взяти визначення ./розбирач;
взяти визначення біб/Друк;
взяти визначення біб/Кодування;

синонім СИМВОЛ_РОЗРИВУ = КД::символи::Розрив;
синонім СИМВОЛ_ПРОПУСКУ = КД::символи::Пропуск;
синонім СИМВОЛ_ОБЕРНЕНА_КОСА = КД::символи::Обернена_похила;
синонім СИМВОЛ_ДВОЛАПКА = КД::символи::Дволапка;
синонім СИМВОЛ_КРАПКИ = КД::символи::Крапка;
синонім СИМВОЛ_0 = КД::символи::Нуль;
синонім СИМВОЛ_1 = КД::символи::Один;
синонім СИМВОЛ_2 = КД::символи::Два;
синонім СИМВОЛ_3 = КД::символи::Три;
синонім СИМВОЛ_4 = КД::символи::Чотири;
синонім СИМВОЛ_5 = КД::символи::Пʼять;
синонім СИМВОЛ_6 = КД::символи::Шість;
синонім СИМВОЛ_7 = КД::символи::Сім;
синонім СИМВОЛ_8 = КД::символи::Вісім;
синонім СИМВОЛ_9 = КД::символи::Девʼять;

секція КЦ {
  секція розбирач {
    зовнішня дія створити(виділяч: адреса<біб::Виділяч>): адреса<Розбирач> {
      змінна розбирач = біб::виділити<Розбирач>(виділяч);
      розбирач.виділяч = виділяч;
      вернути розбирач;
    }
  }
}

секція КЦ {
  секція розбирач {
    дія визначити_розмір_символа_юнікоду(перший_байт: п8): п8 {
      якщо (перший_байт & 128) == 0 {
        вернути 1;
      }
      якщо (перший_байт & 224) == 192 {
        вернути 2;
      }
      якщо (перший_байт & 240) == 224 {
        вернути 3;
      }
      якщо (перший_байт & 248) == 240 {
        вернути 4;
      }
      вернути 0;
    }

    дія перевірити_частину_т8(розбирач: адреса<Розбирач>, кс: т8, значення: т8, поточна_позиція: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      змінна п: позитивне = 0;

    далі:
      якщо п >= кс.розмір {
        вернути ні;
      } інакше якщо поточна_позиція.позиція_в_тексті >= значення.розмір {
        вернути ні;
      } інакше {
        змінна розмір_символа_кс = визначити_розмір_символа_юнікоду(кс.дані[п]);
        змінна розмір_символа = визначити_розмір_символа_юнікоду(значення.дані[поточна_позиція.позиція_в_тексті]);

        якщо розмір_символа_кс != розмір_символа {
          вернути ні;
        }

        якщо розмір_символа == 1 {
          якщо значення.дані[поточна_позиція.позиція_в_тексті] != кс.дані[п] {
            вернути ні;
          }
          якщо п == кс.розмір - 1 {
            вихід_позиції_кінця::вміст = поточна_позиція;
            вернути так;
          }
          поточна_позиція.позиція_в_тексті += 1;
          поточна_позиція.стовпець += 1;
          п += 1;
        } інакше якщо розмір_символа == 2 {
          якщо значення.дані[поточна_позиція.позиція_в_тексті] != кс.дані[п] {
            вернути ні;
          }
          якщо п == кс.розмір - 1 {
            вернути ні;
          }
          поточна_позиція.позиція_в_тексті += 1;
          п += 1;
          якщо значення.дані[поточна_позиція.позиція_в_тексті] != кс.дані[п] {
            вернути ні;
          }
          якщо п == кс.розмір - 1 {
            вихід_позиції_кінця::вміст = поточна_позиція;
            вернути так;
          }
          поточна_позиція.позиція_в_тексті += 1;
          поточна_позиція.стовпець += 1;
          п += 1;
        } інакше якщо розмір_символа == 3 {
          якщо значення.дані[поточна_позиція.позиція_в_тексті] != кс.дані[п] {
            вернути ні;
          }
          якщо п == кс.розмір - 1 {
            вернути ні;
          }
          поточна_позиція.позиція_в_тексті += 1;
          п += 1;
          якщо значення.дані[поточна_позиція.позиція_в_тексті] != кс.дані[п] {
            вернути ні;
          }
          якщо п == кс.розмір - 1 {
            вернути ні;
          }
          поточна_позиція.позиція_в_тексті += 1;
          п += 1;
          якщо значення.дані[поточна_позиція.позиція_в_тексті] != кс.дані[п] {
            вернути ні;
          }
          якщо п == кс.розмір - 1 {
            вихід_позиції_кінця::вміст = поточна_позиція;
            вернути так;
          }
          поточна_позиція.позиція_в_тексті += 1;
          поточна_позиція.стовпець += 1;
          п += 1;
        } інакше якщо розмір_символа == 4 {
          якщо значення.дані[поточна_позиція.позиція_в_тексті] != кс.дані[п] {
            вернути ні;
          }
          якщо п == кс.розмір - 1 {
            вернути ні;
          }
          поточна_позиція.позиція_в_тексті += 1;
          п += 1;
          якщо значення.дані[поточна_позиція.позиція_в_тексті] != кс.дані[п] {
            вернути ні;
          }
          якщо п == кс.розмір - 1 {
            вернути ні;
          }
          поточна_позиція.позиція_в_тексті += 1;
          п += 1;
          якщо значення.дані[поточна_позиція.позиція_в_тексті] != кс.дані[п] {
            вернути ні;
          }
          якщо п == кс.розмір - 1 {
            вернути ні;
          }
          поточна_позиція.позиція_в_тексті += 1;
          п += 1;
          якщо значення.дані[поточна_позиція.позиція_в_тексті] != кс.дані[п] {
            вернути ні;
          }
          якщо п == кс.розмір - 1 {
            вихід_позиції_кінця::вміст = поточна_позиція;
            вернути так;
          }
          поточна_позиція.позиція_в_тексті += 1;
          поточна_позиція.стовпець += 1;
          п += 1;
        } інакше {
          вернути ні;
        }

        стрибнути далі;
      }

      вернути ні;
    }

    дія перевірити_чи_текст_т8(розбирач: адреса<Розбирач>, значення: т8, поточна_позиція: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      якщо значення.дані[поточна_позиція.позиція_в_тексті] != СИМВОЛ_ДВОЛАПКА {
        вернути ні;
      }

      змінна закінчено = ні;
      змінна екран = ні;

      поточна_позиція.позиція_в_тексті += 1;
      поточна_позиція.стовпець += 1;

    далі:
      якщо поточна_позиція.позиція_в_тексті >= значення.розмір {
        вернути ні;
      } інакше {
        якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_ОБЕРНЕНА_КОСА {
          якщо екран {
            екран = ні;
          } інакше {
            екран = так;
          }
        } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_ДВОЛАПКА {
          якщо екран {
            екран = ні;
          } інакше {
            закінчено = так;
            стрибнути вихід;
          }
        } інакше {
          екран = ні;
        }

        змінна розмір_символа = визначити_розмір_символа_юнікоду(значення.дані[поточна_позиція.позиція_в_тексті]);

        якщо розмір_символа == 1 {
          поточна_позиція.позиція_в_тексті += 1;
          поточна_позиція.стовпець += 1;
        } інакше якщо розмір_символа == 2 {
          поточна_позиція.позиція_в_тексті += 2;
          поточна_позиція.стовпець += 1;
        } інакше якщо розмір_символа == 3 {
          поточна_позиція.позиція_в_тексті += 3;
          поточна_позиція.стовпець += 1;
        } інакше якщо розмір_символа == 4 {
          поточна_позиція.позиція_в_тексті += 4;
          поточна_позиція.стовпець += 1;
        } інакше {
          вернути ні;
        }

        стрибнути далі;
      }

    вихід:
      якщо закінчено {
        вихід_позиції_кінця::вміст = поточна_позиція;
        вернути так;
      } інакше {
        вернути ні;
      }
    }

    дія перевірити_чи_число_т8(розбирач: адреса<Розбирач>, значення: т8, поточна_позиція: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_0 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_1 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_2 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_3 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_4 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_5 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_6 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_7 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_8 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_9 {
      } інакше {
        вернути ні;
      }

      поточна_позиція.позиція_в_тексті += 1;
      поточна_позиція.стовпець += 1;

      змінна з_крапкою = ні;
      змінна цифра_після_крапки = ні;

    продовження:
      якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_КРАПКИ {
        якщо з_крапкою {
          вернути ні;
        } інакше {
          з_крапкою = так;
        }
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_0 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_1 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_2 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_3 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_4 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_5 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_6 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_7 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_8 {
      } інакше якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_9 {
      } інакше {
        якщо з_крапкою {
          якщо цифра_після_крапки == ні {
            вернути ні;
          }
        }
        поточна_позиція.позиція_в_тексті -= 1;
        поточна_позиція.стовпець -= 1;
        вихід_позиції_кінця::вміст = поточна_позиція;
        вернути так;
      }

      якщо з_крапкою {
        цифра_після_крапки = так;
      }

    далі:
      поточна_позиція.позиція_в_тексті += 1;
      поточна_позиція.стовпець += 1;

      стрибнути продовження;
    }

    дія перевірити_чи_початок_ідентифікатора_т8(розбирач: адреса<Розбирач>, значення: т8, поточна_позиція: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      якщо перевірити_частину_т8(розбирач, "ʼ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "_", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "А", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Б", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "В", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Г", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Д", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Е", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Є", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ж", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "З", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "И", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "І", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ї", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Й", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "К", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Л", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "М", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Н", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "О", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "П", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Р", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "С", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Т", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "У", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ф", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Х", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ц", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ч", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ш", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Щ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ь", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ю", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Я", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ґ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ё", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ъ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ы", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Э", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "а", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "б", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "в", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "г", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "д", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "е", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "є", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ж", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "з", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "и", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "і", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ї", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "й", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "к", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "л", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "м", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "н", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "о", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "п", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "р", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "с", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "т", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "у", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ф", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "х", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ц", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ч", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ш", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "щ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ь", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ю", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "я", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ґ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ё", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ъ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ы", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "э", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше {
        вернути ні;
      }

      вернути так;
    }

    дія перевірити_чи_продовження_ідентифікатора_т8(розбирач: адреса<Розбирач>, значення: т8, поточна_позиція: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      якщо перевірити_частину_т8(розбирач, "ʼ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "_", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "0", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "1", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "2", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "3", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "4", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "5", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "6", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "7", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "8", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "9", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "А", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Б", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "В", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Г", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Д", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Е", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Є", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ж", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "З", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "И", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "І", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ї", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Й", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "К", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Л", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "М", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Н", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "О", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "П", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Р", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "С", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Т", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "У", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ф", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Х", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ц", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ч", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ш", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Щ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ь", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ю", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Я", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ґ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ё", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ъ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Ы", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "Э", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "а", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "б", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "в", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "г", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "д", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "е", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "є", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ж", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "з", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "и", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "і", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ї", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "й", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "к", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "л", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "м", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "н", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "о", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "п", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "р", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "с", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "т", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "у", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ф", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "х", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ц", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ч", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ш", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "щ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ь", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ю", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "я", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ґ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ё", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ъ", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "ы", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше якщо перевірити_частину_т8(розбирач, "э", значення, поточна_позиція, вихід_позиції_кінця) {
      } інакше {
        вернути ні;
      }

      вернути так;
    }

    дія перевірити_чи_ідентифікатор_т8(розбирач: адреса<Розбирач>, значення: т8, поточна_позиція: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      якщо перевірити_чи_початок_ідентифікатора_т8(розбирач, значення, поточна_позиція, вихід_позиції_кінця) {
        поточна_позиція = вихід_позиції_кінця::вміст;
        поточна_позиція.позиція_в_тексті += 1;
        поточна_позиція.стовпець += 1;

        поки перевірити_чи_продовження_ідентифікатора_т8(розбирач, значення, поточна_позиція, вихід_позиції_кінця) {
          поточна_позиція = вихід_позиції_кінця::вміст;
          поточна_позиція.позиція_в_тексті += 1;
          поточна_позиція.стовпець += 1;
        }

        вернути так;
      }

      вернути ні;
    }

    дія перевірити_чи_ключове_слово_т8(розбирач: адреса<Розбирач>, кс: т8, значення: т8, поточна_позиція: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>, це_ідентифікатор: адреса<логічне>): логічне {
      якщо перевірити_частину_т8(розбирач, кс, значення, поточна_позиція, вихід_позиції_кінця) {
        змінна поточна_позиція_перевірки_продовження_ідентифікатора = вихід_позиції_кінця::вміст;
        поточна_позиція_перевірки_продовження_ідентифікатора.позиція_в_тексті += 1;
        поточна_позиція_перевірки_продовження_ідентифікатора.стовпець += 1;

        змінна позиція_кінця_перевірки_продовження_ідентифікатора: ПозиціяСлова;

        якщо перевірити_чи_продовження_ідентифікатора_т8(розбирач, значення, поточна_позиція_перевірки_продовження_ідентифікатора, позиція_кінця_перевірки_продовження_ідентифікатора::адреса) {
          це_ідентифікатор::вміст = так;
          вернути ні;
        }

        вернути так;
      }

      це_ідентифікатор::вміст = ні;
      вернути ні;
    }

    зовнішня дія розібрати_на_слова(розбирач: адреса<Розбирач>, значення: т8, вихід: адреса<Слова>, вихід_помилки: адреса<ПомилкаРозборуНаСлова>): логічне {
      змінна слова = Слова { 0, пусто, 0 };

      змінна поточна_позиція = ПозиціяСлова { 0, 1, 1 };
      змінна позиція_кінця_слова: ПозиціяСлова;
      змінна це_ідентифікатор = ні;

    знову:
      якщо поточна_позиція.позиція_в_тексті >= значення.розмір {
        стрибнути вихід;
      }

      якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_РОЗРИВУ {
        поточна_позиція.рядок += 1;
        поточна_позиція.стовпець = 0;
        стрибнути далі;
      }

      якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_ПРОПУСКУ {
        стрибнути далі;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "синонім", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаСинонім, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "стрибнути", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаСтрибнути, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "стала", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаСтала, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "змінна", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗмінна, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "ціль", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЦіль, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "якщо", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЯкщо, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "як", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЯк, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "інакше", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаІнакше, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "перелік", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаПерелік, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "поки", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаПоки, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "дія", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаДія, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "структура", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаСтруктура, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "зовнішня", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗовнішня, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "місцева", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаМісцева, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "секція", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаСекція, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "взяти", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаВзяти, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_чи_ключове_слово_т8(розбирач, "вернути", значення, поточна_позиція, позиція_кінця_слова::адреса, це_ідентифікатор::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаВернути, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }
      якщо це_ідентифікатор {
        стрибнути перевірка_ідентифікатора;
      }

      якщо перевірити_частину_т8(розбирач, "(", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакВідкритаДужка, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, ")", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакЗакритаДужка, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "[", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакВідкритаКвадратнаДужка, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "]", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакЗакритаКвадратнаДужка, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "{", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаВідкритаФігурнаДужка, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "}", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗакритаФігурнаДужка, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "<", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакМенше, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, ">", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакБільше, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "=", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакРівно, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "+", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакПлюс, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "-", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакМінус, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "*", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакПомножити, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "//", значення, поточна_позиція, поточна_позиція::адреса) {
        поточна_позиція.позиція_в_тексті += 1;
        поточна_позиція.стовпець += 1;

        поки поточна_позиція.позиція_в_тексті < значення.розмір {
          якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_РОЗРИВУ {
            стрибнути знову;
          }
          поточна_позиція.позиція_в_тексті += 1;
          поточна_позиція.стовпець += 1;
        }

        стрибнути знову;
      }

      якщо перевірити_частину_т8(розбирач, "/*", значення, поточна_позиція, поточна_позиція::адреса) {
        поточна_позиція.позиція_в_тексті += 1;
        поточна_позиція.стовпець += 1;

        поки поточна_позиція.позиція_в_тексті < значення.розмір {
          якщо значення.дані[поточна_позиція.позиція_в_тексті] == СИМВОЛ_РОЗРИВУ {
            поточна_позиція.позиція_в_тексті += 1;
            поточна_позиція.рядок += 1;
            поточна_позиція.стовпець = 1;
          } інакше якщо перевірити_частину_т8(розбирач, "*/", значення, поточна_позиція, поточна_позиція::адреса) {
            стрибнути далі;
          } інакше {
            поточна_позиція.позиція_в_тексті += 1;
            поточна_позиція.стовпець += 1;
          }
        }

        стрибнути знову;
      }

      якщо перевірити_частину_т8(розбирач, "/", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакПоділити, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "%", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакВідсоток, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "∧", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакПірамідка, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "~", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакТильда, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "&", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакАмперсанд, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "|", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакПряма, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, ".", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакКрапка, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, ":", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакДвокрапка, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, ",", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакКома, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, ";", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакКрапкакома, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "?", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакПитання, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_частину_т8(розбирач, "!", значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЗнакОклик, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_чи_текст_т8(розбирач, значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаТекст, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      якщо перевірити_чи_число_т8(розбирач, значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаЧисло, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      стрибнути перевірка_ідентифікатора;

    перевірка_ідентифікатора:
      якщо перевірити_чи_ідентифікатор_т8(розбирач, значення, поточна_позиція, позиція_кінця_слова::адреса) {
        покласти_в_слова(розбирач, слова::адреса, Слово { ВидСловаІдентифікатор, поточна_позиція, позиція_кінця_слова });
        поточна_позиція = позиція_кінця_слова;
        стрибнути далі;
      }

      стрибнути помилка;

    далі:
      поточна_позиція.позиція_в_тексті += 1;
      поточна_позиція.стовпець += 1;

      стрибнути знову;

    помилка:
      вихід_помилки::вміст = ПомилкаРозборуНаСлова {
        позиція = поточна_позиція
      };
      вернути ні;

    вихід:
      покласти_в_слова(розбирач, слова::адреса, Слово { КІНЕЦЬ_СЛІВ, ПозиціяСлова { поточна_позиція.позиція_в_тексті - 1, поточна_позиція.рядок, поточна_позиція.стовпець - 1 }, ПозиціяСлова { поточна_позиція.позиція_в_тексті - 1, поточна_позиція.рядок, поточна_позиція.стовпець - 1 } });
      вихід::вміст = слова;

      вернути так;
    }

    дія надрукувати_слово(розбирач: адреса<Розбирач>, значення: т8, слово: Слово) {
      якщо слово.вид == КІНЕЦЬ_СЛІВ {
        біб::вивести("КІНЕЦЬ_СЛІВ");
      } інакше якщо слово.вид == ВидСловаВзяти {
        біб::вивести("ВидСловаВзяти");
      } інакше якщо слово.вид == ВидСловаВизначення {
        біб::вивести("ВидСловаВизначення");
      } інакше якщо слово.вид == ВидСловаВластивість {
        біб::вивести("ВидСловаВластивість");
      } інакше якщо слово.вид == ВидСловаВернути {
        біб::вивести("ВидСловаВернути");
      } інакше якщо слово.вид == ВидСловаДія {
        біб::вивести("ВидСловаДія");
      } інакше якщо слово.вид == ВидСловаЄ {
        біб::вивести("ВидСловаЄ");
      } інакше якщо слово.вид == ВидСловаЗовнішня {
        біб::вивести("ВидСловаЗовнішня");
      } інакше якщо слово.вид == ВидСловаМісцева {
        біб::вивести("ВидСловаМісцева");
      } інакше якщо слово.вид == ВидСловаІнакше {
        біб::вивести("ВидСловаІнакше");
      } інакше якщо слово.вид == ВидСловаСекція {
        біб::вивести("ВидСловаСекція");
      } інакше якщо слово.вид == ВидСловаНе {
        біб::вивести("ВидСловаНе");
      } інакше якщо слово.вид == ВидСловаПоки {
        біб::вивести("ВидСловаПоки");
      } інакше якщо слово.вид == ВидСловаПерелік {
        біб::вивести("ВидСловаПерелік");
      } інакше якщо слово.вид == ВидСловаСтруктура {
        біб::вивести("ВидСловаСтруктура");
      } інакше якщо слово.вид == ВидСловаЯк {
        біб::вивести("ВидСловаЯк");
      } інакше якщо слово.вид == ВидСловаЯкщо {
        біб::вивести("ВидСловаЯкщо");
      } інакше якщо слово.вид == ВидСловаЗнакРівно {
        біб::вивести("ВидСловаЗнакРівно");
      } інакше якщо слово.вид == ВидСловаЗнакБільше {
        біб::вивести("ВидСловаЗнакБільше");
      } інакше якщо слово.вид == ВидСловаЗнакМенше {
        біб::вивести("ВидСловаЗнакМенше");
      } інакше якщо слово.вид == ВидСловаЗнакКрапка {
        біб::вивести("ВидСловаЗнакКрапка");
      } інакше якщо слово.вид == ВидСловаЗнакПлюс {
        біб::вивести("ВидСловаЗнакПлюс");
      } інакше якщо слово.вид == ВидСловаЗнакМінус {
        біб::вивести("ВидСловаЗнакМінус");
      } інакше якщо слово.вид == ВидСловаЗнакПомножити {
        біб::вивести("ВидСловаЗнакПомножити");
      } інакше якщо слово.вид == ВидСловаЗнакПоділити {
        біб::вивести("ВидСловаЗнакПоділити");
      } інакше якщо слово.вид == ВидСловаЗнакВідсоток {
        біб::вивести("ВидСловаЗнакВідсоток");
      } інакше якщо слово.вид == ВидСловаЗнакПірамідка {
        біб::вивести("ВидСловаЗнакПірамідка");
      } інакше якщо слово.вид == ВидСловаЗнакАмперсанд {
        біб::вивести("ВидСловаЗнакАмперсанд");
      } інакше якщо слово.вид == ВидСловаЗнакПряма {
        біб::вивести("ВидСловаЗнакПряма");
      } інакше якщо слово.вид == ВидСловаЗнакВідкритаДужка {
        біб::вивести("ВидСловаЗнакВідкритаДужка");
      } інакше якщо слово.вид == ВидСловаЗнакЗакритаДужка {
        біб::вивести("ВидСловаЗнакЗакритаДужка");
      } інакше якщо слово.вид == ВидСловаЗнакВідкритаКвадратнаДужка {
        біб::вивести("ВидСловаЗнакВідкритаКвадратнаДужка");
      } інакше якщо слово.вид == ВидСловаЗнакЗакритаКвадратнаДужка {
        біб::вивести("ВидСловаЗнакЗакритаКвадратнаДужка");
      } інакше якщо слово.вид == ВидСловаЗнакПитання {
        біб::вивести("ВидСловаЗнакПитання");
      } інакше якщо слово.вид == ВидСловаЗнакДвокрапка {
        біб::вивести("ВидСловаЗнакДвокрапка");
      } інакше якщо слово.вид == ВидСловаЗнакТильда {
        біб::вивести("ВидСловаЗнакТильда");
      } інакше якщо слово.вид == ВидСловаЗнакОднолапка {
        біб::вивести("ВидСловаЗнакОднолапка");
      } інакше якщо слово.вид == ВидСловаЗнакДволапка {
        біб::вивести("ВидСловаЗнакДволапка");
      } інакше якщо слово.вид == ВидСловаЗнакОклик {
        біб::вивести("ВидСловаЗнакОклик");
      } інакше якщо слово.вид == ВидСловаЗнакКома {
        біб::вивести("ВидСловаЗнакКома");
      } інакше якщо слово.вид == ВидСловаЗнакМіжряд {
        біб::вивести("ВидСловаЗнакМіжряд");
      } інакше якщо слово.вид == ВидСловаЧисло {
        біб::вивести("ВидСловаЧисло");
      } інакше якщо слово.вид == ВидСловаСимвол {
        біб::вивести("ВидСловаСимвол");
      } інакше якщо слово.вид == ВидСловаТекст {
        біб::вивести("ВидСловаТекст");
      } інакше якщо слово.вид == ВидСловаКоментар {
        біб::вивести("ВидСловаКоментар");
      } інакше якщо слово.вид == ВидСловаБагаторядковийКоментар {
        біб::вивести("ВидСловаБагаторядковийКоментар");
      } інакше якщо слово.вид == ВидСловаІдентифікатор {
        біб::вивести("ВидСловаІдентифікатор");
      } інакше якщо слово.вид == ВидСловаЗмінна {
        біб::вивести("ВидСловаЗмінна");
      } інакше якщо слово.вид == ВидСловаЦіль {
        біб::вивести("ВидСловаЦіль");
      } інакше якщо слово.вид == ВидСловаЗнакКрапкакома {
        біб::вивести("ВидСловаЗнакКрапкакома");
      } інакше якщо слово.вид == ВидСловаВідкритаФігурнаДужка {
        біб::вивести("ВидСловаВідкритаФігурнаДужка");
      } інакше якщо слово.вид == ВидСловаЗакритаФігурнаДужка {
        біб::вивести("ВидСловаЗакритаФігурнаДужка");
      } інакше якщо слово.вид == ВидСловаСинонім {
        біб::вивести("ВидСловаСинонім");
      } інакше якщо слово.вид == ВидСловаСтрибнути {
        біб::вивести("ВидСловаСтрибнути");
      } інакше якщо слово.вид == ВидСловаСтала {
        біб::вивести("ВидСловаСтала");
      } інакше {
        біб::вивести("--- НЕВІДОМИЙ ЗНАК --- ");
      }
      біб::вивести(" [");
      біб::вивести_позитивне(слово.позиція_початку.позиція_в_тексті);
      біб::вивести("]");
      біб::вивести_позитивне(слово.позиція_початку.рядок);
      біб::вивести(":");
      біб::вивести_позитивне(слово.позиція_початку.стовпець);
      біб::вивести(" [");
      біб::вивести_позитивне(слово.позиція_кінця.позиція_в_тексті);
      біб::вивести("]");
      біб::вивести_позитивне(слово.позиція_кінця.рядок);
      біб::вивести(":");
      біб::надрукувати_позитивне(слово.позиція_кінця.стовпець);
    }

    зовнішня дія надрукувати_слова(розбирач: адреса<Розбирач>, значення: т8, слова: Слова) {
      змінна п: позитивне = 0;

      поки п < слова.розмір {
        надрукувати_слово(розбирач, значення, слова.дані[п]);

        п += 1;
      }
    }
  }
}

секція КЦ {
  секція розбирач {
    зовнішня дія звільнити_сполуку(розбирач: адреса<Розбирач>, сполука: адреса<Сполука>) {
      якщо сполука == пусто {
        вернути;
      }

      якщо сполука.вид == ВидСполукиЦіль {
        змінна дані = сполука.дані як ДаніСполукиЦіль;
        звільнити_сполуку(розбирач, дані.тип);
        звільнити_сполуку(розбирач, дані.значення);
      } інакше якщо сполука.вид == ВидСполукиДія {
        змінна дані = сполука.дані як ДаніСполукиДія;
        звільнити_параметри(розбирач, дані.параметри);
        звільнити_сполуку(розбирач, дані.тип_результату);
        якщо дані.тіло.заповнено == позитивне(так) {
          звільнити_сполуки(розбирач, дані.тіло.значення);
        }
      } інакше якщо сполука.вид == ВидСполукиСтруктура {
        змінна дані = сполука.дані як ДаніСполукиСтруктура;
        звільнити_параметри(розбирач, дані.параметри);
      } інакше якщо сполука.вид == ВидСполукиЗаписати {
        змінна дані = сполука.дані як ДаніСполукиЗаписати;
        звільнити_сполуку(розбирач, дані.значення);
      } інакше якщо сполука.вид == ВидСполукиПрочитати {
        змінна дані = сполука.дані як ДаніСполукиПрочитати;
      } інакше якщо сполука.вид == ВидСполукиОтриматиВластивість {
        змінна дані = сполука.дані як ДаніСполукиОтриматиВластивість;
        звільнити_сполуку(розбирач, дані.ліво);
      } інакше якщо сполука.вид == ВидСполукиЗмінитиВластивість {
        змінна дані = сполука.дані як ДаніСполукиЗмінитиВластивість;
        звільнити_сполуку(розбирач, дані.ліво);
        звільнити_сполуку(розбирач, дані.значення);
      } інакше якщо сполука.вид == ВидСполукиЗмінитиСекційнуВластивість {
        змінна дані = сполука.дані як ДаніСполукиЗмінитиСекційнуВластивість;
        звільнити_сполуку(розбирач, дані.ліво);
        звільнити_сполуку(розбирач, дані.значення);
      } інакше якщо сполука.вид == ВидСполукиВаріативнийТип {
        змінна дані = сполука.дані як ДаніСполукиВаріативнийТип;
        звільнити_сполуки(розбирач, дані.типи);
      } інакше якщо сполука.вид == ВидСполукиШаблон {
        змінна дані = сполука.дані як ДаніСполукиШаблон;
        звільнити_параметри_шаблону(розбирач, дані.параметри);
        звільнити_сполуку(розбирач, дані.значення);
      } інакше якщо сполука.вид == ВидСполукиТипДії {
        змінна дані = сполука.дані як ДаніСполукиТипДії;
        звільнити_параметри(розбирач, дані.параметри);
        звільнити_сполуку(розбирач, дані.тип_результату);
      } інакше якщо сполука.вид == ВидСполукиЗмінитиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиЗмінитиЕлемент;
        звільнити_сполуку(розбирач, дані.ліво);
        звільнити_сполуку(розбирач, дані.ключ);
        звільнити_сполуку(розбирач, дані.значення);
      } інакше якщо сполука.вид == ВидСполукиСинонім {
        змінна дані = сполука.дані як ДаніСполукиСинонім;
        звільнити_сполуку(розбирач, дані.значення);
      } інакше якщо сполука.вид == ВидСполукиВернути {
        змінна дані = сполука.дані як ДаніСполукиВернути;
        звільнити_сполуку(розбирач, дані.значення);
      } інакше якщо сполука.вид == ВидСполукиЯкщо {
        змінна дані = сполука.дані як ДаніСполукиЯкщо;
        звільнити_сполуку(розбирач, дані.умова);
        звільнити_сполуки(розбирач, дані.тіло);
        звільнити_сполуки(розбирач, дані.тіло_інакше);
      } інакше якщо сполука.вид == ВидСполукиПоки {
        змінна дані = сполука.дані як ДаніСполукиПоки;
        звільнити_сполуку(розбирач, дані.умова);
        звільнити_сполуки(розбирач, дані.тіло);
      } інакше якщо сполука.вид == ВидСполукиСекція {
        змінна дані = сполука.дані як ДаніСполукиСекція;
        звільнити_сполуки(розбирач, дані.тіло);
      } інакше якщо сполука.вид == ВидСполукиКрок {
        змінна дані = сполука.дані як ДаніСполукиКрок;
      } інакше якщо сполука.вид == ВидСполукиСтрибнути {
        змінна дані = сполука.дані як ДаніСполукиСтрибнути;
      } інакше якщо сполука.вид == ВидСполукиВзяти {
        змінна дані = сполука.дані як ДаніСполукиВзяти;
        звільнити_елементи_взяти(розбирач, дані.шлях);
      } інакше якщо сполука.вид == ВидСполукиОтриматиСекційнуВластивість {
        змінна дані = сполука.дані як ДаніСполукиОтриматиСекційнуВластивість;
        звільнити_сполуку(розбирач, дані.ліво);
      } інакше якщо сполука.вид == ВидСполукиОтриматиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиОтриматиЕлемент;
        звільнити_сполуку(розбирач, дані.ліво);
        звільнити_сполуку(розбирач, дані.ключ);
      } інакше якщо сполука.вид == ВидСполукиВиконатиШаблон {
        змінна дані = сполука.дані як ДаніСполукиВиконатиШаблон;
        звільнити_сполуку(розбирач, дані.ліво);
        звільнити_аргументи(розбирач, дані.аргументи);
      } інакше якщо сполука.вид == ВидСполукиВиконатиДію {
        змінна дані = сполука.дані як ДаніСполукиВиконатиДію;
        звільнити_сполуку(розбирач, дані.ліво);
        звільнити_аргументи(розбирач, дані.аргументи);
      } інакше якщо сполука.вид == ВидСполукиОднооперація {
        змінна дані = сполука.дані як ДаніСполукиОднооперація;
        звільнити_сполуку(розбирач, дані.значення);
      } інакше якщо сполука.вид == ВидСполукиОперація {
        змінна дані = сполука.дані як ДаніСполукиОперація;
        звільнити_сполуку(розбирач, дані.ліво);
        звільнити_сполуку(розбирач, дані.право);
      } інакше якщо сполука.вид == ВидСполукиЧисло {
        змінна дані = сполука.дані як ДаніСполукиЧисло;
      } інакше якщо сполука.вид == ВидСполукиТекст {
        змінна дані = сполука.дані як ДаніСполукиТекст;
      } інакше якщо сполука.вид == ВидСполукиОбʼєкт {
        змінна дані = сполука.дані як ДаніСполукиОбʼєкт;
        звільнити_сполуку(розбирач, дані.ліво);
        звільнити_аргументи(розбирач, дані.аргументи);
      } інакше якщо сполука.вид == ВидСполукиПерелік {
        змінна дані = сполука.дані як ДаніСполукиПерелік;
        звільнити_елементи_переліка(розбирач, дані.елементи);
      }

      звільнити(розбирач, сполука);
    }

    зовнішня дія клонувати_сполуку(розбирач: адреса<Розбирач>, сполука: адреса<Сполука>): адреса<Сполука> {
      якщо сполука == пусто {
        вернути пусто;
      }

      змінна клон = виділити<Сполука>(розбирач);
      клон.вид = сполука.вид;
      клон.місцезнаходження = сполука.місцезнаходження;

      якщо сполука.вид == ВидСполукиЦіль {
        змінна дані = сполука.дані як ДаніСполукиЦіль;
        дані.тип = клонувати_сполуку(розбирач, дані.тип);
        дані.значення = клонувати_сполуку(розбирач, дані.значення);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиДія {
        змінна дані = сполука.дані як ДаніСполукиДія;
        дані.параметри = клонувати_параметри(розбирач, дані.параметри);
        дані.тип_результату = клонувати_сполуку(розбирач, дані.тип_результату);
        якщо дані.тіло.заповнено == позитивне(так) {
          дані.тіло.значення = клонувати_сполуки(розбирач, дані.тіло.значення);
        }
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиСтруктура {
        змінна дані = сполука.дані як ДаніСполукиСтруктура;
        дані.параметри = клонувати_параметри(розбирач, дані.параметри);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиЗаписати {
        змінна дані = сполука.дані як ДаніСполукиЗаписати;
        дані.значення = клонувати_сполуку(розбирач, дані.значення);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиПрочитати {
        змінна дані = сполука.дані як ДаніСполукиПрочитати;
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиОтриматиВластивість {
        змінна дані = сполука.дані як ДаніСполукиОтриматиВластивість;
        дані.ліво = клонувати_сполуку(розбирач, дані.ліво);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиЗмінитиВластивість {
        змінна дані = сполука.дані як ДаніСполукиЗмінитиВластивість;
        дані.ліво = клонувати_сполуку(розбирач, дані.ліво);
        дані.значення = клонувати_сполуку(розбирач, дані.значення);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиЗмінитиСекційнуВластивість {
        змінна дані = сполука.дані як ДаніСполукиЗмінитиСекційнуВластивість;
        дані.ліво = клонувати_сполуку(розбирач, дані.ліво);
        дані.значення = клонувати_сполуку(розбирач, дані.значення);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиВаріативнийТип {
        змінна дані = сполука.дані як ДаніСполукиВаріативнийТип;
        дані.типи = клонувати_сполуки(розбирач, дані.типи);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиШаблон {
        змінна дані = сполука.дані як ДаніСполукиШаблон;
        дані.параметри = клонувати_параметри_шаблону(розбирач, дані.параметри);
        дані.значення = клонувати_сполуку(розбирач, дані.значення);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиТипДії {
        змінна дані = сполука.дані як ДаніСполукиТипДії;
        дані.параметри = клонувати_параметри(розбирач, дані.параметри);
        дані.тип_результату = клонувати_сполуку(розбирач, дані.тип_результату);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиЗмінитиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиЗмінитиЕлемент;
        дані.ліво = клонувати_сполуку(розбирач, дані.ліво);
        дані.ключ = клонувати_сполуку(розбирач, дані.ключ);
        дані.значення = клонувати_сполуку(розбирач, дані.значення);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиСинонім {
        змінна дані = сполука.дані як ДаніСполукиСинонім;
        дані.значення = клонувати_сполуку(розбирач, дані.значення);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиВернути {
        змінна дані = сполука.дані як ДаніСполукиВернути;
        дані.значення = клонувати_сполуку(розбирач, дані.значення);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиЯкщо {
        змінна дані = сполука.дані як ДаніСполукиЯкщо;
        дані.умова = клонувати_сполуку(розбирач, дані.умова);
        дані.тіло = клонувати_сполуки(розбирач, дані.тіло);
        дані.тіло_інакше = клонувати_сполуки(розбирач, дані.тіло_інакше);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиПоки {
        змінна дані = сполука.дані як ДаніСполукиПоки;
        дані.умова = клонувати_сполуку(розбирач, дані.умова);
        дані.тіло = клонувати_сполуки(розбирач, дані.тіло);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиСекція {
        змінна дані = сполука.дані як ДаніСполукиСекція;
        дані.тіло = клонувати_сполуки(розбирач, дані.тіло);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиКрок {
        змінна дані = сполука.дані як ДаніСполукиКрок;
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиСтрибнути {
        змінна дані = сполука.дані як ДаніСполукиСтрибнути;
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиВзяти {
        змінна дані = сполука.дані як ДаніСполукиВзяти;
        дані.шлях = клонувати_елементи_взяти(розбирач, дані.шлях);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиОтриматиСекційнуВластивість {
        змінна дані = сполука.дані як ДаніСполукиОтриматиСекційнуВластивість;
        дані.ліво = клонувати_сполуку(розбирач, дані.ліво);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиОтриматиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиОтриматиЕлемент;
        дані.ліво = клонувати_сполуку(розбирач, дані.ліво);
        дані.ключ = клонувати_сполуку(розбирач, дані.ключ);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиВиконатиШаблон {
        змінна дані = сполука.дані як ДаніСполукиВиконатиШаблон;
        дані.ліво = клонувати_сполуку(розбирач, дані.ліво);
        дані.аргументи = клонувати_аргументи(розбирач, дані.аргументи);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиВиконатиДію {
        змінна дані = сполука.дані як ДаніСполукиВиконатиДію;
        дані.ліво = клонувати_сполуку(розбирач, дані.ліво);
        дані.аргументи = клонувати_аргументи(розбирач, дані.аргументи);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиОднооперація {
        змінна дані = сполука.дані як ДаніСполукиОднооперація;
        дані.значення = клонувати_сполуку(розбирач, дані.значення);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиОперація {
        змінна дані = сполука.дані як ДаніСполукиОперація;
        дані.ліво = клонувати_сполуку(розбирач, дані.ліво);
        дані.право = клонувати_сполуку(розбирач, дані.право);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиЧисло {
        змінна дані = сполука.дані як ДаніСполукиЧисло;
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиТекст {
        змінна дані = сполука.дані як ДаніСполукиТекст;
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиОбʼєкт {
        змінна дані = сполука.дані як ДаніСполукиОбʼєкт;
        дані.ліво = клонувати_сполуку(розбирач, дані.ліво);
        дані.аргументи = клонувати_аргументи(розбирач, дані.аргументи);
        клон.дані = дані;
      } інакше якщо сполука.вид == ВидСполукиПерелік {
        змінна дані = сполука.дані як ДаніСполукиПерелік;
        дані.елементи = клонувати_елементи_переліка(розбирач, дані.елементи);
        клон.дані = дані;
      }

      вернути клон;
    }

    зовнішня дія клонувати_сполуки(розбирач: адреса<Розбирач>, сполуки: Сполуки): Сполуки {
      змінна клон = Сполуки { сполуки.розмір, виділити_памʼять<адреса<Сполука>>(розбирач, сполуки.розмір), сполуки.розмір };

      змінна п: позитивне = 0;
      поки п < сполуки.розмір {
        клон.дані[п] = клонувати_сполуку(розбирач, сполуки.дані[п]);

        п += 1;
      }

      вернути клон;
    }

    зовнішня дія клонувати_параметр(розбирач: адреса<Розбирач>, параметр: Параметр): Параметр {
      параметр.тип = клонувати_сполуку(розбирач, параметр.тип);
      вернути параметр;
    }

    зовнішня дія клонувати_параметри(розбирач: адреса<Розбирач>, параметри: Параметри): Параметри {
      змінна клон = Параметри { параметри.розмір, виділити_памʼять<Параметр>(розбирач, параметри.розмір), параметри.розмір };

      змінна п: позитивне = 0;
      поки п < параметри.розмір {
        клон.дані[п] = клонувати_параметр(розбирач, параметри.дані[п]);

        п += 1;
      }

      вернути клон;
    }

    зовнішня дія клонувати_параметр_шаблону(розбирач: адреса<Розбирач>, параметр_шаблону: ПараметрШаблону): ПараметрШаблону {
      параметр_шаблону.тип = клонувати_сполуку(розбирач, параметр_шаблону.тип);
      вернути параметр_шаблону;
    }

    зовнішня дія клонувати_параметри_шаблону(розбирач: адреса<Розбирач>, параметри_шаблону: ПараметриШаблону): ПараметриШаблону {
      змінна клон = ПараметриШаблону { параметри_шаблону.розмір, виділити_памʼять<ПараметрШаблону>(розбирач, параметри_шаблону.розмір), параметри_шаблону.розмір };

      змінна п: позитивне = 0;
      поки п < параметри_шаблону.розмір {
        клон.дані[п] = клонувати_параметр_шаблону(розбирач, параметри_шаблону.дані[п]);

        п += 1;
      }

      вернути клон;
    }

    зовнішня дія клонувати_ідентифікатори(розбирач: адреса<Розбирач>, ідентифікатори: Ідентифікатори): Ідентифікатори {
      змінна клон = Ідентифікатори { ідентифікатори.розмір, виділити_памʼять<Ідентифікатор>(розбирач, ідентифікатори.розмір), ідентифікатори.розмір };

      змінна п: позитивне = 0;
      поки п < ідентифікатори.розмір {
        клон.дані[п] = ідентифікатори.дані[п];

        п += 1;
      }

      вернути клон;
    }

    зовнішня дія клонувати_аргумент(розбирач: адреса<Розбирач>, аргумент: Аргумент): Аргумент {
      аргумент.значення = клонувати_сполуку(розбирач, аргумент.значення);
      вернути аргумент;
    }

    зовнішня дія клонувати_аргументи(розбирач: адреса<Розбирач>, аргументи: Аргументи): Аргументи {
      змінна клон = Аргументи { аргументи.розмір, виділити_памʼять<Аргумент>(розбирач, аргументи.розмір), аргументи.розмір, аргументи.автозаповнити };

      змінна п: позитивне = 0;
      поки п < аргументи.розмір {
        клон.дані[п] = клонувати_аргумент(розбирач, аргументи.дані[п]);

        п += 1;
      }

      вернути клон;
    }

    зовнішня дія клонувати_елемент_переліка(розбирач: адреса<Розбирач>, елемент_переліка: ЕлементПереліка): ЕлементПереліка {
      елемент_переліка.параметри = клонувати_параметри(розбирач, елемент_переліка.параметри);
      елемент_переліка.значення = клонувати_сполуку(розбирач, елемент_переліка.значення);
      вернути елемент_переліка;
    }

    зовнішня дія клонувати_елементи_переліка(розбирач: адреса<Розбирач>, елементи_переліка: ЕлементиПереліка): ЕлементиПереліка {
      змінна клон = ЕлементиПереліка { елементи_переліка.розмір, виділити_памʼять<ЕлементПереліка>(розбирач, елементи_переліка.розмір), елементи_переліка.розмір };

      змінна п: позитивне = 0;
      поки п < елементи_переліка.розмір {
        клон.дані[п] = клонувати_елемент_переліка(розбирач, елементи_переліка.дані[п]);

        п += 1;
      }

      вернути клон;
    }

    зовнішня дія клонувати_елемент_взяти(розбирач: адреса<Розбирач>, елемент_взяти: ЕлементВзяти): ЕлементВзяти {
      вернути елемент_взяти;
    }

    зовнішня дія клонувати_елементи_взяти(розбирач: адреса<Розбирач>, елементи_взяти: ЕлементиВзяти): ЕлементиВзяти {
      змінна клон = ЕлементиВзяти { елементи_взяти.розмір, виділити_памʼять<ЕлементВзяти>(розбирач, елементи_взяти.розмір), елементи_взяти.розмір };

      змінна п: позитивне = 0;
      поки п < елементи_взяти.розмір {
        клон.дані[п] = клонувати_елемент_взяти(розбирач, елементи_взяти.дані[п]);

        п += 1;
      }

      вернути клон;
    }
  }

  секція розбирач {
    дія спробувати_розібрати_частинку(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_атом(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_молекулу(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_молекулу__хвіст(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, позиція_початку_молекули: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, сполука_атома: адреса<Сполука>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_однооперацію(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_тип(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_операцію(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, очікує_закінчення_шаблону: логічне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_операцію_1(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, очікує_закінчення_шаблону: логічне, сполука_ліво: адреса<Сполука>, мін: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_значення(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, як_елемент_тіла: логічне, очікує_закінчення_шаблону: логічне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_параметр(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<Параметр>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_параметри(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вид_слова_розділення: позитивне, вид_слова_закінчення: позитивне, вихід: адреса<Параметри>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_параметр_шаблону(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<ПараметрШаблону>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_параметри_шаблону(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вид_слова_розділення: позитивне, вид_слова_закінчення: позитивне, вихід: адреса<ПараметриШаблону>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_аргумент(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, очікує_закінчення_шаблону: логічне, вихід: адреса<Аргумент>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_аргумент_шаблону(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, очікує_закінчення_шаблону: логічне, вихід: адреса<Аргумент>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_аргументи(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, дозволити_трикрапки: логічне, очікує_закінчення_шаблону: логічне, вид_слова_розділення: позитивне, вид_слова_закінчення: позитивне, вихід: адреса<Аргументи>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_аргументи_шаблону(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, дозволити_трикрапки: логічне, очікує_закінчення_шаблону: логічне, вид_слова_розділення: позитивне, вид_слова_закінчення: позитивне, вихід: адреса<Аргументи>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_дію(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_структуру(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_елемент_переліка(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<ЕлементПереліка>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_елементи_переліка(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вид_слова_розділення: позитивне, вид_слова_закінчення: позитивне, вихід: адреса<ЕлементиПереліка>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_перелік(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_ціль(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_синонім(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_вернути(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_якщо(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_поки(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_секцію(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_крок(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_стрибнути(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_взяти(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_тіло(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вид_слова_закінчення: позитивне, вихід: адреса<Сполуки>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_елемент_тіла(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;

    дія спробувати_розібрати_частинку(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакВідкритаДужка {
        поточна_позиція += 1;

        змінна сполука_значення: адреса<Сполука> = пусто;
        змінна позиція_помилки_значення: позитивне = 0;

        якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки_значення::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_значення;
          вернути ні;
        }
        поточна_позиція += 1;

        якщо слова.дані[поточна_позиція].вид != ВидСловаЗнакЗакритаДужка {
          звільнити_сполуку(розбирач, сполука_значення);
          вихід_позиції_помилки::вміст = поточна_позиція;
          вернути ні;
        }

        вихід::вміст = сполука_значення;
        вихід_позиції_кінця::вміст = поточна_позиція;
        вернути так;
      }

      якщо слова.дані[поточна_позиція].вид == ВидСловаІдентифікатор {
        поточна_позиція += 1;
        якщо слова.дані[поточна_позиція].вид == ВидСловаТекст {
          змінна дані_сполуки_текст = ДаніСполукиТекст {
            префікс = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { поточна_позиція - 1 } },
            позиція_слова = поточна_позиція,
          };

          змінна сполука_тексту = виділити<Сполука>(розбирач);
          сполука_тексту.вид = ВидСполукиТекст;
          сполука_тексту.дані = дані_сполуки_текст;
          сполука_тексту.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

          вихід::вміст = сполука_тексту;
          вихід_позиції_кінця::вміст = поточна_позиція;
          вернути так;
        } інакше {
          поточна_позиція -= 1;
        }

        змінна дані_сполуки_прочитати = ДаніСполукиПрочитати {
          ідентифікатор = Ідентифікатор { поточна_позиція },
        };

        змінна сполука_прочитати = виділити<Сполука>(розбирач);
        сполука_прочитати.вид = ВидСполукиПрочитати;
        сполука_прочитати.дані = дані_сполуки_прочитати;
        сполука_прочитати.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

        вихід::вміст = сполука_прочитати;
        вихід_позиції_кінця::вміст = поточна_позиція;
        вернути так;
      }

      якщо слова.дані[поточна_позиція].вид == ВидСловаЧисло {
        змінна дані_сполуки_число = ДаніСполукиЧисло {
          позиція_слова = поточна_позиція,
        };

        змінна сполука_числа = виділити<Сполука>(розбирач);
        сполука_числа.вид = ВидСполукиЧисло;
        сполука_числа.дані = дані_сполуки_число;
        сполука_числа.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

        вихід::вміст = сполука_числа;
        вихід_позиції_кінця::вміст = поточна_позиція;
        вернути так;
      }

      якщо слова.дані[поточна_позиція].вид == ВидСловаТекст {
        змінна дані_сполуки_текст = ДаніСполукиТекст {
          префікс = можливо<Ідентифікатор> { позитивне(ні), Ідентифікатор { 0 } },
          позиція_слова = поточна_позиція,
        };

        змінна сполука_тексту = виділити<Сполука>(розбирач);
        сполука_тексту.вид = ВидСполукиТекст;
        сполука_тексту.дані = дані_сполуки_текст;
        сполука_тексту.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

        вихід::вміст = сполука_тексту;
        вихід_позиції_кінця::вміст = поточна_позиція;
        вернути так;
      }

      вихід_позиції_помилки::вміст = поточна_позиція;
      вернути ні;
    }

    дія спробувати_розібрати_атом(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      якщо спробувати_розібрати_частинку(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, вихід_позиції_помилки) {
        вернути так;
      }

      змінна поточна_позиція = позиція_початку;

      вихід_позиції_помилки::вміст = поточна_позиція;
      вернути ні;
    }

    //
    // --- з рекурсією ---
    // молекула = (молекула ('.' ідентифікатор)) | атом;
    //
    // --- без рекурсії ---
    // молекула = атом хвіст_молекули;
    // хвіст_молекули = ('.' ідентифікатор хвіст_молекули) | ;
    //
    дія спробувати_розібрати_молекулу(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна поточна_позиція = позиція_початку;
      змінна сполука_атома: адреса<Сполука> = пусто;
      змінна позиція_помилки_атома: позитивне = 0;

      якщо спробувати_розібрати_атом(розбирач, слова, поточна_позиція, сполука_атома::адреса, поточна_позиція::адреса, позиція_помилки_атома::адреса) {
        поточна_позиція += 1;

        змінна сполука_хвоста: адреса<Сполука> = пусто;
        змінна позиція_помилки_хвоста: позитивне = 0;

        якщо спробувати_розібрати_молекулу__хвіст(розбирач, слова, поточна_позиція, позиція_початку, сполука_хвоста::адреса, поточна_позиція::адреса, сполука_атома, позиція_помилки_хвоста::адреса) {
          вихід::вміст = сполука_хвоста;
          вихід_позиції_кінця::вміст = поточна_позиція;

          вернути так;
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_хвоста;
          стрибнути вихід_з_помилкою;
        }

        вихід::вміст = сполука_атома;
        вихід_позиції_кінця::вміст = поточна_позиція;

        вернути так;
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_атома;
        стрибнути вихід_з_помилкою;
      }

    вихід_з_помилкою:
      звільнити_сполуку(розбирач, сполука_атома);
      вернути ні;
    }

    дія спробувати_розібрати_молекулу__хвіст(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, позиція_початку_молекули: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, сполука_атома: адреса<Сполука>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапка { // отримати властивість
        поточна_позиція += 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаІдентифікатор {
          змінна сполука_отримати_властивість = виділити<Сполука>(розбирач);
          сполука_отримати_властивість.вид = ВидСполукиОтриматиВластивість;
          сполука_отримати_властивість.дані = ДаніСполукиОтриматиВластивість {
            ліво = сполука_атома,
            ідентифікатор = Ідентифікатор { поточна_позиція }
          };
          сполука_отримати_властивість.місцезнаходження = Місцезнаходження { позиція_початку_молекули, поточна_позиція };

          поточна_позиція += 1;

          змінна позиція_помилки_молекули_хвоста: позитивне = 0;

          якщо спробувати_розібрати_молекулу__хвіст(розбирач, слова, поточна_позиція, позиція_початку_молекули, вихід, вихід_позиції_кінця, сполука_отримати_властивість, позиція_помилки_молекули_хвоста::адреса) {
            вернути так;
          } інакше {
            звільнити_сполуку(розбирач, сполука_отримати_властивість);
            вихід_позиції_помилки::вміст = позиція_помилки_молекули_хвоста;
            вернути ні;
          }
        }

        вихід_позиції_помилки::вміст = поточна_позиція;
        вернути ні;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакДвокрапка { // отримати секційну властивість
        поточна_позиція += 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакДвокрапка {
          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид == ВидСловаІдентифікатор {
            змінна сполука_отримати_секційну_властивість = виділити<Сполука>(розбирач);
            сполука_отримати_секційну_властивість.вид = ВидСполукиОтриматиСекційнуВластивість;
            сполука_отримати_секційну_властивість.дані = ДаніСполукиОтриматиСекційнуВластивість {
              ліво = сполука_атома,
              ідентифікатор = Ідентифікатор { поточна_позиція }
            };
            сполука_отримати_секційну_властивість.місцезнаходження = Місцезнаходження { позиція_початку_молекули, поточна_позиція };

            поточна_позиція += 1;

            змінна позиція_помилки_молекули_хвоста: позитивне = 0;

            якщо спробувати_розібрати_молекулу__хвіст(розбирач, слова, поточна_позиція, позиція_початку_молекули, вихід, вихід_позиції_кінця, сполука_отримати_секційну_властивість, позиція_помилки_молекули_хвоста::адреса) {
              вернути так;
            } інакше {
              звільнити_сполуку(розбирач, сполука_отримати_секційну_властивість);
              вихід_позиції_помилки::вміст = позиція_помилки_молекули_хвоста;
              вернути ні;
            }
          }

          вихід_позиції_помилки::вміст = поточна_позиція;
          вернути ні;
        } інакше {
          вихід_позиції_помилки::вміст = поточна_позиція;
          вернути ні;
        }
      } якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакВідкритаКвадратнаДужка { // отримати елемент
        поточна_позиція += 1;

        змінна сполука_ключа: адреса<Сполука> = пусто;
        змінна позиція_помилки_ключа: позитивне = 0;
        якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_ключа::адреса, поточна_позиція::адреса, позиція_помилки_ключа::адреса) {
          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид != ВидСловаЗнакЗакритаКвадратнаДужка {
            звільнити_сполуку(розбирач, сполука_ключа);
            вихід_позиції_помилки::вміст = поточна_позиція;
            вернути ні;
          }

          змінна сполука_отримати_елемент = виділити<Сполука>(розбирач);
          сполука_отримати_елемент.вид = ВидСполукиОтриматиЕлемент;
          сполука_отримати_елемент.дані = ДаніСполукиОтриматиЕлемент {
            ліво = сполука_атома,
            ключ = сполука_ключа
          };
          сполука_отримати_елемент.місцезнаходження = Місцезнаходження { позиція_початку_молекули, поточна_позиція };

          поточна_позиція += 1;

          змінна позиція_помилки_молекули_хвоста: позитивне = 0;

          якщо спробувати_розібрати_молекулу__хвіст(розбирач, слова, поточна_позиція, позиція_початку_молекули, вихід, вихід_позиції_кінця, сполука_отримати_елемент, позиція_помилки_молекули_хвоста::адреса) {
            вернути так;
          } інакше {
            звільнити_сполуку(розбирач, сполука_отримати_елемент);
            вихід_позиції_помилки::вміст = позиція_помилки_молекули_хвоста;
            вернути ні;
          }
        }

        вихід_позиції_помилки::вміст = позиція_помилки_ключа;
        вернути ні;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакМенше { // виконати шаблон
        поточна_позиція += 1;

        змінна аргументи_шаблону = Аргументи { 0, пусто, 0, позитивне(ні) };
        змінна позиція_помилки_аргументів_шаблону: позитивне = 0;
        якщо спробувати_розібрати_аргументи_шаблону(розбирач, слова, поточна_позиція, ні, так, ВидСловаЗнакКома, ВидСловаЗнакБільше, аргументи_шаблону::адреса, поточна_позиція::адреса, позиція_помилки_аргументів_шаблону::адреса) {
          змінна сполука_виконати_шаблон = виділити<Сполука>(розбирач);
          сполука_виконати_шаблон.вид = ВидСполукиВиконатиШаблон;
          сполука_виконати_шаблон.дані = ДаніСполукиВиконатиШаблон {
            ліво = сполука_атома,
            аргументи = аргументи_шаблону
          };
          сполука_виконати_шаблон.місцезнаходження = Місцезнаходження { позиція_початку_молекули, поточна_позиція };

          поточна_позиція += 1;

          змінна позиція_помилки_молекули_хвоста: позитивне = 0;

          якщо спробувати_розібрати_молекулу__хвіст(розбирач, слова, поточна_позиція, позиція_початку_молекули, вихід, вихід_позиції_кінця, сполука_виконати_шаблон, позиція_помилки_молекули_хвоста::адреса) {
            вернути так;
          } інакше {
            звільнити_сполуку(розбирач, сполука_виконати_шаблон);
            вихід_позиції_помилки::вміст = позиція_помилки_молекули_хвоста;
            вернути ні;
          }
        }

        вихід::вміст = сполука_атома;
        вихід_позиції_кінця::вміст = поточна_позиція - 2;
        вернути так;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакВідкритаДужка { // виконати дію
        поточна_позиція += 1;

        змінна аргументи_дії = Аргументи { 0, пусто, 0, позитивне(ні) };
        змінна позиція_помилки_аргументів_дії: позитивне = 0;
        якщо спробувати_розібрати_аргументи(розбирач, слова, поточна_позиція, ні, ні, ВидСловаЗнакКома, ВидСловаЗнакЗакритаДужка, аргументи_дії::адреса, поточна_позиція::адреса, позиція_помилки_аргументів_дії::адреса) {
          змінна сполука_виконати_дію = виділити<Сполука>(розбирач);
          сполука_виконати_дію.вид = ВидСполукиВиконатиДію;
          сполука_виконати_дію.дані = ДаніСполукиВиконатиДію {
            ліво = сполука_атома,
            аргументи = аргументи_дії
          };
          сполука_виконати_дію.місцезнаходження = Місцезнаходження { позиція_початку_молекули, поточна_позиція };

          поточна_позиція += 1;

          змінна позиція_помилки_молекули_хвоста: позитивне = 0;

          якщо спробувати_розібрати_молекулу__хвіст(розбирач, слова, поточна_позиція, позиція_початку_молекули, вихід, вихід_позиції_кінця, сполука_виконати_дію, позиція_помилки_молекули_хвоста::адреса) {
            вернути так;
          } інакше {
            звільнити_сполуку(розбирач, сполука_виконати_дію);
            вихід_позиції_помилки::вміст = позиція_помилки_молекули_хвоста;
            вернути ні;
          }
        }

        вихід_позиції_помилки::вміст = позиція_помилки_аргументів_дії;
        вернути ні;
      }

      вихід::вміст = сполука_атома;
      вихід_позиції_кінця::вміст = поточна_позиція - 1;
      вернути так;
    }

    дія спробувати_розібрати_однооперацію(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_однодоперація = ДаніСполукиОднооперація {
        вид = 0,
        значення = пусто
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакОклик {
        дані_сполуки_однодоперація.вид = ВидОдноопераціїЗаперечення;
        поточна_позиція += 1;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакПлюс {
        дані_сполуки_однодоперація.вид = ВидОдноопераціїПлюс;
        поточна_позиція += 1;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакМінус {
        дані_сполуки_однодоперація.вид = ВидОдноопераціїМінус;
        поточна_позиція += 1;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакТильда {
        дані_сполуки_однодоперація.вид = ВидОдноопераціїДвійковеЗаперечення;
        поточна_позиція += 1;
      } інакше {
        вернути спробувати_розібрати_молекулу(розбирач, слова, поточна_позиція, вихід, вихід_позиції_кінця, вихід_позиції_помилки);
      }

      змінна позиція_помилки_значення: позитивне = 0;

      якщо спробувати_розібрати_однооперацію(розбирач, слова, поточна_позиція, дані_сполуки_однодоперація.значення::адреса, поточна_позиція::адреса, позиція_помилки_значення::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_значення;
        вернути ні;
      }

      змінна сполука_однооперації = виділити<Сполука>(розбирач);
      сполука_однооперації.вид = ВидСполукиОднооперація;
      сполука_однооперації.дані = дані_сполуки_однодоперація;
      сполука_однооперації.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      вихід::вміст = сполука_однооперації;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;
    }

    дія спробувати_розібрати_тип_дії(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_тип_дії = ДаніСполукиТипДії {
        параметри = Параметри { 0, пусто, 0 },
        тип_результату = пусто,
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаЗнакВідкритаДужка {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      змінна позиція_помилки_параметрів: позитивне = 0;
      якщо спробувати_розібрати_параметри(розбирач, слова, поточна_позиція, ВидСловаЗнакКома, ВидСловаЗнакЗакритаДужка, дані_сполуки_тип_дії.параметри::адреса, поточна_позиція::адреса, позиція_помилки_параметрів::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_параметрів;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакМінус {
        поточна_позиція += 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакБільше {
          поточна_позиція += 1;

          змінна позиція_помилки_типу: позитивне = 0;

          якщо спробувати_розібрати_тип(розбирач, слова, поточна_позиція, дані_сполуки_тип_дії.тип_результату::адреса, поточна_позиція::адреса, позиція_помилки_типу::адреса) == ні {
            вихід_позиції_помилки::вміст = позиція_помилки_типу;
            стрибнути вихід_з_помилкою;
          }
        } інакше {
          вихід_позиції_помилки::вміст = поточна_позиція;
          стрибнути вихід_з_помилкою;
        }
      } інакше {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }

    успішний_вихід:
      змінна сполука_типу_дії = виділити<Сполука>(розбирач);
      сполука_типу_дії.вид = ВидСполукиТипДії;
      сполука_типу_дії.дані = дані_сполуки_тип_дії;
      сполука_типу_дії.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      вихід::вміст = сполука_типу_дії;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      звільнити_параметри(розбирач, дані_сполуки_тип_дії.параметри);
      звільнити_сполуку(розбирач, дані_сполуки_тип_дії.тип_результату);
      вернути ні;
    }

    дія спробувати_розібрати_тип(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна поточна_позиція = позиція_початку;
      змінна сполука_молекули: адреса<Сполука> = пусто;
      змінна позиція_помилки_молекули: позитивне = 0;
      змінна типи = Сполуки { 0, пусто, 0 };

      поки поточна_позиція < слова.розмір {
        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакВідкритаДужка {
          якщо спробувати_розібрати_тип_дії(розбирач, слова, поточна_позиція, сполука_молекули::адреса, поточна_позиція::адреса, позиція_помилки_молекули::адреса) {
            стрибнути ок_тип_молекула;
          }

          змінна збережена_поточна_позиція = поточна_позиція;

          поточна_позиція += 1;
          якщо спробувати_розібрати_тип(розбирач, слова, поточна_позиція, сполука_молекули::адреса, поточна_позиція::адреса, позиція_помилки_молекули::адреса) {
            поточна_позиція += 1;

            якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакЗакритаДужка {
              стрибнути ок_тип_молекула;
            } інакше {
              звільнити_сполуку(розбирач, сполука_молекули);
              поточна_позиція = збережена_поточна_позиція;
              сполука_молекули = пусто;
              позиція_помилки_молекули = 0;
            }
          } інакше {
            поточна_позиція -= 1;
          }
        }

        якщо спробувати_розібрати_молекулу(розбирач, слова, поточна_позиція, сполука_молекули::адреса, поточна_позиція::адреса, позиція_помилки_молекули::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_молекули;
          вернути ні;
        }

      ок_тип_молекула:
        покласти_в_сполуки(розбирач, типи::адреса, сполука_молекули);

        поточна_позиція += 1;
        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакПряма {
          поточна_позиція += 1;
        } інакше {
          поточна_позиція -= 1;
          стрибнути успішний_вихід;
        }
      }

    успішний_вихід:
      якщо типи.розмір == 1 {
        вихід::вміст = типи.дані[0];
        вихід_позиції_кінця::вміст = поточна_позиція;
        звільнити_памʼять(розбирач, типи.дані);
        вернути так;
      } інакше {
        змінна сполука_варіативного_типу = виділити<Сполука>(розбирач);
        сполука_варіативного_типу.вид = ВидСполукиВаріативнийТип;
        сполука_варіативного_типу.дані = ДаніСполукиВаріативнийТип {
          типи = типи
        };
        сполука_варіативного_типу.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
        вихід::вміст = сполука_варіативного_типу;
        вихід_позиції_кінця::вміст = поточна_позиція;
        вернути так;
      }
    }

    дія спробувати_розібрати_операцію(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, очікує_закінчення_шаблону: логічне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна поточна_позиція = позиція_початку;

      змінна сполука_ліво: адреса<Сполука> = пусто;
      змінна позиція_помилки_ліво: позитивне = 0;

      якщо спробувати_розібрати_однооперацію(розбирач, слова, поточна_позиція, сполука_ліво::адреса, поточна_позиція::адреса, позиція_помилки_ліво::адреса) {
        поточна_позиція += 1;

        змінна сполука_результату: адреса<Сполука> = пусто;
        змінна позиція_помилки_сполуки_результату: позитивне = 0;

        якщо спробувати_розібрати_операцію_1(розбирач, слова, поточна_позиція, очікує_закінчення_шаблону, сполука_ліво, 0, сполука_результату::адреса, поточна_позиція::адреса, позиція_помилки_сполуки_результату::адреса) {
          вихід::вміст = сполука_результату;
          вихід_позиції_кінця::вміст = поточна_позиція;
          вернути так;
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_сполуки_результату;
          стрибнути звільнити_і_вийти;
        }
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_ліво;
        стрибнути звільнити_і_вийти;
      }

      звільнити_і_вийти:
      звільнити_сполуку(розбирач, сполука_ліво);
      вернути ні;
    }

    структура ІнформаціяОперації {
      вид_операції: позитивне;
      кількість_слів: позитивне;
      пріоритет: позитивне;
    }

    дія дізнатись_інформацію_операції(слова: Слова, позиція: позитивне): ІнформаціяОперації {
      якщо слова.дані[позиція].вид == КІНЕЦЬ_СЛІВ {
        вернути ІнформаціяОперації { 0, 0, 0 };
      }
      змінна вид = слова.дані[позиція].вид;
      змінна вид_далі = слова.дані[позиція + 1].вид;
      якщо вид == ВидСловаЯк {
        вернути ІнформаціяОперації { ВидОпераціїЯк, 1, 255 };
      }
      якщо вид == ВидСловаЗнакПлюс {
        якщо вид_далі == ВидСловаЗнакРівно {
          вернути ІнформаціяОперації { 0, 0, 0 };
        }
        вернути ІнформаціяОперації { ВидОпераціїДодавання, 1, 97 };
      }
      якщо вид == ВидСловаЗнакМінус {
        якщо вид_далі == ВидСловаЗнакРівно {
          вернути ІнформаціяОперації { 0, 0, 0 };
        }
        вернути ІнформаціяОперації { ВидОпераціїВіднімання, 1, 97 };
      }
      якщо вид == ВидСловаЗнакПомножити {
        якщо вид_далі == ВидСловаЗнакРівно {
          вернути ІнформаціяОперації { 0, 0, 0 };
        }
        якщо вид_далі == ВидСловаЗнакПомножити {
          вернути ІнформаціяОперації { ВидОпераціїПіднесенняДоСтепеня, 2, 100 };
        }
        вернути ІнформаціяОперації { ВидОпераціїМноження, 1, 98 };
      }
      якщо вид == ВидСловаЗнакПоділити {
        якщо вид_далі == ВидСловаЗнакРівно {
          вернути ІнформаціяОперації { 0, 0, 0 };
        }
        якщо вид_далі == ВидСловаЗнакПоділити {
          вернути ІнформаціяОперації { ВидОпераціїДіленняНаціло, 2, 99 };
        }
        вернути ІнформаціяОперації { ВидОпераціїДілення, 1, 98 };
      }
      якщо вид == ВидСловаЗнакВідсоток {
        якщо вид_далі == ВидСловаЗнакРівно {
          вернути ІнформаціяОперації { 0, 0, 0 };
        }
        вернути ІнформаціяОперації { ВидОпераціїМодуль, 1, 98 };
      }
      якщо вид == ВидСловаЗнакБільше {
        якщо вид_далі == ВидСловаЗнакБільше {
          вернути ІнформаціяОперації { ВидОпераціїЗсувВправо, 2, 96 };
        }
        якщо вид_далі == ВидСловаЗнакРівно {
          вернути ІнформаціяОперації { ВидОпераціїБільшеРівне, 2, 95 };
        }
        вернути ІнформаціяОперації { ВидОпераціїБільше, 1, 95 };
      }
      якщо вид == ВидСловаЗнакМенше {
        якщо вид_далі == ВидСловаЗнакМенше {
          вернути ІнформаціяОперації { ВидОпераціїЗсувВліво, 2, 96 };
        }
        якщо вид_далі == ВидСловаЗнакРівно {
          вернути ІнформаціяОперації { ВидОпераціїМеншеРівне, 2, 95 };
        }
        вернути ІнформаціяОперації { ВидОпераціїМенше, 1, 95 };
      }
//      якщо вид == ВидСловаБільше {
//        вернути ІнформаціяОперації { ВидОпераціїБільше, 1, 95 };
//      }
//      якщо вид == ВидСловаМенше {
//        вернути ІнформаціяОперації { ВидОпераціїМенше, 1, 95 };
//      }
//      якщо вид == ВидСловаМістить {
//        вернути ІнформаціяОперації { ВидОпераціїМістить, 1, 93 };
//      }
//      якщо вид == ВидСловаЄ {
//        вернути ІнформаціяОперації { ВидОпераціїЄ, 1, 93 };
//      }
//      якщо вид == ВидСловаНе {
//        якщо вид_далі == ВидСловаБільше {
//          вернути ІнформаціяОперації { ВидОпераціїМеншеРівне, 2, 95 };
//        }
//        якщо вид_далі == ВидСловаМенше {
//          вернути ІнформаціяОперації { ВидОпераціїБільшеРівне, 2, 95 };
//        }
//        якщо вид_далі == ВидСловаРівно {
//          вернути ІнформаціяОперації { ВидОпераціїНерівне, 2, 94 };
//        }
//        якщо вид_далі == ВидСловаМістить {
//          вернути ІнформаціяОперації { ВидОпераціїНеМістить, 2, 93 };
//        }
//        якщо вид_далі == ВидСловаЄ {
//          вернути ІнформаціяОперації { ВидОпераціїНеЄ, 2, 93 };
//        }
//      }
      якщо вид == ВидСловаЗнакОклик {
        якщо вид_далі == ВидСловаЗнакРівно {
          вернути ІнформаціяОперації { ВидОпераціїНерівне, 2, 94 };
        }
      }
      якщо вид == ВидСловаЗнакРівно {
        якщо вид_далі == ВидСловаЗнакРівно {
          вернути ІнформаціяОперації { ВидОпераціїРівне, 2, 94 };
        }
      }
//      якщо вид == ВидСловаРівно {
//        вернути ІнформаціяОперації { ВидОпераціїРівне, 1, 94 };
//      }
      якщо вид == ВидСловаЗнакАмперсанд {
        якщо вид_далі == ВидСловаЗнакРівно {
          вернути ІнформаціяОперації { 0, 0, 0 };
        }
        якщо вид_далі == ВидСловаЗнакАмперсанд {
          вернути ІнформаціяОперації { ВидОпераціїІ, 2, 89 };
        }
        вернути ІнформаціяОперації { ВидОпераціїДІ, 1, 92 };
      }
//      якщо вид == ВидСловаІ {
//        вернути ІнформаціяОперації { ВидОпераціїІ, 1, 89 };
//      }
      якщо вид == ВидСловаЗнакПірамідка {
        якщо вид_далі == ВидСловаЗнакРівно {
          вернути ІнформаціяОперації { 0, 0, 0 };
        }
        вернути ІнформаціяОперації { ВидОпераціїВАБО, 1, 91 };
      }
      якщо вид == ВидСловаЗнакПряма {
        якщо вид_далі == ВидСловаЗнакРівно {
          вернути ІнформаціяОперації { 0, 0, 0 };
        }
        якщо вид_далі == ВидСловаЗнакПряма {
          вернути ІнформаціяОперації { ВидОпераціїАБО, 2, 88 };
        }
        вернути ІнформаціяОперації { ВидОпераціїДАБО, 1, 90 };
      }
//      якщо вид == ВидСловаАбо {
//        вернути ІнформаціяОперації { ВидОпераціїАБО, 1, 88 };
//      }
      вернути ІнформаціяОперації { 0, 0, 0 };
    }

    дія перевірити_оп1(інформація_операції: ІнформаціяОперації, мін: позитивне): логічне {
      якщо інформація_операції.вид_операції == 0 {
        вернути ні;
      }
      якщо інформація_операції.пріоритет >= мін {
        вернути так;
      }
      вернути ні;
    }

    дія перевірити_оп2(інформація_операції: ІнформаціяОперації, збережена_інформація_операції: ІнформаціяОперації): логічне {
      якщо інформація_операції.вид_операції == 0 {
        вернути ні;
      }
      якщо інформація_операції.пріоритет > збережена_інформація_операції.пріоритет {
        вернути так;
      }
      якщо інформація_операції.вид_операції == ВидОпераціїПіднесенняДоСтепеня {
        вернути інформація_операції.пріоритет == збережена_інформація_операції.пріоритет;
      }
      вернути ні;
    }

    дія спробувати_розібрати_операцію_1(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, очікує_закінчення_шаблону: логічне, сполука_ліво: адреса<Сполука>, мін: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна поточна_позиція = позиція_початку;

      змінна інформація_операції = дізнатись_інформацію_операції(слова, поточна_позиція);

      поки перевірити_оп1(інформація_операції, мін) {
        якщо очікує_закінчення_шаблону {
          якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакБільше {
            вихід::вміст = сполука_ліво;
            вихід_позиції_кінця::вміст = поточна_позиція - 1;
            вернути так;
          }
        }

        змінна збережена_інформація_операції = інформація_операції;
        змінна збережена_поточна_позиція = поточна_позиція;

        поточна_позиція += інформація_операції.кількість_слів;

        змінна сполука_право: адреса<Сполука> = пусто;
        змінна позиція_помилки_право: позитивне = 0;

        якщо інформація_операції.вид_операції == ВидОпераціїЯк {
          якщо спробувати_розібрати_тип(розбирач, слова, поточна_позиція, сполука_право::адреса, поточна_позиція::адреса, позиція_помилки_право::адреса) == ні {
            вихід_позиції_помилки::вміст = позиція_помилки_право;
            вернути ні;
          }
        } інакше {
          якщо спробувати_розібрати_однооперацію(розбирач, слова, поточна_позиція, сполука_право::адреса, поточна_позиція::адреса, позиція_помилки_право::адреса) == ні {
            вихід_позиції_помилки::вміст = позиція_помилки_право;
            вернути ні;
          }
        }

        поточна_позиція += 1;
        інформація_операції = дізнатись_інформацію_операції(слова, поточна_позиція);

        поки перевірити_оп2(інформація_операції, збережена_інформація_операції) {
          змінна рсп = ні;
          змінна позиція_помилки_рсп: позитивне = 0;

          якщо інформація_операції.пріоритет > збережена_інформація_операції.пріоритет {
            рсп = спробувати_розібрати_операцію_1(розбирач, слова, поточна_позиція, очікує_закінчення_шаблону, сполука_право, збережена_інформація_операції.пріоритет + 1, сполука_право::адреса, поточна_позиція::адреса, позиція_помилки_рсп::адреса);
          } інакше {
            рсп = спробувати_розібрати_операцію_1(розбирач, слова, поточна_позиція, очікує_закінчення_шаблону, сполука_право, збережена_інформація_операції.пріоритет, сполука_право::адреса, поточна_позиція::адреса, позиція_помилки_рсп::адреса);
          }

          якщо рсп {
          } інакше {
            звільнити_сполуку(розбирач, сполука_право);
            вихід_позиції_помилки::вміст = позиція_помилки_рсп;
            вернути ні;
          }

          поточна_позиція += 1;
          інформація_операції = дізнатись_інформацію_операції(слова, поточна_позиція);
        }

        змінна нова_сполука_ліво = виділити<Сполука>(розбирач);
        нова_сполука_ліво.вид = ВидСполукиОперація;
        нова_сполука_ліво.дані = ДаніСполукиОперація {
          вид = збережена_інформація_операції.вид_операції,
          ліво = сполука_ліво,
          право = сполука_право,
        };
        нова_сполука_ліво.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція - 1 };

        сполука_ліво = нова_сполука_ліво;

        інформація_операції = дізнатись_інформацію_операції(слова, поточна_позиція);
      }

      вихід::вміст = сполука_ліво;
      вихід_позиції_кінця::вміст = поточна_позиція - 1;
      вернути так;
    }

    дія спробувати_розібрати_параметр(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<Параметр>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна параметр = Параметр {
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), Ідентифікатор { 0 } },
        тип = пусто
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == ВидСловаІдентифікатор {
        поточна_позиція += 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакДвокрапка {
          параметр.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { поточна_позиція - 1 } };

          поточна_позиція += 1;
        } інакше {
          поточна_позиція -= 1;
        }
      }

      змінна позиція_помилки_типу: позитивне = 0;

      якщо спробувати_розібрати_тип(розбирач, слова, поточна_позиція, параметр.тип::адреса, поточна_позиція::адреса, позиція_помилки_типу::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_типу;
        вернути ні;
      }

      вихід::вміст = параметр;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;
    }

    дія спробувати_розібрати_параметри(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вид_слова_розділення: позитивне, вид_слова_закінчення: позитивне, вихід: адреса<Параметри>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна параметри = Параметри { 0, пусто, 0 };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
        вихід::вміст = параметри;
        вихід_позиції_кінця::вміст = поточна_позиція;

        вернути так;
      }

      поки поточна_позиція < слова.розмір {
        змінна параметр: Параметр;
        змінна позиція_помилки_параметра: позитивне = 0;

        якщо спробувати_розібрати_параметр(розбирач, слова, поточна_позиція, параметр::адреса, поточна_позиція::адреса, позиція_помилки_параметра::адреса) {
          покласти_в_параметри(розбирач, параметри::адреса, параметр);

          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
            поточна_позиція += 1;

            якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
              звільнити_параметри(розбирач, параметри);
              вихід_позиції_помилки::вміст = поточна_позиція;

              вернути ні;
            } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
              вихід::вміст = параметри;
              вихід_позиції_кінця::вміст = поточна_позиція;

              вернути так;
            } інакше {
              поточна_позиція -= 1;
            }
          } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
            вихід::вміст = параметри;
            вихід_позиції_кінця::вміст = поточна_позиція;

            вернути так;
          } інакше {
            звільнити_параметри(розбирач, параметри);
            вихід_позиції_помилки::вміст = поточна_позиція;

            вернути ні;
          }
        } інакше {
          звільнити_параметри(розбирач, параметри);
          вихід_позиції_помилки::вміст = позиція_помилки_параметра;

          вернути ні;
        }

        поточна_позиція += 1;
      }

      звільнити_параметри(розбирач, параметри);
      вихід_позиції_помилки::вміст = поточна_позиція - 1;

      вернути ні;
    }

    дія спробувати_розібрати_параметр_шаблону(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<ПараметрШаблону>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна параметр_шаблону = ПараметрШаблону {
        ідентифікатор = Ідентифікатор { 0 },
        тип = пусто
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаІдентифікатор {
        вихід_позиції_помилки::вміст = поточна_позиція;
        вернути ні;
      }
      параметр_шаблону.ідентифікатор = Ідентифікатор { поточна_позиція };
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакДвокрапка {
        поточна_позиція += 1;

        змінна позиція_помилки_типу: позитивне = 0;

        якщо спробувати_розібрати_тип(розбирач, слова, поточна_позиція, параметр_шаблону.тип::адреса, поточна_позиція::адреса, позиція_помилки_типу::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_типу;
          вернути ні;
        }
      } інакше {
        поточна_позиція -= 1;
      }

      вихід::вміст = параметр_шаблону;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;
    }

    дія спробувати_розібрати_параметри_шаблону(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вид_слова_розділення: позитивне, вид_слова_закінчення: позитивне, вихід: адреса<ПараметриШаблону>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна параметри_шаблону = ПараметриШаблону { 0, пусто, 0 };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
        вихід::вміст = параметри_шаблону;
        вихід_позиції_кінця::вміст = поточна_позиція;

        вернути так;
      }

      поки поточна_позиція < слова.розмір {
        змінна параметр_шаблону: ПараметрШаблону;
        змінна позиція_помилки_параметра: позитивне = 0;

        якщо спробувати_розібрати_параметр_шаблону(розбирач, слова, поточна_позиція, параметр_шаблону::адреса, поточна_позиція::адреса, позиція_помилки_параметра::адреса) {
          покласти_в_параметри_шаблону(розбирач, параметри_шаблону::адреса, параметр_шаблону);

          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
            поточна_позиція += 1;

            якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
              звільнити_параметри_шаблону(розбирач, параметри_шаблону);
              вихід_позиції_помилки::вміст = поточна_позиція;

              вернути ні;
            } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
              вихід::вміст = параметри_шаблону;
              вихід_позиції_кінця::вміст = поточна_позиція;

              вернути так;
            } інакше {
              поточна_позиція -= 1;
            }
          } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
            вихід::вміст = параметри_шаблону;
            вихід_позиції_кінця::вміст = поточна_позиція;

            вернути так;
          } інакше {
            звільнити_параметри_шаблону(розбирач, параметри_шаблону);
            вихід_позиції_помилки::вміст = поточна_позиція;

            вернути ні;
          }
        } інакше {
          звільнити_параметри_шаблону(розбирач, параметри_шаблону);
          вихід_позиції_помилки::вміст = позиція_помилки_параметра;

          вернути ні;
        }

        поточна_позиція += 1;
      }

      звільнити_параметри_шаблону(розбирач, параметри_шаблону);
      вихід_позиції_помилки::вміст = поточна_позиція - 1;

      вернути ні;
    }

    дія спробувати_розібрати_аргумент(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, очікує_закінчення_шаблону: логічне, вихід: адреса<Аргумент>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна аргумент = Аргумент {
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), Ідентифікатор { 0 } },
        значення = пусто
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == ВидСловаІдентифікатор {
        поточна_позиція += 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакРівно {
          аргумент.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { поточна_позиція - 1 } };

          поточна_позиція += 1;
        } інакше {
          поточна_позиція -= 1;
        }
      }

      змінна позиція_помилки_значення: позитивне = 0;

      якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, очікує_закінчення_шаблону, аргумент.значення::адреса, поточна_позиція::адреса, позиція_помилки_значення::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_значення;
        вернути ні;
      }

      вихід::вміст = аргумент;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;
    }

    дія спробувати_розібрати_аргумент_шаблону(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, очікує_закінчення_шаблону: логічне, вихід: адреса<Аргумент>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна аргумент = Аргумент {
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), Ідентифікатор { 0 } },
        значення = пусто
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == ВидСловаІдентифікатор {
        поточна_позиція += 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакРівно {
          аргумент.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { поточна_позиція - 1 } };

          поточна_позиція += 1;
        } інакше {
          поточна_позиція -= 1;
        }
      }

      змінна позиція_помилки_значення: позитивне = 0;

      якщо спробувати_розібрати_тип(розбирач, слова, поточна_позиція, аргумент.значення::адреса, поточна_позиція::адреса, позиція_помилки_значення::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_значення;
        вернути ні;
      }

      вихід::вміст = аргумент;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;
    }

    дія спробувати_розібрати_аргументи(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, дозволити_трикрапки: логічне, очікує_закінчення_шаблону: логічне, вид_слова_розділення: позитивне, вид_слова_закінчення: позитивне, вихід: адреса<Аргументи>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна аргументи = Аргументи { 0, пусто, 0, позитивне(ні) };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
        вихід::вміст = аргументи;
        вихід_позиції_кінця::вміст = поточна_позиція;

        вернути так;
      }

      поки поточна_позиція < слова.розмір {
        змінна аргумент: Аргумент;
        змінна позиція_помилки_аргумента: позитивне;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапка {
          поточна_позиція += 1;
          якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапка {
            поточна_позиція += 1;
            якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапка {
              аргументи.автозаповнити = позитивне(так);

              поточна_позиція += 1;

              якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
                поточна_позиція += 1;

                якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
                  звільнити_аргументи(розбирач, аргументи);
                  вихід_позиції_помилки::вміст = поточна_позиція;

                  вернути ні;
                } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
                  вихід::вміст = аргументи;
                  вихід_позиції_кінця::вміст = поточна_позиція;

                  вернути так;
                } інакше {
                  поточна_позиція -= 1;
                }
              } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
                вихід::вміст = аргументи;
                вихід_позиції_кінця::вміст = поточна_позиція;

                вернути так;
              } інакше {
                звільнити_аргументи(розбирач, аргументи);
                вихід_позиції_помилки::вміст = поточна_позиція;

                вернути ні;
              }
            } інакше {
              звільнити_аргументи(розбирач, аргументи);
              вихід_позиції_помилки::вміст = поточна_позиція;

              вернути ні;
            }
          } інакше {
            звільнити_аргументи(розбирач, аргументи);
            вихід_позиції_помилки::вміст = поточна_позиція;

            вернути ні;
          }
        } інакше якщо спробувати_розібрати_аргумент(розбирач, слова, поточна_позиція, очікує_закінчення_шаблону, аргумент::адреса, поточна_позиція::адреса, позиція_помилки_аргумента::адреса) {
          покласти_в_аргументи(розбирач, аргументи::адреса, аргумент);

          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
            поточна_позиція += 1;

            якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
              звільнити_аргументи(розбирач, аргументи);
              вихід_позиції_помилки::вміст = поточна_позиція;

              вернути ні;
            } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
              вихід::вміст = аргументи;
              вихід_позиції_кінця::вміст = поточна_позиція;

              вернути так;
            } інакше {
              поточна_позиція -= 1;
            }
          } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
            вихід::вміст = аргументи;
            вихід_позиції_кінця::вміст = поточна_позиція;

            вернути так;
          } інакше {
            звільнити_аргументи(розбирач, аргументи);
            вихід_позиції_помилки::вміст = поточна_позиція;

            вернути ні;
          }
        } інакше {
          звільнити_аргументи(розбирач, аргументи);
          вихід_позиції_помилки::вміст = позиція_помилки_аргумента;

          вернути ні;
        }

        поточна_позиція += 1;
      }

      звільнити_аргументи(розбирач, аргументи);
      вихід_позиції_помилки::вміст = поточна_позиція - 1;

      вернути ні;
    }

    дія спробувати_розібрати_аргументи_шаблону(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, дозволити_трикрапки: логічне, очікує_закінчення_шаблону: логічне, вид_слова_розділення: позитивне, вид_слова_закінчення: позитивне, вихід: адреса<Аргументи>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна аргументи = Аргументи { 0, пусто, 0, позитивне(ні) };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
        вихід::вміст = аргументи;
        вихід_позиції_кінця::вміст = поточна_позиція;

        вернути так;
      }

      поки поточна_позиція < слова.розмір {
        змінна аргумент: Аргумент;
        змінна позиція_помилки_аргумента: позитивне;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапка {
          поточна_позиція += 1;
          якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапка {
            поточна_позиція += 1;
            якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапка {
              аргументи.автозаповнити = позитивне(так);

              поточна_позиція += 1;

              якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
                поточна_позиція += 1;

                якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
                  звільнити_аргументи(розбирач, аргументи);
                  вихід_позиції_помилки::вміст = поточна_позиція;

                  вернути ні;
                } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
                  вихід::вміст = аргументи;
                  вихід_позиції_кінця::вміст = поточна_позиція;

                  вернути так;
                } інакше {
                  поточна_позиція -= 1;
                }
              } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
                вихід::вміст = аргументи;
                вихід_позиції_кінця::вміст = поточна_позиція;

                вернути так;
              } інакше {
                звільнити_аргументи(розбирач, аргументи);
                вихід_позиції_помилки::вміст = поточна_позиція;

                вернути ні;
              }
            } інакше {
              звільнити_аргументи(розбирач, аргументи);
              вихід_позиції_помилки::вміст = поточна_позиція;

              вернути ні;
            }
          } інакше {
            звільнити_аргументи(розбирач, аргументи);
            вихід_позиції_помилки::вміст = поточна_позиція;

            вернути ні;
          }
        } інакше якщо спробувати_розібрати_аргумент_шаблону(розбирач, слова, поточна_позиція, очікує_закінчення_шаблону, аргумент::адреса, поточна_позиція::адреса, позиція_помилки_аргумента::адреса) {
          покласти_в_аргументи(розбирач, аргументи::адреса, аргумент);

          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
            поточна_позиція += 1;

            якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
              звільнити_аргументи(розбирач, аргументи);
              вихід_позиції_помилки::вміст = поточна_позиція;

              вернути ні;
            } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
              вихід::вміст = аргументи;
              вихід_позиції_кінця::вміст = поточна_позиція;

              вернути так;
            } інакше {
              поточна_позиція -= 1;
            }
          } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
            вихід::вміст = аргументи;
            вихід_позиції_кінця::вміст = поточна_позиція;

            вернути так;
          } інакше {
            звільнити_аргументи(розбирач, аргументи);
            вихід_позиції_помилки::вміст = поточна_позиція;

            вернути ні;
          }
        } інакше {
          звільнити_аргументи(розбирач, аргументи);
          вихід_позиції_помилки::вміст = позиція_помилки_аргумента;

          вернути ні;
        }

        поточна_позиція += 1;
      }

      звільнити_аргументи(розбирач, аргументи);
      вихід_позиції_помилки::вміст = поточна_позиція - 1;

      вернути ні;
    }

    дія спробувати_розібрати_дію(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_дія = ДаніСполукиДія {
        доступність = ДІЯ_ВНУТРІШНЯ,
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), Ідентифікатор { 0 } },
        параметри = Параметри { 0, пусто, 0},
        тип_результату = пусто,
        тіло = можливо<Сполуки> { позитивне(ні), Сполуки { 0, пусто, 0 } }
      };
      змінна параметри_шаблону = ПараметриШаблону { 0, пусто, 0};
      змінна як_шаблон = ні;

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == ВидСловаМісцева {
        дані_сполуки_дія.доступність = ДІЯ_МІСЦЕВА;
        поточна_позиція += 1;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗовнішня {
        дані_сполуки_дія.доступність = ДІЯ_ЗОВНІШНЯ;
        поточна_позиція += 1;
      }

      якщо слова.дані[поточна_позиція].вид != ВидСловаДія {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид == ВидСловаІдентифікатор {
        дані_сполуки_дія.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { поточна_позиція } };
        поточна_позиція += 1;
      }

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакМенше {
        поточна_позиція += 1;

        змінна позиція_помилки_параметрів_шаблону: позитивне = 0;
        якщо спробувати_розібрати_параметри_шаблону(розбирач, слова, поточна_позиція, ВидСловаЗнакКома, ВидСловаЗнакБільше, параметри_шаблону::адреса, поточна_позиція::адреса, позиція_помилки_параметрів_шаблону::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_параметрів_шаблону;
          стрибнути вихід_з_помилкою;
        }
        як_шаблон = так;
        поточна_позиція += 1;
      }

      якщо слова.дані[поточна_позиція].вид != ВидСловаЗнакВідкритаДужка {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      змінна позиція_помилки_параметрів: позитивне = 0;
      якщо спробувати_розібрати_параметри(розбирач, слова, поточна_позиція, ВидСловаЗнакКома, ВидСловаЗнакЗакритаДужка, дані_сполуки_дія.параметри::адреса, поточна_позиція::адреса, позиція_помилки_параметрів::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_параметрів;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакДвокрапка {
        поточна_позиція += 1;

        змінна позиція_помилки_типу: позитивне = 0;

        якщо спробувати_розібрати_тип(розбирач, слова, поточна_позиція, дані_сполуки_дія.тип_результату::адреса, поточна_позиція::адреса, позиція_помилки_типу::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_типу;
          стрибнути вихід_з_помилкою;
        }
        поточна_позиція += 1;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакМінус {
        поточна_позиція += 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакБільше {
          поточна_позиція += 1;

          змінна позиція_помилки_типу: позитивне = 0;

          якщо спробувати_розібрати_тип(розбирач, слова, поточна_позиція, дані_сполуки_дія.тип_результату::адреса, поточна_позиція::адреса, позиція_помилки_типу::адреса) == ні {
            вихід_позиції_помилки::вміст = позиція_помилки_типу;
            стрибнути вихід_з_помилкою;
          }
          поточна_позиція += 1;
        } інакше {
          вихід_позиції_помилки::вміст = поточна_позиція;
          стрибнути вихід_з_помилкою;
        }
      }

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
        стрибнути успішний_вихід;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаВідкритаФігурнаДужка {
        поточна_позиція += 1;
      } інакше {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }

      змінна позиція_помилки_тіла: позитивне = 0;
      якщо спробувати_розібрати_тіло(розбирач, слова, поточна_позиція, ВидСловаЗакритаФігурнаДужка, дані_сполуки_дія.тіло.значення::адреса, поточна_позиція::адреса, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути вихід_з_помилкою;
      }

      дані_сполуки_дія.тіло.заповнено = позитивне(так);

    успішний_вихід:
      змінна сполука_дії = виділити<Сполука>(розбирач);
      сполука_дії.вид = ВидСполукиДія;
      сполука_дії.дані = дані_сполуки_дія;
      сполука_дії.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      якщо як_шаблон {
        змінна сполука_шаблону = виділити<Сполука>(розбирач);
        сполука_шаблону.вид = ВидСполукиШаблон;
        сполука_шаблону.дані = ДаніСполукиШаблон {
          ідентифікатор = дані_сполуки_дія.ідентифікатор,
          параметри = параметри_шаблону,
          значення = сполука_дії
        };
        сполука_шаблону.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

        вихід::вміст = сполука_шаблону;
      } інакше {
        вихід::вміст = сполука_дії;
      }
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      звільнити_параметри_шаблону(розбирач, параметри_шаблону);
      звільнити_параметри(розбирач, дані_сполуки_дія.параметри);
      звільнити_сполуку(розбирач, дані_сполуки_дія.тип_результату);
      вернути ні;
    }

    дія спробувати_розібрати_значення(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, як_елемент_тіла: логічне, очікує_закінчення_шаблону: логічне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна поточна_позиція = позиція_початку;

      змінна сполука_операції: адреса<Сполука> = пусто;

      якщо як_елемент_тіла == ні {
        якщо слова.дані[поточна_позиція].вид == ВидСловаВідкритаФігурнаДужка {
          стрибнути обробник_фігурної_дужки;
        }
      }

      змінна позиція_помилки_операції: позитивне = 0;
      якщо спробувати_розібрати_операцію(розбирач, слова, поточна_позиція, очікує_закінчення_шаблону, сполука_операції::адреса, поточна_позиція::адреса, позиція_помилки_операції::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_операції;
        вернути ні;
      }

      поточна_позиція += 1;
      якщо слова.дані[поточна_позиція].вид == ВидСловаВідкритаФігурнаДужка {
   обробник_фігурної_дужки:
        поточна_позиція += 1;

        змінна аргументи_обʼєкта = Аргументи { 0, пусто, 0, позитивне(ні) };
        змінна позиція_помилки_аргументів_обʼєкта: позитивне = 0;
        якщо спробувати_розібрати_аргументи(розбирач, слова, поточна_позиція, так, ні, ВидСловаЗнакКома, ВидСловаЗакритаФігурнаДужка, аргументи_обʼєкта::адреса, поточна_позиція::адреса, позиція_помилки_аргументів_обʼєкта::адреса) {
          змінна сполука_обʼєкта = виділити<Сполука>(розбирач);
          сполука_обʼєкта.вид = ВидСполукиОбʼєкт;
          сполука_обʼєкта.дані = ДаніСполукиОбʼєкт {
            ліво = сполука_операції,
            аргументи = аргументи_обʼєкта
          };
          сполука_обʼєкта.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

          вихід_позиції_кінця::вміст = поточна_позиція;
          вихід::вміст = сполука_обʼєкта;
          вернути так;
        }

        вихід_позиції_помилки::вміст = позиція_помилки_аргументів_обʼєкта;
        вернути ні;
      } інакше {
        поточна_позиція -= 1;
        вихід_позиції_кінця::вміст = поточна_позиція;
        вихід::вміст = сполука_операції;
        вернути так;
      }
    }

    дія спробувати_розібрати_структуру(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_структура = ДаніСполукиСтруктура {
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), Ідентифікатор { 0 } },
        параметри = Параметри { 0, пусто, 0}
      };
      змінна параметри_шаблону = ПараметриШаблону { 0, пусто, 0};
      змінна як_шаблон = ні;

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаСтруктура {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид == ВидСловаІдентифікатор {
        дані_сполуки_структура.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { поточна_позиція } };
        поточна_позиція += 1;
      }

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакМенше {
        поточна_позиція += 1;

        змінна позиція_помилки_параметрів_шаблону: позитивне = 0;
        якщо спробувати_розібрати_параметри_шаблону(розбирач, слова, поточна_позиція, ВидСловаЗнакКома, ВидСловаЗнакБільше, параметри_шаблону::адреса, поточна_позиція::адреса, позиція_помилки_параметрів_шаблону::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_параметрів_шаблону;
          стрибнути вихід_з_помилкою;
        }
        як_шаблон = так;
        поточна_позиція += 1;
      }

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
        стрибнути успішний_вихід;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаВідкритаФігурнаДужка {
        поточна_позиція += 1;

        змінна позиція_помилки_параметрів: позитивне = 0;
        якщо спробувати_розібрати_параметри(розбирач, слова, поточна_позиція, ВидСловаЗнакКрапкакома, ВидСловаЗакритаФігурнаДужка, дані_сполуки_структура.параметри::адреса, поточна_позиція::адреса, позиція_помилки_параметрів::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_параметрів;
          стрибнути вихід_з_помилкою;
        }
      } інакше {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }

    успішний_вихід:
      змінна сполука_структури = виділити<Сполука>(розбирач);
      сполука_структури.вид = ВидСполукиСтруктура;
      сполука_структури.дані = дані_сполуки_структура;
      сполука_структури.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      якщо як_шаблон {
        змінна сполука_шаблону = виділити<Сполука>(розбирач);
        сполука_шаблону.вид = ВидСполукиШаблон;
        сполука_шаблону.дані = ДаніСполукиШаблон {
          ідентифікатор = дані_сполуки_структура.ідентифікатор,
          параметри = параметри_шаблону,
          значення = сполука_структури
        };
        сполука_шаблону.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

        вихід::вміст = сполука_шаблону;
      } інакше {
        вихід::вміст = сполука_структури;
      }
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      звільнити_параметри_шаблону(розбирач, параметри_шаблону);
      звільнити_параметри(розбирач, дані_сполуки_структура.параметри);
      вернути ні;
    }

    дія спробувати_розібрати_елемент_переліка(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<ЕлементПереліка>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна елемент_переліка = ЕлементПереліка {
        ідентифікатор = Ідентифікатор { 0 },
        параметри = Параметри { 0, пусто, 0 },
        значення = пусто
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаІдентифікатор {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      елемент_переліка.ідентифікатор = Ідентифікатор { поточна_позиція };
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид == ВидСловаВідкритаФігурнаДужка {
        поточна_позиція += 1;

        змінна позиція_помилки_параметрів: позитивне = 0;
        якщо спробувати_розібрати_параметри(розбирач, слова, поточна_позиція, ВидСловаЗнакКрапкакома, ВидСловаЗакритаФігурнаДужка, елемент_переліка.параметри::адреса, поточна_позиція::адреса, позиція_помилки_параметрів::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_параметрів;
          стрибнути вихід_з_помилкою;
        }
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакРівно {
        поточна_позиція += 1;

        змінна позиція_помилки_значення: позитивне = 0;
        якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, елемент_переліка.значення::адреса, поточна_позиція::адреса, позиція_помилки_значення::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_значення;
          стрибнути вихід_з_помилкою;
        }
      } інакше {
        поточна_позиція -= 1;
      }

    успішний_вихід:
      вихід::вміст = елемент_переліка;
      вихід_позиції_кінця::вміст = поточна_позиція;
      вернути так;

    вихід_з_помилкою:
      звільнити_параметри(розбирач, елемент_переліка.параметри);
      звільнити_сполуку(розбирач, елемент_переліка.значення);
      вернути ні;
    }

    дія спробувати_розібрати_елементи_переліка(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вид_слова_розділення: позитивне, вид_слова_закінчення: позитивне, вихід: адреса<ЕлементиПереліка>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна елементи_переліка = ЕлементиПереліка { 0, пусто, 0 };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
        вихід::вміст = елементи_переліка;
        вихід_позиції_кінця::вміст = поточна_позиція;

        вернути так;
      }

      поки поточна_позиція < слова.розмір {
        змінна елемент_переліка: ЕлементПереліка;
        змінна позиція_помилки_елемента_переліка: позитивне = 0;

        якщо спробувати_розібрати_елемент_переліка(розбирач, слова, поточна_позиція, елемент_переліка::адреса, поточна_позиція::адреса, позиція_помилки_елемента_переліка::адреса) {
          покласти_в_елементи_переліка(розбирач, елементи_переліка::адреса, елемент_переліка);

          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
            поточна_позиція += 1;

            якщо слова.дані[поточна_позиція].вид == вид_слова_розділення {
              звільнити_елементи_переліка(розбирач, елементи_переліка);
              вихід_позиції_помилки::вміст = поточна_позиція;

              вернути ні;
            } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
              вихід::вміст = елементи_переліка;
              вихід_позиції_кінця::вміст = поточна_позиція;

              вернути так;
            } інакше {
              поточна_позиція -= 1;
            }
          } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
            вихід::вміст = елементи_переліка;
            вихід_позиції_кінця::вміст = поточна_позиція;

            вернути так;
          } інакше {
            звільнити_елементи_переліка(розбирач, елементи_переліка);
            вихід_позиції_помилки::вміст = поточна_позиція;

            вернути ні;
          }
        } інакше {
          звільнити_елементи_переліка(розбирач, елементи_переліка);
          вихід_позиції_помилки::вміст = позиція_помилки_елемента_переліка;

          вернути ні;
        }

        поточна_позиція += 1;
      }

      звільнити_елементи_переліка(розбирач, елементи_переліка);
      вихід_позиції_помилки::вміст = поточна_позиція - 1;

      вернути ні;
    }

    дія спробувати_розібрати_перелік(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_перелік = ДаніСполукиПерелік {
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), Ідентифікатор { 0 } },
        елементи = ЕлементиПереліка { 0, пусто, 0}
      };
      змінна параметри_шаблону = ПараметриШаблону { 0, пусто, 0};
      змінна як_шаблон = ні;

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаПерелік {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид == ВидСловаІдентифікатор {
        дані_сполуки_перелік.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { поточна_позиція } };
        поточна_позиція += 1;
      }

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакМенше {
        поточна_позиція += 1;

        змінна позиція_помилки_параметрів_шаблону: позитивне = 0;
        якщо спробувати_розібрати_параметри_шаблону(розбирач, слова, поточна_позиція, ВидСловаЗнакКома, ВидСловаЗнакБільше, параметри_шаблону::адреса, поточна_позиція::адреса, позиція_помилки_параметрів_шаблону::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_параметрів_шаблону;
          стрибнути вихід_з_помилкою;
        }
        як_шаблон = так;
        поточна_позиція += 1;
      }

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
        стрибнути успішний_вихід;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаВідкритаФігурнаДужка {
        поточна_позиція += 1;

        змінна позиція_помилки_елементів_переліка: позитивне = 0;
        якщо спробувати_розібрати_елементи_переліка(розбирач, слова, поточна_позиція, ВидСловаЗнакКома, ВидСловаЗакритаФігурнаДужка, дані_сполуки_перелік.елементи::адреса, поточна_позиція::адреса, позиція_помилки_елементів_переліка::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_елементів_переліка;
          стрибнути вихід_з_помилкою;
        }
      } інакше {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }

    успішний_вихід:
      змінна сполука_переліка = виділити<Сполука>(розбирач);
      сполука_переліка.вид = ВидСполукиПерелік;
      сполука_переліка.дані = дані_сполуки_перелік;
      сполука_переліка.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      якщо як_шаблон {
        змінна сполука_шаблону = виділити<Сполука>(розбирач);
        сполука_шаблону.вид = ВидСполукиШаблон;
        сполука_шаблону.дані = ДаніСполукиШаблон {
          ідентифікатор = дані_сполуки_перелік.ідентифікатор,
          параметри = параметри_шаблону,
          значення = сполука_переліка
        };
        сполука_шаблону.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

        вихід::вміст = сполука_шаблону;
      } інакше {
        вихід::вміст = сполука_переліка;
      }
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      звільнити_параметри_шаблону(розбирач, параметри_шаблону);
      звільнити_елементи_переліка(розбирач, дані_сполуки_перелік.елементи);
      вернути ні;
    }

    дія спробувати_розібрати_ціль(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_ціль = ДаніСполукиЦіль {
        модифікатор = ЦільЗвичайна,
        ідентифікатор = Ідентифікатор { 0 },
        тип = пусто,
        значення = пусто
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == ВидСловаЦіль {
        дані_сполуки_ціль.модифікатор = ЦільЗвичайна;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗмінна {
        дані_сполуки_ціль.модифікатор = ЦільЗмінна;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаСтала {
        дані_сполуки_ціль.модифікатор = ЦільСтала;
      } інакше {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид != ВидСловаІдентифікатор {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      дані_сполуки_ціль.ідентифікатор = Ідентифікатор { поточна_позиція };
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакДвокрапка {
        поточна_позиція += 1;

        змінна позиція_помилки_типу: позитивне = 0;

        якщо спробувати_розібрати_тип(розбирач, слова, поточна_позиція, дані_сполуки_ціль.тип::адреса, поточна_позиція::адреса, позиція_помилки_типу::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_типу;
          стрибнути вихід_з_помилкою;
        }
        поточна_позиція += 1;
      }

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакРівно {
        поточна_позиція += 1;

        змінна позиція_помилки_значення: позитивне = 0;
        якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, дані_сполуки_ціль.значення::адреса, поточна_позиція::адреса, позиція_помилки_значення::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_значення;
          стрибнути вихід_з_помилкою;
        }
      } інакше {
        поточна_позиція -= 1;
      }

    успішний_вихід:
      змінна сполука_цілі = виділити<Сполука>(розбирач);
      сполука_цілі.вид = ВидСполукиЦіль;
      сполука_цілі.дані = дані_сполуки_ціль;
      сполука_цілі.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      вихід::вміст = сполука_цілі;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      звільнити_сполуку(розбирач, дані_сполуки_ціль.тип);
      звільнити_сполуку(розбирач, дані_сполуки_ціль.значення);
      вернути ні;
    }

    дія спробувати_розібрати_синонім(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_синонім = ДаніСполукиСинонім {
        ідентифікатор = Ідентифікатор { 0 },
        значення = пусто
      };
      змінна параметри_шаблону = ПараметриШаблону { 0, пусто, 0};
      змінна як_шаблон = ні;

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаСинонім {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид != ВидСловаІдентифікатор {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      дані_сполуки_синонім.ідентифікатор = Ідентифікатор { поточна_позиція };
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакМенше {
        поточна_позиція += 1;

        змінна позиція_помилки_параметрів_шаблону: позитивне = 0;
        якщо спробувати_розібрати_параметри_шаблону(розбирач, слова, поточна_позиція, ВидСловаЗнакКома, ВидСловаЗнакБільше, параметри_шаблону::адреса, поточна_позиція::адреса, позиція_помилки_параметрів_шаблону::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_параметрів_шаблону;
          стрибнути вихід_з_помилкою;
        }
        як_шаблон = так;
        поточна_позиція += 1;
      }

      якщо слова.дані[поточна_позиція].вид != ВидСловаЗнакРівно {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      змінна позиція_помилки_значення: позитивне = 0;
      якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, дані_сполуки_синонім.значення::адреса, поточна_позиція::адреса, позиція_помилки_значення::адреса) == ні {
        якщо спробувати_розібрати_тип(розбирач, слова, поточна_позиція, дані_сполуки_синонім.значення::адреса, поточна_позиція::адреса, позиція_помилки_значення::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_значення;
          стрибнути вихід_з_помилкою;
        }
      }

    успішний_вихід:
      якщо як_шаблон {
        змінна сполука_шаблону = виділити<Сполука>(розбирач);
        сполука_шаблону.вид = ВидСполукиШаблон;
        сполука_шаблону.дані = ДаніСполукиШаблон {
          ідентифікатор = можливо<Ідентифікатор> { позитивне(так), дані_сполуки_синонім.ідентифікатор },
          параметри = параметри_шаблону,
          значення = дані_сполуки_синонім.значення
        };
        сполука_шаблону.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

        вихід::вміст = сполука_шаблону;
      } інакше {
        змінна сполука_синоніма = виділити<Сполука>(розбирач);
        сполука_синоніма.вид = ВидСполукиСинонім;
        сполука_синоніма.дані = дані_сполуки_синонім;
        сполука_синоніма.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

        вихід::вміст = сполука_синоніма;
      }
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      звільнити_сполуку(розбирач, дані_сполуки_синонім.значення);
      вернути ні;
    }

    дія спробувати_розібрати_вернути(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_вернути = ДаніСполукиВернути {
        значення = пусто
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаВернути {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      // потім: може краще перевіряти наявність ;
      змінна позиція_помилки_значення: позитивне = 0;
      якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, дані_сполуки_вернути.значення::адреса, поточна_позиція::адреса, позиція_помилки_значення::адреса) {
        стрибнути успішний_вихід;
      } інакше {
        поточна_позиція -= 1;
      }

    успішний_вихід:
      змінна сполука_вернути = виділити<Сполука>(розбирач);
      сполука_вернути.вид = ВидСполукиВернути;
      сполука_вернути.дані = дані_сполуки_вернути;
      сполука_вернути.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      вихід::вміст = сполука_вернути;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      звільнити_сполуку(розбирач, дані_сполуки_вернути.значення);
      вернути ні;
    }

    дія спробувати_розібрати_якщо(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_якщо = ДаніСполукиЯкщо {
        умова = пусто,
        тіло = Сполуки { 0, пусто, 0 },
        тіло_інакше = Сполуки { 0, пусто, 0 },
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаЯкщо {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      змінна позиція_помилки_умови: позитивне = 0;

      якщо спробувати_розібрати_операцію(розбирач, слова, поточна_позиція, ні, дані_сполуки_якщо.умова::адреса, поточна_позиція::адреса, позиція_помилки_умови::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_умови;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид != ВидСловаВідкритаФігурнаДужка {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      змінна позиція_помилки_тіла: позитивне = 0;
      якщо спробувати_розібрати_тіло(розбирач, слова, поточна_позиція, ВидСловаЗакритаФігурнаДужка, дані_сполуки_якщо.тіло::адреса, поточна_позиція::адреса, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид == ВидСловаІнакше {
        поточна_позиція += 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЯкщо {
          змінна сполука_якщо: адреса<Сполука>;
          змінна позиція_помилки_якщо: позитивне;

          якщо спробувати_розібрати_якщо(розбирач, слова, поточна_позиція, сполука_якщо::адреса, поточна_позиція::адреса, позиція_помилки_якщо::адреса) {
            покласти_в_сполуки(розбирач, дані_сполуки_якщо.тіло_інакше::адреса, сполука_якщо);
          } інакше {
            вихід_позиції_помилки::вміст = позиція_помилки_якщо;
            стрибнути вихід_з_помилкою;
          }
        } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаВідкритаФігурнаДужка {
          поточна_позиція += 1;

          змінна позиція_помилки_тіла_інакше: позитивне = 0;
          якщо спробувати_розібрати_тіло(розбирач, слова, поточна_позиція, ВидСловаЗакритаФігурнаДужка, дані_сполуки_якщо.тіло_інакше::адреса, поточна_позиція::адреса, позиція_помилки_тіла_інакше::адреса) == ні {
            вихід_позиції_помилки::вміст = позиція_помилки_тіла_інакше;
            стрибнути вихід_з_помилкою;
          }
        } інакше {
          вихід_позиції_помилки::вміст = поточна_позиція;
          стрибнути вихід_з_помилкою;
        }
      } інакше {
        поточна_позиція -= 1;
      }

    успішний_вихід:
      змінна сполука_якщо = виділити<Сполука>(розбирач);
      сполука_якщо.вид = ВидСполукиЯкщо;
      сполука_якщо.дані = дані_сполуки_якщо;
      сполука_якщо.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      вихід::вміст = сполука_якщо;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      звільнити_сполуку(розбирач, дані_сполуки_якщо.умова);
      звільнити_сполуки(розбирач, дані_сполуки_якщо.тіло);
      звільнити_сполуки(розбирач, дані_сполуки_якщо.тіло_інакше);
      вернути ні;
    }

    дія спробувати_розібрати_поки(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_поки = ДаніСполукиПоки {
        умова = пусто,
        тіло = Сполуки { 0, пусто, 0}
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаПоки {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      змінна позиція_помилки_умови: позитивне = 0;

      якщо спробувати_розібрати_операцію(розбирач, слова, поточна_позиція, ні, дані_сполуки_поки.умова::адреса, поточна_позиція::адреса, позиція_помилки_умови::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_умови;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид != ВидСловаВідкритаФігурнаДужка {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      змінна позиція_помилки_тіла: позитивне = 0;
      якщо спробувати_розібрати_тіло(розбирач, слова, поточна_позиція, ВидСловаЗакритаФігурнаДужка, дані_сполуки_поки.тіло::адреса, поточна_позиція::адреса, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути вихід_з_помилкою;
      }

    успішний_вихід:
      змінна сполука_поки = виділити<Сполука>(розбирач);
      сполука_поки.вид = ВидСполукиПоки;
      сполука_поки.дані = дані_сполуки_поки;
      сполука_поки.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      вихід::вміст = сполука_поки;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      звільнити_сполуку(розбирач, дані_сполуки_поки.умова);
      звільнити_сполуки(розбирач, дані_сполуки_поки.тіло);
      вернути ні;
    }

    дія спробувати_розібрати_секцію(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_секція = ДаніСполукиСекція {
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), Ідентифікатор { 0 } },
        тіло = Сполуки { 0, пусто, 0}
      };
      змінна параметри_шаблону = ПараметриШаблону { 0, пусто, 0};
      змінна як_шаблон = ні;

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаСекція {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид == ВидСловаІдентифікатор {
        дані_сполуки_секція.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { поточна_позиція } };
        поточна_позиція += 1;
      }

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакМенше {
        поточна_позиція += 1;

        змінна позиція_помилки_параметрів_шаблону: позитивне = 0;
        якщо спробувати_розібрати_параметри_шаблону(розбирач, слова, поточна_позиція, ВидСловаЗнакКома, ВидСловаЗнакБільше, параметри_шаблону::адреса, поточна_позиція::адреса, позиція_помилки_параметрів_шаблону::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_параметрів_шаблону;
          стрибнути вихід_з_помилкою;
        }
        як_шаблон = так;
        поточна_позиція += 1;
      }

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
        стрибнути успішний_вихід;
      } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаВідкритаФігурнаДужка {
        поточна_позиція += 1;
      } інакше {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }

      змінна позиція_помилки_тіла: позитивне = 0;
      якщо спробувати_розібрати_тіло(розбирач, слова, поточна_позиція, ВидСловаЗакритаФігурнаДужка, дані_сполуки_секція.тіло::адреса, поточна_позиція::адреса, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути вихід_з_помилкою;
      }

    успішний_вихід:
      змінна сполука_секції = виділити<Сполука>(розбирач);
      сполука_секції.вид = ВидСполукиСекція;
      сполука_секції.дані = дані_сполуки_секція;
      сполука_секції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      якщо як_шаблон {
        змінна сполука_шаблону = виділити<Сполука>(розбирач);
        сполука_шаблону.вид = ВидСполукиШаблон;
        сполука_шаблону.дані = ДаніСполукиШаблон {
          ідентифікатор = дані_сполуки_секція.ідентифікатор,
          параметри = параметри_шаблону,
          значення = сполука_секції
        };
        сполука_шаблону.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

        вихід::вміст = сполука_шаблону;
      } інакше {
        вихід::вміст = сполука_секції;
      }
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      звільнити_параметри_шаблону(розбирач, параметри_шаблону);
      звільнити_сполуки(розбирач, дані_сполуки_секція.тіло);
      вернути ні;
    }

    дія спробувати_розібрати_крок(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_крок = ДаніСполукиКрок {
        ідентифікатор = Ідентифікатор { 0 }
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаІдентифікатор {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      дані_сполуки_крок.ідентифікатор = Ідентифікатор { поточна_позиція };
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид != ВидСловаЗнакДвокрапка {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }

    успішний_вихід:
      змінна сполука_кроку = виділити<Сполука>(розбирач);
      сполука_кроку.вид = ВидСполукиКрок;
      сполука_кроку.дані = дані_сполуки_крок;
      сполука_кроку.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      вихід::вміст = сполука_кроку;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      вернути ні;
    }

    дія спробувати_розібрати_стрибнути(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_стрибнути = ДаніСполукиСтрибнути {
        ідентифікатор = Ідентифікатор { 0 }
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаСтрибнути {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид != ВидСловаІдентифікатор {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      дані_сполуки_стрибнути.ідентифікатор = Ідентифікатор { поточна_позиція };

    успішний_вихід:
      змінна сполука_стрибнути = виділити<Сполука>(розбирач);
      сполука_стрибнути.вид = ВидСполукиСтрибнути;
      сполука_стрибнути.дані = дані_сполуки_стрибнути;
      сполука_стрибнути.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      вихід::вміст = сполука_стрибнути;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      вернути ні;
    }

    дія спробувати_розібрати_взяти(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_взяти = ДаніСполукиВзяти {
        відносно = позитивне(ні),
        звідки = Ідентифікатор { 0 },
        шлях = ЕлементиВзяти { 0, пусто, 0 }
      };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид != ВидСловаВзяти {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид != ВидСловаІдентифікатор {
        вихід_позиції_помилки::вміст = поточна_позиція;
        стрибнути вихід_з_помилкою;
      }
      дані_сполуки_взяти.звідки = Ідентифікатор { поточна_позиція };
      поточна_позиція += 1;

      якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапка {
        поточна_позиція += 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакПоділити {
          дані_сполуки_взяти.відносно = позитивне(так);

          поточна_позиція += 1;
        } інакше {
          вихід_позиції_помилки::вміст = поточна_позиція;
          стрибнути вихід_з_помилкою;
        }
      }

      поки поточна_позиція < слова.розмір {
        якщо слова.дані[поточна_позиція].вид == ВидСловаІдентифікатор {
          покласти_в_елементи_взяти(розбирач, дані_сполуки_взяти.шлях::адреса, ЕлементВзяти { поточна_позиція });

          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакПоділити {
            поточна_позиція += 1;
          } інакше {
            поточна_позиція -= 1;
            стрибнути успішний_вихід;
          }
        } інакше {
          якщо дані_сполуки_взяти.шлях.розмір == 0 {
            вихід_позиції_помилки::вміст = поточна_позиція;
            стрибнути вихід_з_помилкою;
          }
          поточна_позиція -= 1;
          стрибнути успішний_вихід;
        }
      }

      вихід_позиції_помилки::вміст = поточна_позиція - 1;
      стрибнути вихід_з_помилкою;

    успішний_вихід:
      змінна сполука_взяти = виділити<Сполука>(розбирач);
      сполука_взяти.вид = ВидСполукиВзяти;
      сполука_взяти.дані = дані_сполуки_взяти;
      сполука_взяти.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };

      вихід::вміст = сполука_взяти;
      вихід_позиції_кінця::вміст = поточна_позиція;

      вернути так;

    вихід_з_помилкою:
      звільнити_елементи_взяти(розбирач, дані_сполуки_взяти.шлях);
      вернути ні;
    }

    дія спробувати_розібрати_елемент_тіла(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна позиція_помилки: позитивне = 0;
      змінна найдовша_позиція_помилки: позитивне = 0;

      якщо спробувати_розібрати_дію(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_структуру(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_перелік(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_поки(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_якщо(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_секцію(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_ціль(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        змінна поточна_позиція = вихід_позиції_кінця::вміст + 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
          вихід_позиції_кінця::вміст = поточна_позиція;
          вернути так;
        }

        позиція_помилки = поточна_позиція;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_синонім(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        змінна поточна_позиція = вихід_позиції_кінця::вміст + 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
          вихід_позиції_кінця::вміст = поточна_позиція;
          вернути так;
        }

        позиція_помилки = поточна_позиція;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_вернути(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        змінна поточна_позиція = вихід_позиції_кінця::вміст + 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
          вихід_позиції_кінця::вміст = поточна_позиція;
          вернути так;
        }

        позиція_помилки = поточна_позиція;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_стрибнути(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        змінна поточна_позиція = вихід_позиції_кінця::вміст + 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
          вихід_позиції_кінця::вміст = поточна_позиція;
          вернути так;
        }

        позиція_помилки = поточна_позиція;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_взяти(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        змінна поточна_позиція = вихід_позиції_кінця::вміст + 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
          вихід_позиції_кінця::вміст = поточна_позиція;
          вернути так;
        }

        позиція_помилки = поточна_позиція;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      змінна поточна_позиція = позиція_початку;
      змінна сполука_ліво: адреса<Сполука> = пусто;
      якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, так, ні, сполука_ліво::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
        поточна_позиція += 1;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
          вихід::вміст = сполука_ліво;
          вихід_позиції_кінця::вміст = поточна_позиція;
          вернути так;
        } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакРівно { // =
          якщо сполука_ліво.вид == ВидСполукиПрочитати { // а = 10
            поточна_позиція += 1;
            змінна сполука_значення: адреса<Сполука> = пусто;
            якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
              поточна_позиція += 1;
              якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                змінна дані_сполуки_прочитати = сполука_ліво.дані як ДаніСполукиПрочитати;
                змінна сполука_записати = виділити<Сполука>(розбирач);
                сполука_записати.вид = ВидСполукиЗаписати;
                сполука_записати.дані = ДаніСполукиЗаписати {
                  ідентифікатор = дані_сполуки_прочитати.ідентифікатор,
                  значення = сполука_значення
                };
                сполука_записати.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                звільнити(розбирач, сполука_ліво);
                вихід::вміст = сполука_записати;
                вихід_позиції_кінця::вміст = поточна_позиція;
                вернути так;
              }
            }
          } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиВластивість { // а.б = 10
            поточна_позиція += 1;
            змінна сполука_значення: адреса<Сполука> = пусто;
            якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
              поточна_позиція += 1;
              якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                змінна дані_сполуки_отримати_властивість = сполука_ліво.дані як ДаніСполукиОтриматиВластивість;
                змінна сполука_змінити_властивість = виділити<Сполука>(розбирач);
                сполука_змінити_властивість.вид = ВидСполукиЗмінитиВластивість;
                сполука_змінити_властивість.дані = ДаніСполукиЗмінитиВластивість {
                  ліво = дані_сполуки_отримати_властивість.ліво,
                  ідентифікатор = дані_сполуки_отримати_властивість.ідентифікатор,
                  значення = сполука_значення
                };
                сполука_змінити_властивість.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                звільнити(розбирач, сполука_ліво);
                вихід::вміст = сполука_змінити_властивість;
                вихід_позиції_кінця::вміст = поточна_позиція;
                вернути так;
              }
            }
          } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиСекційнуВластивість { // а::б = 10
            поточна_позиція += 1;
            змінна сполука_значення: адреса<Сполука> = пусто;
            якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
              поточна_позиція += 1;
              якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                змінна дані_сполуки_отримати_секційну_властивість = сполука_ліво.дані як ДаніСполукиОтриматиСекційнуВластивість;
                змінна сполука_змінити_секційну_властивість = виділити<Сполука>(розбирач);
                сполука_змінити_секційну_властивість.вид = ВидСполукиЗмінитиСекційнуВластивість;
                сполука_змінити_секційну_властивість.дані = ДаніСполукиЗмінитиСекційнуВластивість {
                  ліво = дані_сполуки_отримати_секційну_властивість.ліво,
                  ідентифікатор = дані_сполуки_отримати_секційну_властивість.ідентифікатор,
                  значення = сполука_значення
                };
                сполука_змінити_секційну_властивість.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                звільнити(розбирач, сполука_ліво);
                вихід::вміст = сполука_змінити_секційну_властивість;
                вихід_позиції_кінця::вміст = поточна_позиція;
                вернути так;
              }
            }
          } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиЕлемент { // а[б] = 10
            поточна_позиція += 1;
            змінна сполука_значення: адреса<Сполука> = пусто;
            якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
              поточна_позиція += 1;
              якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                змінна дані_сполуки_отримати_елемент = сполука_ліво.дані як ДаніСполукиОтриматиЕлемент;
                змінна сполука_змінити_елемент = виділити<Сполука>(розбирач);
                сполука_змінити_елемент.вид = ВидСполукиЗмінитиЕлемент;
                сполука_змінити_елемент.дані = ДаніСполукиЗмінитиЕлемент {
                  ліво = дані_сполуки_отримати_елемент.ліво,
                  ключ = дані_сполуки_отримати_елемент.ключ,
                  значення = сполука_значення
                };
                сполука_змінити_елемент.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                звільнити(розбирач, сполука_ліво);
                вихід::вміст = сполука_змінити_елемент;
                вихід_позиції_кінця::вміст = поточна_позиція;
                вернути так;
              }
            }
          }
        } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакПлюс {
          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакРівно {
            якщо сполука_ліво.вид == ВидСполукиПрочитати { // а += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_прочитати = сполука_ліво.дані як ДаніСполукиПрочитати;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїДодавання,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_записати = виділити<Сполука>(розбирач);
                  сполука_записати.вид = ВидСполукиЗаписати;
                  сполука_записати.дані = ДаніСполукиЗаписати {
                    ідентифікатор = дані_сполуки_прочитати.ідентифікатор,
                    значення = сполука_операції
                  };
                  сполука_записати.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_записати;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиВластивість { // а.б += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_отримати_властивість = сполука_ліво.дані як ДаніСполукиОтриматиВластивість;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїДодавання,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_змінити_властивість = виділити<Сполука>(розбирач);
                  сполука_змінити_властивість.вид = ВидСполукиЗмінитиВластивість;
                  сполука_змінити_властивість.дані = ДаніСполукиЗмінитиВластивість {
                    ліво = клонувати_сполуку(розбирач, дані_сполуки_отримати_властивість.ліво),
                    ідентифікатор = дані_сполуки_отримати_властивість.ідентифікатор,
                    значення = сполука_операції
                  };
                  сполука_змінити_властивість.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_змінити_властивість;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиСекційнуВластивість { // а::б += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_отримати_секційну_властивість = сполука_ліво.дані як ДаніСполукиОтриматиСекційнуВластивість;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїДодавання,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_змінити_секційну_властивість = виділити<Сполука>(розбирач);
                  сполука_змінити_секційну_властивість.вид = ВидСполукиЗмінитиСекційнуВластивість;
                  сполука_змінити_секційну_властивість.дані = ДаніСполукиЗмінитиСекційнуВластивість {
                    ліво = клонувати_сполуку(розбирач, дані_сполуки_отримати_секційну_властивість.ліво),
                    ідентифікатор = дані_сполуки_отримати_секційну_властивість.ідентифікатор,
                    значення = сполука_операції
                  };
                  сполука_змінити_секційну_властивість.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_змінити_секційну_властивість;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиЕлемент { // а[б] += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_отримати_елемент = сполука_ліво.дані як ДаніСполукиОтриматиЕлемент;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїДодавання,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_змінити_елемент = виділити<Сполука>(розбирач);
                  сполука_змінити_елемент.вид = ВидСполукиЗмінитиЕлемент;
                  сполука_змінити_елемент.дані = ДаніСполукиЗмінитиЕлемент {
                    ліво = клонувати_сполуку(розбирач, дані_сполуки_отримати_елемент.ліво),
                    ключ = клонувати_сполуку(розбирач, дані_сполуки_отримати_елемент.ключ),
                    значення = сполука_операції
                  };
                  сполука_змінити_елемент.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_змінити_елемент;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            }
          }
        } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакМінус {
          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакРівно {
            якщо сполука_ліво.вид == ВидСполукиПрочитати { // а += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_прочитати = сполука_ліво.дані як ДаніСполукиПрочитати;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїВіднімання,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_записати = виділити<Сполука>(розбирач);
                  сполука_записати.вид = ВидСполукиЗаписати;
                  сполука_записати.дані = ДаніСполукиЗаписати {
                    ідентифікатор = дані_сполуки_прочитати.ідентифікатор,
                    значення = сполука_операції
                  };
                  сполука_записати.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_записати;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиВластивість { // а.б += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_отримати_властивість = сполука_ліво.дані як ДаніСполукиОтриматиВластивість;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїВіднімання,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_змінити_властивість = виділити<Сполука>(розбирач);
                  сполука_змінити_властивість.вид = ВидСполукиЗмінитиВластивість;
                  сполука_змінити_властивість.дані = ДаніСполукиЗмінитиВластивість {
                    ліво = клонувати_сполуку(розбирач, дані_сполуки_отримати_властивість.ліво),
                    ідентифікатор = дані_сполуки_отримати_властивість.ідентифікатор,
                    значення = сполука_операції
                  };
                  сполука_змінити_властивість.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_змінити_властивість;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиСекційнуВластивість { // а::б += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_отримати_секційну_властивість = сполука_ліво.дані як ДаніСполукиОтриматиСекційнуВластивість;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїВіднімання,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_змінити_секційну_властивість = виділити<Сполука>(розбирач);
                  сполука_змінити_секційну_властивість.вид = ВидСполукиЗмінитиСекційнуВластивість;
                  сполука_змінити_секційну_властивість.дані = ДаніСполукиЗмінитиСекційнуВластивість {
                    ліво = клонувати_сполуку(розбирач, дані_сполуки_отримати_секційну_властивість.ліво),
                    ідентифікатор = дані_сполуки_отримати_секційну_властивість.ідентифікатор,
                    значення = сполука_операції
                  };
                  сполука_змінити_секційну_властивість.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_змінити_секційну_властивість;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиЕлемент { // а[б] += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_отримати_елемент = сполука_ліво.дані як ДаніСполукиОтриматиЕлемент;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїВіднімання,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_змінити_елемент = виділити<Сполука>(розбирач);
                  сполука_змінити_елемент.вид = ВидСполукиЗмінитиЕлемент;
                  сполука_змінити_елемент.дані = ДаніСполукиЗмінитиЕлемент {
                    ліво = клонувати_сполуку(розбирач, дані_сполуки_отримати_елемент.ліво),
                    ключ = клонувати_сполуку(розбирач, дані_сполуки_отримати_елемент.ключ),
                    значення = сполука_операції
                  };
                  сполука_змінити_елемент.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_змінити_елемент;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            }
          }
        } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакПомножити {
          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакРівно {
            якщо сполука_ліво.вид == ВидСполукиПрочитати { // а += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_прочитати = сполука_ліво.дані як ДаніСполукиПрочитати;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїМноження,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_записати = виділити<Сполука>(розбирач);
                  сполука_записати.вид = ВидСполукиЗаписати;
                  сполука_записати.дані = ДаніСполукиЗаписати {
                    ідентифікатор = дані_сполуки_прочитати.ідентифікатор,
                    значення = сполука_операції
                  };
                  сполука_записати.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_записати;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиВластивість { // а.б += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_отримати_властивість = сполука_ліво.дані як ДаніСполукиОтриматиВластивість;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїМноження,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_змінити_властивість = виділити<Сполука>(розбирач);
                  сполука_змінити_властивість.вид = ВидСполукиЗмінитиВластивість;
                  сполука_змінити_властивість.дані = ДаніСполукиЗмінитиВластивість {
                    ліво = клонувати_сполуку(розбирач, дані_сполуки_отримати_властивість.ліво),
                    ідентифікатор = дані_сполуки_отримати_властивість.ідентифікатор,
                    значення = сполука_операції
                  };
                  сполука_змінити_властивість.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_змінити_властивість;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиСекційнуВластивість { // а::б += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_отримати_секційну_властивість = сполука_ліво.дані як ДаніСполукиОтриматиСекційнуВластивість;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїМноження,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_змінити_секційну_властивість = виділити<Сполука>(розбирач);
                  сполука_змінити_секційну_властивість.вид = ВидСполукиЗмінитиСекційнуВластивість;
                  сполука_змінити_секційну_властивість.дані = ДаніСполукиЗмінитиСекційнуВластивість {
                    ліво = клонувати_сполуку(розбирач, дані_сполуки_отримати_секційну_властивість.ліво),
                    ідентифікатор = дані_сполуки_отримати_секційну_властивість.ідентифікатор,
                    значення = сполука_операції
                  };
                  сполука_змінити_секційну_властивість.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_змінити_секційну_властивість;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиЕлемент { // а[б] += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_отримати_елемент = сполука_ліво.дані як ДаніСполукиОтриматиЕлемент;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїМноження,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_змінити_елемент = виділити<Сполука>(розбирач);
                  сполука_змінити_елемент.вид = ВидСполукиЗмінитиЕлемент;
                  сполука_змінити_елемент.дані = ДаніСполукиЗмінитиЕлемент {
                    ліво = клонувати_сполуку(розбирач, дані_сполуки_отримати_елемент.ліво),
                    ключ = клонувати_сполуку(розбирач, дані_сполуки_отримати_елемент.ключ),
                    значення = сполука_операції
                  };
                  сполука_змінити_елемент.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_змінити_елемент;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            }
          }
        } інакше якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакПоділити {
          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакРівно {
            якщо сполука_ліво.вид == ВидСполукиПрочитати { // а += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_прочитати = сполука_ліво.дані як ДаніСполукиПрочитати;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїДілення,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_записати = виділити<Сполука>(розбирач);
                  сполука_записати.вид = ВидСполукиЗаписати;
                  сполука_записати.дані = ДаніСполукиЗаписати {
                    ідентифікатор = дані_сполуки_прочитати.ідентифікатор,
                    значення = сполука_операції
                  };
                  сполука_записати.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_записати;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиВластивість { // а.б += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_отримати_властивість = сполука_ліво.дані як ДаніСполукиОтриматиВластивість;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїДілення,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_змінити_властивість = виділити<Сполука>(розбирач);
                  сполука_змінити_властивість.вид = ВидСполукиЗмінитиВластивість;
                  сполука_змінити_властивість.дані = ДаніСполукиЗмінитиВластивість {
                    ліво = клонувати_сполуку(розбирач, дані_сполуки_отримати_властивість.ліво),
                    ідентифікатор = дані_сполуки_отримати_властивість.ідентифікатор,
                    значення = сполука_операції
                  };
                  сполука_змінити_властивість.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_змінити_властивість;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиСекційнуВластивість { // а::б += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_отримати_секційну_властивість = сполука_ліво.дані як ДаніСполукиОтриматиСекційнуВластивість;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїДілення,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_змінити_секційну_властивість = виділити<Сполука>(розбирач);
                  сполука_змінити_секційну_властивість.вид = ВидСполукиЗмінитиСекційнуВластивість;
                  сполука_змінити_секційну_властивість.дані = ДаніСполукиЗмінитиСекційнуВластивість {
                    ліво = клонувати_сполуку(розбирач, дані_сполуки_отримати_секційну_властивість.ліво),
                    ідентифікатор = дані_сполуки_отримати_секційну_властивість.ідентифікатор,
                    значення = сполука_операції
                  };
                  сполука_змінити_секційну_властивість.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_змінити_секційну_властивість;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            } інакше якщо сполука_ліво.вид == ВидСполукиОтриматиЕлемент { // а[б] += 10
              поточна_позиція += 1;
              змінна сполука_значення: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_значення(розбирач, слова, поточна_позиція, ні, ні, сполука_значення::адреса, поточна_позиція::адреса, позиція_помилки::адреса) {
                поточна_позиція += 1;
                якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
                  змінна дані_сполуки_отримати_елемент = сполука_ліво.дані як ДаніСполукиОтриматиЕлемент;
                  змінна сполука_операції = виділити<Сполука>(розбирач);
                  сполука_операції.вид = ВидСполукиОперація;
                  сполука_операції.дані = ДаніСполукиОперація {
                    вид = ВидОпераціїДілення,
                    ліво = сполука_ліво,
                    право = сполука_значення
                  };
                  сполука_операції.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  змінна сполука_змінити_елемент = виділити<Сполука>(розбирач);
                  сполука_змінити_елемент.вид = ВидСполукиЗмінитиЕлемент;
                  сполука_змінити_елемент.дані = ДаніСполукиЗмінитиЕлемент {
                    ліво = клонувати_сполуку(розбирач, дані_сполуки_отримати_елемент.ліво),
                    ключ = клонувати_сполуку(розбирач, дані_сполуки_отримати_елемент.ключ),
                    значення = сполука_операції
                  };
                  сполука_змінити_елемент.місцезнаходження = Місцезнаходження { позиція_початку, поточна_позиція };
                  вихід::вміст = сполука_змінити_елемент;
                  вихід_позиції_кінця::вміст = поточна_позиція;
                  вернути так;
                }
              }
            }
          }
        }

        позиція_помилки = поточна_позиція;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_крок(розбирач, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      вихід_позиції_помилки::вміст = найдовша_позиція_помилки;
      вернути ні;
    }

    дія спробувати_розібрати_тіло(розбирач: адреса<Розбирач>, слова: Слова, позиція_початку: позитивне, вид_слова_закінчення: позитивне, вихід: адреса<Сполуки>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна сполуки = Сполуки { 0, пусто, 0 };

      змінна поточна_позиція = позиція_початку;

      якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
        вихід::вміст = сполуки;
        вихід_позиції_кінця::вміст = поточна_позиція;

        вернути так;
      }

      поки поточна_позиція < слова.розмір {
        змінна сполука_елемента_тіла: адреса<Сполука> = пусто;
        змінна позиція_помилки_елемента_тіла: позитивне = 0;

        якщо слова.дані[поточна_позиція].вид == ВидСловаЗнакКрапкакома {
          // пропуск
        } інакше якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
          вихід::вміст = сполуки;
          вихід_позиції_кінця::вміст = поточна_позиція;

          вернути так;
        } інакше якщо спробувати_розібрати_елемент_тіла(розбирач, слова, поточна_позиція, сполука_елемента_тіла::адреса, поточна_позиція::адреса, позиція_помилки_елемента_тіла::адреса) {
          покласти_в_сполуки(розбирач, сполуки::адреса, сполука_елемента_тіла);

          поточна_позиція += 1;

          якщо слова.дані[поточна_позиція].вид == вид_слова_закінчення {
            вихід::вміст = сполуки;
            вихід_позиції_кінця::вміст = поточна_позиція;

            вернути так;
          } інакше {
            поточна_позиція -= 1;
          }
        } інакше {
          звільнити_сполуки(розбирач, сполуки);
          вихід_позиції_помилки::вміст = позиція_помилки_елемента_тіла;

          вернути ні;
        }

        поточна_позиція += 1;
      }

      звільнити_сполуки(розбирач, сполуки);
      вихід_позиції_помилки::вміст = поточна_позиція - 1;

      вернути ні;
    }

    зовнішня дія розібрати_слова_на_сполуки(розбирач: адреса<Розбирач>, слова: Слова, вихід: адреса<Сполуки>, вихід_помилки: адреса<ПомилкаРозборуНаСполуки>): логічне {
      змінна сполуки = Сполуки { 0, пусто, 0 };

      змінна позиція_кінця: позитивне = 0;
      змінна позиція_помилки: позитивне = 0;

      якщо спробувати_розібрати_тіло(розбирач, слова, 0, КІНЕЦЬ_СЛІВ, сполуки::адреса, позиція_кінця::адреса, позиція_помилки::адреса) {
        вихід::вміст = сполуки;

        вернути так;
      }

      вихід_помилки::вміст = ПомилкаРозборуНаСполуки { позиція_помилки };
      вернути ні;
    }

    дія вивести_символ_операції(вид: позитивне) {
      якщо вид == ВидОпераціїМноження {
        біб::вивести("*");
      } інакше якщо вид == ВидОпераціїДілення {
        біб::вивести("/");
      } інакше якщо вид == ВидОпераціїМодуль {
        біб::вивести("%");
      } інакше якщо вид == ВидОпераціїДодавання {
        біб::вивести("+");
      } інакше якщо вид == ВидОпераціїВіднімання {
        біб::вивести("-");
      } інакше якщо вид == ВидОпераціїЗсувВліво {
        біб::вивести("<<");
      } інакше якщо вид == ВидОпераціїЗсувВправо {
        біб::вивести(">>");
      } інакше якщо вид == ВидОпераціїМенше {
        біб::вивести("<");
      } інакше якщо вид == ВидОпераціїБільше {
        біб::вивести(">");
      } інакше якщо вид == ВидОпераціїМеншеРівне {
        біб::вивести("<=");
      } інакше якщо вид == ВидОпераціїБільшеРівне {
        біб::вивести(">=");
      } інакше якщо вид == ВидОпераціїРівне {
        біб::вивести("==");
      } інакше якщо вид == ВидОпераціїНерівне {
        біб::вивести("!=");
      } інакше якщо вид == ВидОпераціїДІ {
        біб::вивести("&");
      } інакше якщо вид == ВидОпераціїВАБО {
        біб::вивести("∧");
      } інакше якщо вид == ВидОпераціїДАБО {
        біб::вивести("|");
      } інакше якщо вид == ВидОпераціїІ {
        біб::вивести("&&");
      } інакше якщо вид == ВидОпераціїАБО {
        біб::вивести("||");
      } інакше якщо вид == ВидОпераціїДіленняНаціло {
        біб::вивести("//");
      } інакше якщо вид == ВидОпераціїПіднесенняДоСтепеня {
        біб::вивести("**");
      } інакше якщо вид == ВидОпераціїМістить {
        біб::вивести("містить");
      } інакше якщо вид == ВидОпераціїНеМістить {
        біб::вивести("не містить");
      } інакше якщо вид == ВидОпераціїЄ {
        біб::вивести("є");
      } інакше якщо вид == ВидОпераціїНеЄ {
        біб::вивести("не є");
      } інакше якщо вид == ВидОпераціїЯк {
        біб::вивести("як");
      } інакше {
        біб::вивести("НЕВІДОМА ОПЕРАЦІЯ");
      }
    }

    дія вивести_пробіли(кількість: позитивне) {
      змінна п: позитивне = 0;
      поки п < кількість {
        біб::вивести(" ");
        п += 1;
      }
    }

    дія вивести_сполуку(розбирач: адреса<Розбирач>, значення: т8, слова: Слова, сполука: адреса<Сполука>, глибина: позитивне);

    дія вивести_аргумент(розбирач: адреса<Розбирач>, значення: т8, слова: Слова, аргумент: Аргумент, глибина: позитивне) {
      вивести_пробіли(глибина);
      біб::надрукувати("Аргумент(");
      вивести_сполуку(розбирач, значення, слова, аргумент.значення, глибина + 1);
      біб::надрукувати("");
      вивести_пробіли(глибина);
      біб::вивести(")");
    }

    дія вивести_аргументи(розбирач: адреса<Розбирач>, значення: т8, слова: Слова, аргументи: Аргументи, глибина: позитивне) {
      змінна п: позитивне = 0;

      поки п < аргументи.розмір {
        вивести_аргумент(розбирач, значення, слова, аргументи.дані[п], глибина);
        якщо п < аргументи.розмір - 1 {
          біб::надрукувати(",");
        }

        п += 1;
      }
    }

    дія вивести_сполуку(розбирач: адреса<Розбирач>, значення: т8, слова: Слова, сполука: адреса<Сполука>, глибина: позитивне) {
      вивести_пробіли(глибина);
      якщо сполука.вид == ВидСполукиЦіль {
        змінна дані = сполука.дані як ДаніСполукиЦіль;
        якщо дані.модифікатор == ЦільЗвичайна {
          біб::надрукувати("Ціль(");
        } інакше якщо дані.модифікатор == ЦільЗмінна {
          біб::надрукувати("Змінна(");
        } інакше {
          біб::надрукувати("Стала(");
        }
        вивести_пробіли(глибина + 1);
        біб::вивести("\"");
//        біб::вивести_ю8(отримати_значення_ідентифікатора(значення, слова, дані.ідентифікатор));
        якщо дані.значення != пусто {
          біб::надрукувати("\",");
          вивести_сполуку(розбирач, значення, слова, дані.значення, глибина + 1);
        }
        біб::надрукувати("");
        вивести_пробіли(глибина);
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиДія {
        змінна дані = сполука.дані як ДаніСполукиДія;
        біб::надрукувати("Дія(");
        вивести_пробіли(глибина + 1);
        якщо дані.доступність == ДІЯ_ВНУТРІШНЯ {
          біб::вивести("ВНУТРІШНЯ");
        } інакше якщо дані.доступність == ДІЯ_МІСЦЕВА {
          біб::вивести("МІСЦЕВА");
        } інакше якщо дані.доступність == ДІЯ_ЗОВНІШНЯ {
          біб::вивести("ЗОВНІШНЯ");
        } інакше {
          біб::вивести("НЕВІДОМА");
        }
        якщо дані.ідентифікатор.заповнено == позитивне(так) {
          біб::надрукувати(",");
          вивести_пробіли(глибина + 1);
          біб::вивести("\"");
//          біб::вивести_ю8(отримати_значення_ідентифікатора(значення, слова, дані.ідентифікатор.значення));
          біб::вивести("\"");
        }
        якщо дані.тіло.заповнено == позитивне(так) {
          біб::надрукувати(",");
          вивести_пробіли(глибина + 1);
          біб::надрукувати("[");
          надрукувати_сполуки(розбирач, значення, слова, дані.тіло.значення, глибина + 2);
          вивести_пробіли(глибина + 1);
          біб::вивести("]");
        }
        біб::надрукувати("");
        вивести_пробіли(глибина);
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиСтруктура {
        змінна дані = сполука.дані як ДаніСполукиСтруктура;
        біб::надрукувати("Структура(");
        якщо дані.ідентифікатор.заповнено == позитивне(так) {
          вивести_пробіли(глибина + 1);
          біб::вивести("\"");
//          біб::вивести_ю8(отримати_значення_ідентифікатора(значення, слова, дані.ідентифікатор.значення));
          біб::надрукувати("\"");
        }
        вивести_пробіли(глибина);
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиЗаписати {
        біб::вивести("Записати(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиПрочитати {
        змінна дані = сполука.дані як ДаніСполукиПрочитати;
        біб::вивести("Прочитати(");
        біб::вивести("\"");
//        біб::вивести_ю8(отримати_значення_ідентифікатора(значення, слова, дані.ідентифікатор));
        біб::вивести("\"");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиОтриматиВластивість {
        змінна дані = сполука.дані як ДаніСполукиОтриматиВластивість;
        біб::вивести("ОтриматиВластивість(");

        вивести_сполуку(розбирач, значення, слова, дані.ліво, глибина + 1);
        біб::вивести(", ");

        вивести_пробіли(глибина + 1);
        біб::вивести("\"\"");

        біб::надрукувати("");
        вивести_пробіли(глибина);
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиЗмінитиВластивість {
        біб::вивести("ЗмінитиВластивість(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиЗмінитиСекційнуВластивість {
        біб::вивести("ЗмінитиСекційнуВластивість(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиВаріативнийТип {
        біб::вивести("ВаріативнийТип(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиШаблон {
        біб::вивести("Шаблон(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиТипДії {
        біб::вивести("ТипДії(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиЗмінитиЕлемент {
        біб::вивести("ЗмінитиЕлемент(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиСинонім {
        біб::вивести("Синонім(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиВернути {
        біб::вивести("Вернути(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиЯкщо {
        біб::вивести("Якщо(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиПоки {
        біб::вивести("Поки(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиСекція {
        біб::вивести("Секція(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиКрок {
        біб::вивести("Крок(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиСтрибнути {
        біб::вивести("Стрибнути(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиВзяти {
        біб::вивести("Взяти(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиОтриматиСекційнуВластивість {
        змінна дані = сполука.дані як ДаніСполукиОтриматиСекційнуВластивість;
        біб::вивести("ОтриматиСекційнуВластивість(");

        вивести_сполуку(розбирач, значення, слова, дані.ліво, глибина + 1);
        біб::вивести(", ");

        вивести_пробіли(глибина + 1);
        біб::вивести("\"\"");

        біб::надрукувати("");
        вивести_пробіли(глибина);
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиОтриматиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиОтриматиЕлемент;
        біб::надрукувати("ОтриматиЕлемент(");

        вивести_сполуку(розбирач, значення, слова, дані.ліво, глибина + 1);
        біб::надрукувати(", ");

        вивести_сполуку(розбирач, значення, слова, дані.ключ, глибина + 1);

        біб::надрукувати("");
        вивести_пробіли(глибина);
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиВиконатиШаблон {
        змінна дані = сполука.дані як ДаніСполукиВиконатиШаблон;
        біб::надрукувати("ВиконатиШаблон(");

        вивести_сполуку(розбирач, значення, слова, дані.ліво, глибина + 1);
        біб::надрукувати(", ");

        вивести_пробіли(глибина + 1);
        біб::надрукувати("[");
        вивести_аргументи(розбирач, значення, слова, дані.аргументи, глибина + 2);
        біб::надрукувати("");
        вивести_пробіли(глибина + 1);
        біб::надрукувати("]");

        вивести_пробіли(глибина);
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиВиконатиДію {
        біб::вивести("ВиконатиДію(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиОднооперація {
        біб::вивести("Однооперація(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиОперація {
        змінна дані = сполука.дані як ДаніСполукиОперація;
        біб::надрукувати("Операція(");

        вивести_пробіли(глибина + 1);
        біб::вивести("\"");
        вивести_символ_операції(дані.вид);
        біб::надрукувати("\", ");

        вивести_сполуку(розбирач, значення, слова, дані.ліво, глибина + 1);
        біб::надрукувати(", ");

        вивести_сполуку(розбирач, значення, слова, дані.право, глибина + 1);

        біб::надрукувати("");
        вивести_пробіли(глибина);
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиЧисло {
        змінна дані = сполука.дані як ДаніСполукиЧисло;
        біб::вивести("Число(\"");

//        біб::вивести_ю8(отримати_значення_слова(значення, слова.дані[дані.позиція_слова]));

        біб::вивести("\")");
      } інакше якщо сполука.вид == ВидСполукиТекст {
        змінна дані = сполука.дані як ДаніСполукиТекст;
        біб::вивести("Текст(");

        якщо дані.префікс.заповнено == позитивне(так) {
          біб::вивести("\"");
//          біб::вивести_ю8(отримати_значення_ідентифікатора(значення, слова, дані.префікс.значення));
          біб::вивести("\"");
          біб::вивести(", ");
        }

        біб::вивести("\"");
//        біб::вивести_ю8(отримати_значення_тексту(значення, слова.дані[дані.позиція_слова]));
        біб::вивести("\")");
      } інакше якщо сполука.вид == ВидСполукиОбʼєкт {
        змінна дані = сполука.дані як ДаніСполукиОбʼєкт;
        біб::вивести("Обʼєкт(");
        біб::вивести(")");
      } інакше якщо сполука.вид == ВидСполукиПерелік {
        змінна дані = сполука.дані як ДаніСполукиОбʼєкт;
        біб::вивести("Перелік(");
        біб::вивести(")");
      }
    }

    дія надрукувати_сполуку(розбирач: адреса<Розбирач>, значення: т8, слова: Слова, сполука: адреса<Сполука>, глибина: позитивне) {
      вивести_сполуку(розбирач, значення, слова, сполука, глибина);
      біб::надрукувати("");
    }

    зовнішня дія надрукувати_сполуки(розбирач: адреса<Розбирач>, значення: т8, слова: Слова, сполуки: Сполуки, глибина: позитивне) {
      змінна п: позитивне = 0;

      поки п < сполуки.розмір {
        надрукувати_сполуку(розбирач, значення, слова, сполуки.дані[п], глибина);

        п += 1;
      }
    }

    дія знайти_границі_рядка(значення: т8, позиція_в_тексті: позитивне, вихід_початку: адреса<позитивне>, вихід_кінця: адреса<позитивне>) {
      змінна початок = позиція_в_тексті;
      поки початок > 0 {
        якщо значення.дані[початок - 1] == 10 {
          стрибнути далі_кінець;
        }

        початок -= 1;
      }

    далі_кінець:
      змінна кінець = позиція_в_тексті;
      поки кінець < значення.розмір {
        якщо значення.дані[кінець] == 10 {
          стрибнути вихід;
        }

        кінець += 1;
      }

    вихід:
      вихід_початку::вміст = початок;
      вихід_кінця::вміст = кінець;
    }

    дія знайти_границі_рядка_ю8(значення: ю8, позиція_в_тексті: позитивне, вихід_початку: адреса<позитивне>, вихід_кінця: адреса<позитивне>) {
      змінна початок = позиція_в_тексті;
      поки початок > 0 {
        якщо значення.дані[початок - 1] == 10 {
          стрибнути далі_кінець;
        }

        початок -= 1;
      }

    далі_кінець:
      змінна кінець = позиція_в_тексті;
      поки кінець < значення.розмір {
        якщо значення.дані[кінець] == 10 {
          стрибнути вихід;
        }

        кінець += 1;
      }

    вихід:
      вихід_початку::вміст = початок;
      вихід_кінця::вміст = кінець;
    }

    дія порахувати_кількість_символів_т8(значення: т8): позитивне {
      змінна кількість: позитивне = 0;
      змінна п: позитивне = 0;

      поки п < значення.розмір {
        змінна с = значення.дані[п];

        якщо с < 128 {
          п += 1;
        } інакше якщо (с & 224) == 192 {
          п += 2;
        } інакше якщо (с & 240) == 224 {
          п += 3;
        } інакше якщо (с & 248) == 240 {
          п += 4;
        } інакше {
          вернути кількість;
        }

        кількість += 1;
      }

      вернути кількість;
    }

    дія порахувати_зсув_т8(значення: т8, позиція_символа: позитивне): позитивне {
      змінна п: позитивне = 0;
      змінна символи: позитивне = 0;

      поки п < значення.розмір {
        якщо символи == позиція_символа {
          вернути п;
        }

        змінна с = значення.дані[п];

        якщо с < 128 {
          п += 1;
        } інакше якщо (с & 224) == 192 {
          п += 2;
        } інакше якщо (с & 240) == 224 {
          п += 3;
        } інакше якщо (с & 248) == 240 {
          п += 4;
        } інакше {
          вернути п;
        }

        символи += 1;
      }

      вернути п;
    }

    дія порахувати_кількість_символів_ю8(значення: ю8): позитивне {
      змінна кількість: позитивне = 0;
      змінна п: позитивне = 0;

      поки п < значення.розмір {
        змінна с = значення.дані[п];

        якщо с < 128 {
          п += 1;
        } інакше якщо (с & 224) == 192 {
          п += 2;
        } інакше якщо (с & 240) == 224 {
          п += 3;
        } інакше якщо (с & 248) == 240 {
          п += 4;
        } інакше {
          вернути кількість;
        }

        кількість += 1;
      }

      вернути кількість;
    }

    дія порахувати_зсув_ю8(значення: ю8, позиція_символа: позитивне): позитивне {
      змінна п: позитивне = 0;
      змінна символи: позитивне = 0;

      поки п < значення.розмір {
        якщо символи == позиція_символа {
          вернути п;
        }

        змінна с = значення.дані[п];

        якщо с < 128 {
          п += 1;
        } інакше якщо (с & 224) == 192 {
          п += 2;
        } інакше якщо (с & 240) == 224 {
          п += 3;
        } інакше якщо (с & 248) == 240 {
          п += 4;
        } інакше {
          вернути п;
        }

        символи += 1;
      }

      вернути п;
    }

    зовнішня дія витнути_значення(значення: т8, позиція_помилки: позитивне, максимальна_довжина: позитивне): ВитнутеЗначенняЗіСловом {
      змінна результат = ВитнутеЗначенняЗіСловом {
        витнуте_значення = т8 { 0, пусто },
        початок_підкреслення = 0
      };

      якщо максимальна_довжина == 0 {
        вернути результат;
      }

      змінна рядок_початок: позитивне = 0;
      змінна рядок_кінець: позитивне = 0;
      знайти_границі_рядка(значення, позиція_помилки, рядок_початок::адреса, рядок_кінець::адреса);

      змінна рядок = т8 {
        рядок_кінець - рядок_початок,
        значення.дані[рядок_початок]::адреса як памʼять<п8>
      };

      змінна позиція_символа_помилки = порахувати_кількість_символів_т8(т8 { позиція_помилки - рядок_початок, рядок.дані });
      змінна рядок_символи = порахувати_кількість_символів_т8(рядок);

      змінна макс_байти = максимальна_довжина;
      якщо макс_байти > рядок.розмір {
        макс_байти = рядок.розмір;
      }

      змінна половина_символів = макс_байти / 2;

      змінна під_початок_символ: позитивне = 0;
      якщо позиція_символа_помилки > половина_символів {
        під_початок_символ = позиція_символа_помилки - половина_символів;
      }

      якщо (під_початок_символ + макс_байти) > рядок_символи {
        якщо рядок_символи > макс_байти {
          під_початок_символ = рядок_символи - макс_байти;
        } інакше {
          під_початок_символ = 0;
        }
      }

      змінна під_початок_байт = порахувати_зсув_т8(рядок, під_початок_символ);

      змінна під_кінець_байт = під_початок_байт + макс_байти;
      якщо під_кінець_байт > рядок.розмір {
        під_кінець_байт = рядок.розмір;
      }

      змінна під_розмір = під_кінець_байт - під_початок_байт;

      результат.витнуте_значення = т8 {
        під_розмір,
        рядок.дані[під_початок_байт]::адреса як памʼять<п8>
      };

      якщо позиція_символа_помилки >= під_початок_символ {
        результат.початок_підкреслення = позиція_символа_помилки - під_початок_символ;
      } інакше {
        результат.початок_підкреслення = 0;
      }

      вернути результат;
    }

    дія виправити_т8_якщо_незакінчено(значення: т8): т8 {
      змінна п: позитивне = 0;

      поки п < значення.розмір {
        змінна с = значення.дані[п];

        якщо с < 128 {
          п += 1;
        } інакше якщо (с & 224) == 192 {
          якщо п + 1 < значення.розмір {
            п += 2;
          } інакше {
            значення.розмір = значення.розмір - 1;

            вернути значення;
          }
        } інакше якщо (с & 240) == 224 {
          якщо п + 2 < значення.розмір {
            п += 3;
          } інакше {
            значення.розмір = значення.розмір - 2;

            вернути значення;
          }
        } інакше якщо (с & 248) == 240 {
          якщо п + 3 < значення.розмір {
            п += 4;
          } інакше {
            значення.розмір = значення.розмір - 3;

            вернути значення;
          }
        } інакше {
          вернути значення;
        }
      }

      вернути значення;
    }

    дія виправити_ю8_якщо_незакінчено(значення: ю8): ю8 {
      змінна п: позитивне = 0;

      поки п < значення.розмір {
        змінна с = значення.дані[п];

        якщо с < 128 {
          п += 1;
        } інакше якщо (с & 224) == 192 {
          якщо п + 1 < значення.розмір {
            п += 2;
          } інакше {
            значення.розмір = значення.розмір - 1;

            вернути значення;
          }
        } інакше якщо (с & 240) == 224 {
          якщо п + 2 < значення.розмір {
            п += 3;
          } інакше {
            значення.розмір = значення.розмір - 2;

            вернути значення;
          }
        } інакше якщо (с & 248) == 240 {
          якщо п + 3 < значення.розмір {
            п += 4;
          } інакше {
            значення.розмір = значення.розмір - 3;

            вернути значення;
          }
        } інакше {
          вернути значення;
        }
      }

      вернути значення;
    }

    зовнішня дія витнути_значення_ю8(значення: ю8, позиція_помилки: позитивне, максимальна_довжина: позитивне): ВитнутеЗначенняЗіСловомЮ8 {
      змінна результат = ВитнутеЗначенняЗіСловомЮ8 {
        витнуте_значення = ю8 { 0, пусто },
        початок_підкреслення = 0
      };

      якщо максимальна_довжина == 0 {
        вернути результат;
      }

      змінна рядок_початок: позитивне = 0;
      змінна рядок_кінець: позитивне = 0;
      знайти_границі_рядка_ю8(значення, позиція_помилки, рядок_початок::адреса, рядок_кінець::адреса);

      змінна рядок = ю8 {
        рядок_кінець - рядок_початок,
        значення.дані[рядок_початок]::адреса як памʼять<п8>
      };

      змінна позиція_символа_помилки = порахувати_кількість_символів_ю8(ю8 { позиція_помилки - рядок_початок, рядок.дані });
      змінна рядок_символи = порахувати_кількість_символів_ю8(рядок);

      змінна макс_байти = максимальна_довжина;
      якщо макс_байти > рядок.розмір {
        макс_байти = рядок.розмір;
      }

      змінна половина_символів = макс_байти / 2;

      змінна під_початок_символ: позитивне = 0;
      якщо позиція_символа_помилки > половина_символів {
        під_початок_символ = позиція_символа_помилки - половина_символів;
      }

      якщо (під_початок_символ + макс_байти) > рядок_символи {
        якщо рядок_символи > макс_байти {
          під_початок_символ = рядок_символи - макс_байти;
        } інакше {
          під_початок_символ = 0;
        }
      }

      змінна під_початок_байт = порахувати_зсув_ю8(рядок, під_початок_символ);

      змінна під_кінець_байт = під_початок_байт + макс_байти;
      якщо під_кінець_байт > рядок.розмір {
        під_кінець_байт = рядок.розмір;
      }

      змінна під_розмір = під_кінець_байт - під_початок_байт;

      результат.витнуте_значення = виправити_ю8_якщо_незакінчено(
        ю8 {
          під_розмір,
          рядок.дані[під_початок_байт]::адреса як памʼять<п8>
        }
      );

      якщо позиція_символа_помилки >= під_початок_символ {
        результат.початок_підкреслення = позиція_символа_помилки - під_початок_символ;
      } інакше {
        результат.початок_підкреслення = 0;
      }

      вернути результат;
    }
  }
}