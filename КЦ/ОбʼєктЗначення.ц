взяти визначення Ц;

секція ц {
  дія обʼєкт_значення_arithmetic_operation(тип: комірка<ОбʼєктТипу>, llvm_diia: (L: комірка<LLVM::TL>, блок: комірка<LLVM::BasicBlock>, ліво: комірка<LLVM::Value>, право: комірка<LLVM::Value>) -> комірка<LLVM::Value>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо аргумент.обʼєкт.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення_аргумента = аргумент.обʼєкт.дані як ОбʼєктЗначення;
      якщо обʼєкт_значення_аргумента.тип == тип {
        ціль обʼєкт_значення_для_результату = ОбʼєктЗначення {};
        обʼєкт_значення_для_результату.тип = тип;
        обʼєкт_значення_для_результату.llvm_value = llvm_diia(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, обʼєкт_значення_аргумента.llvm_value);
        ціль обʼєкт_для_результату = Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_результату };
        вернути Результат { обʼєкт_для_результату, помилка = пусто };
      }
    } інакше якщо аргумент.обʼєкт.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення_для_аргумента = аргумент.обʼєкт.дані як ОбʼєктНезавантаженогоЗначення;
      ціль обʼєкт_значення_для_аргумента = ОбʼєктЗначення {};
      обʼєкт_значення_для_аргумента.тип = обʼєкт_незавантаженого_значення_для_аргумента.тип;
      обʼєкт_значення_для_аргумента.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення_для_аргумента.тип.llvm_type, обʼєкт_незавантаженого_значення_для_аргумента.llvm_value);
      ціль обʼєкт_для_аргумента = Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_аргумента };
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось виконати операцію");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_значення_add(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::add, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fadd(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::fadd, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_sub(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::sub, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fsub(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::fsub, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_mul(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::mul, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fmul(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::fmul, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_sdiv(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::sdiv, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_udiv(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::udiv, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fdiv(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::fdiv, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_srem(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::srem, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_urem(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::urem, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_frem(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::frem, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_shl(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::shl, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_lshr(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::lshr, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_ashr(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::ashr, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_and(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::and, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_or(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::or, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_xor(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::xor, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }
}

секція ц {
  місцева дія обʼєкт_значення_додати(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_add(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_add(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_add(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_add(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_add(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_add(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_add(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_add(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_add(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fadd(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fadd(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
      ціль новий_обʼєкт_значення = ОбʼєктЗначення {};
      новий_обʼєкт_значення.тип = К.тип_п64;
      новий_обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, К.тип_п64.llvm_type);
      ціль результат_додавання_адреси = обʼєкт_значення_add(К.тип_п64, новий_обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
      якщо результат_додавання_адреси.помилка != пусто {
        вернути результат_додавання_адреси.помилка;
      }
      якщо результат_додавання_адреси.обʼєкт.вид == ВидОбʼєктаЗначення {
        ціль новий_обʼєкт_значення = результат_додавання_адреси.обʼєкт.дані як ОбʼєктЗначення;
        якщо новий_обʼєкт_значення.тип == К.тип_п64 {
          новий_обʼєкт_значення.тип = обʼєкт_значення.тип;
          новий_обʼєкт_значення.llvm_value = LLVM::inttoptr(К.L, інформація_середовища.llvm_block, новий_обʼєкт_значення.llvm_value, обʼєкт_значення.тип.llvm_type);
          вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = новий_обʼєкт_значення }, помилка = пусто };
        }
      }
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось додати");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_відняти(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_sub(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_sub(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_sub(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_sub(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_sub(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_sub(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_sub(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_sub(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_sub(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fsub(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fsub(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
      ціль новий_обʼєкт_значення = ОбʼєктЗначення {};
      новий_обʼєкт_значення.тип = К.тип_п64;
      новий_обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, К.тип_п64.llvm_type);
      ціль результат_додавання_адреси = обʼєкт_значення_sub(К.тип_п64, новий_обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
      якщо результат_додавання_адреси.помилка != пусто {
        вернути результат_додавання_адреси.помилка;
      }
      якщо результат_додавання_адреси.обʼєкт.вид == ВидОбʼєктаЗначення {
        ціль новий_обʼєкт_значення = результат_додавання_адреси.обʼєкт.дані як ОбʼєктЗначення;
        якщо новий_обʼєкт_значення.тип == К.тип_п64 {
          новий_обʼєкт_значення.тип = обʼєкт_значення.тип;
          новий_обʼєкт_значення.llvm_value = LLVM::inttoptr(К.L, інформація_середовища.llvm_block, новий_обʼєкт_значення.llvm_value, обʼєкт_значення.тип.llvm_type);
          вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = новий_обʼєкт_значення }, помилка = пусто };
        }
      }
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось відняти");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_помножити(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_mul(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_mul(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_mul(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_mul(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_mul(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_mul(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_mul(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_mul(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_mul(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fmul(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fmul(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось помножити");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_поділити(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_sdiv(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_sdiv(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_sdiv(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_sdiv(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_udiv(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_udiv(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_udiv(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_udiv(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_udiv(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fdiv(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fdiv(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось поділити");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_поділити_за_модулем(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_srem(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_srem(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_srem(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_srem(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_urem(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_urem(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_urem(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_urem(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_urem(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_frem(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_frem(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось поділити_за_модулем");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_значення_logical_operation(тип: комірка<ОбʼєктТипу>, llvm_diia: (L: комірка<LLVM::TL>, блок: комірка<LLVM::BasicBlock>, ліво: комірка<LLVM::Value>, право: комірка<LLVM::Value>) -> комірка<LLVM::Value>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо аргумент.обʼєкт.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення_аргумента = аргумент.обʼєкт.дані як ОбʼєктЗначення;
      якщо обʼєкт_значення_аргумента.тип == тип {
        ціль обʼєкт_значення_для_результату = ОбʼєктЗначення {};
        обʼєкт_значення_для_результату.тип = К.тип_логічне;
        обʼєкт_значення_для_результату.llvm_value = llvm_diia(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, обʼєкт_значення_аргумента.llvm_value);
        ціль обʼєкт_для_результату = Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_результату };
        вернути Результат { обʼєкт_для_результату, помилка = пусто };
      } інакше якщо обʼєкт_значення_аргумента.тип.вид == ВидТипуАдреса {
        якщо тип.вид == ВидТипуАдреса {
          ціль обʼєкт_значення_для_результату = ОбʼєктЗначення {};
          обʼєкт_значення_для_результату.тип = К.тип_логічне;
          обʼєкт_значення_для_результату.llvm_value = llvm_diia(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, обʼєкт_значення_аргумента.llvm_value);
          ціль обʼєкт_для_результату = Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_результату };
          вернути Результат { обʼєкт_для_результату, помилка = пусто };
        }
      }
    } інакше якщо аргумент.обʼєкт.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення_для_аргумента = аргумент.обʼєкт.дані як ОбʼєктНезавантаженогоЗначення;
      ціль обʼєкт_значення_для_аргумента = ОбʼєктЗначення {};
      обʼєкт_значення_для_аргумента.тип = обʼєкт_незавантаженого_значення_для_аргумента.тип;
      обʼєкт_значення_для_аргумента.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення_для_аргумента.тип.llvm_type, обʼєкт_незавантаженого_значення_для_аргумента.llvm_value);
      ціль обʼєкт_для_аргумента = Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_аргумента };
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось виконати операцію");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_значення_icmp_sgt(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_sgt, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_ugt(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_ugt, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_ogt(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_ogt, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_ugt(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_ugt, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_sge(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_sge, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_uge(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_uge, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_oge(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_oge, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_uge(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_uge, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_slt(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_slt, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_ult(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_ult, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_olt(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_olt, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_ult(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_ult, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_sle(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_sle, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_ule(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_ule, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_ole(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_ole, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_ule(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_ule, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_eq(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_eq, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_ne(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_ne, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_oeq(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_oeq, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_one(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_one, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_ueq(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_ueq, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_une(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_une, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }
}

секція ц {
  місцева дія обʼєкт_значення_більше(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_icmp_sgt(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_icmp_sgt(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_icmp_sgt(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_icmp_sgt(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_icmp_ugt(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_icmp_ugt(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_icmp_ugt(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_icmp_ugt(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_icmp_ugt(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fcmp_ugt(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fcmp_ugt(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось більше");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_менше(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_icmp_slt(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_icmp_slt(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_icmp_slt(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_icmp_slt(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_icmp_ult(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_icmp_ult(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_icmp_ult(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_icmp_ult(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_icmp_ult(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fcmp_ult(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fcmp_ult(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось менше");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_більше_рівно(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_icmp_sge(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_icmp_sge(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_icmp_sge(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_icmp_sge(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_icmp_uge(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_icmp_uge(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_icmp_uge(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_icmp_uge(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_icmp_uge(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fcmp_uge(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fcmp_uge(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось більше_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_менше_рівно(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_icmp_sle(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_icmp_sle(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_icmp_sle(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_icmp_sle(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_icmp_ule(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_icmp_ule(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_icmp_ule(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_icmp_ule(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_icmp_ule(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fcmp_ule(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fcmp_ule(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось менше_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_рівно(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_icmp_eq(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_icmp_eq(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_icmp_eq(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_icmp_eq(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_icmp_eq(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_icmp_eq(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_icmp_eq(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_icmp_eq(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_icmp_eq(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fcmp_ueq(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fcmp_ueq(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
      вернути обʼєкт_значення_icmp_eq(К.тип_адреса, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось рівно");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_не_рівно(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_icmp_ne(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_icmp_ne(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_icmp_ne(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_icmp_ne(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_icmp_ne(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_icmp_ne(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_icmp_ne(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_icmp_ne(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_icmp_ne(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fcmp_une(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fcmp_une(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
      вернути обʼєкт_значення_icmp_ne(К.тип_адреса, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось не_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_зсунути_вліво(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_shl(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_shl(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_shl(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_shl(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_shl(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_shl(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_shl(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_shl(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_shl(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вліво");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_зсунути_вправо(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_lshr(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_lshr(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_lshr(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_lshr(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_lshr(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_lshr(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_lshr(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_lshr(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_lshr(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вправо");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_зсунути_вправо_знаковий(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_ashr(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_ashr(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_ashr(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_ashr(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_ashr(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_ashr(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_ashr(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_ashr(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_ashr(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вправо_знаковий");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_ді(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_and(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_and(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_and(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_and(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_and(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_and(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_and(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_and(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_and(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось ді");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_дабо(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_or(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_or(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_or(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_or(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_or(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_or(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_or(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_or(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_or(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось дабо");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_вабо(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_xor(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_xor(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_xor(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_xor(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_логічне {
      вернути обʼєкт_значення_xor(К.тип_логічне, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_xor(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_xor(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_xor(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_xor(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось вабо");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_як(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Аргумент): Результат {
    якщо аргумент.обʼєкт.вид != ВидОбʼєктаТипу {
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
      вернути Результат { помилка = помилка_компіляції };
    }
    ціль новий_тип = аргумент.обʼєкт.дані як комірка<ОбʼєктТипу>;
    якщо новий_тип == обʼєкт_значення.тип {
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
    }
    якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
      якщо новий_тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо новий_тип.вид == ВидТипуДія {
        // потім: перевірити чи це тип невідомої адреси
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо обʼєкт_значення.тип.вид == ВидТипуДія {
      // потім: перевірити тут тоже!!!
      якщо новий_тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо обʼєкт_значення.тип.вид == ВидТипуВаріація {
      змінна ціль знайдений_тип_варіації: комірка<ОбʼєктТипу> = пусто;
      змінна ціль пх: позитивне = 0;
      поки пх < обʼєкт_значення.тип.типи_варіації.довжина {
        якщо перевірити_тип(обʼєкт_значення.тип.типи_варіації.дані[пх], новий_тип) {
          знайдений_тип_варіації = обʼєкт_значення.тип.типи_варіації.дані[пх];
        }
        пх = пх + 1;
      }
      якщо знайдений_тип_варіації == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
        вернути Результат { помилка = помилка_компіляції };
      }
      обʼєкт_значення.тип = знайдений_тип_варіації;
      обʼєкт_значення.llvm_value = LLVM::bitcast(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, знайдений_тип_варіації.llvm_type);
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
    }
    якщо новий_тип == К.тип_логічне {
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_ц8 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_ц16 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_ц32 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_ц64 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_п8 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_п16 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_п32 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_п64 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_д32 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptrunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_д64 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fpext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_отримати_властивість(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_отримати_властивість_секції(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість_секції");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_отримати_за_позицією(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, позиція: Аргумент, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
      ціль тип = обʼєкт_значення.тип.тип_адреси;
      ціль результат_отримання_позиції_як_значення = отримати_як_значення(К, інформація_середовища, місцезнаходження, позиція.обʼєкт, К.тип_ц32);
      якщо результат_отримання_позиції_як_значення.помилка != пусто {
        вернути Результат { помилка = результат_отримання_позиції_як_значення.помилка };
      }
      ціль обʼєкт_значення_позиції = результат_отримання_позиції_як_значення.обʼєкт_значення;
      ціль gep_positions_llvm_values = виділити<комірка<LLVM::Value>>(1);
      gep_positions_llvm_values[0] = обʼєкт_значення_позиції.llvm_value;
      ціль llvm_value_gep = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, тип.llvm_type, обʼєкт_значення.llvm_value, 1, gep_positions_llvm_values);
      ціль обʼєкт_незавантаженого_значення = ОбʼєктНезавантаженогоЗначення {};
      обʼєкт_незавантаженого_значення.тип = тип;
      обʼєкт_незавантаженого_значення.llvm_value = llvm_value_gep;
      вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженогоЗначення, дані = обʼєкт_незавантаженого_значення }, помилка = пусто };
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_за_позицією");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_виконати(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, кількість_аргументів: позитивне, аргументи: памʼять<Аргумент>): Результат {
    якщо обʼєкт_значення.тип.вид == ВидТипуДія {
      якщо кількість_аргументів != обʼєкт_значення.тип.параметри_дії.довжина {
        ціль помилка_компіляції = виділити_помилку_компіляції_невірна_кількість_аргументів(місцезнаходження, обʼєкт_значення.тип.параметри_дії.довжина, кількість_аргументів);
        вернути Результат { помилка = помилка_компіляції };
      }
      ціль args_llvm_values = виділити<комірка<LLVM::Value>>(кількість_аргументів як ц32);
//      відкласти звільнити(args_llvm_values);
      змінна ціль параметри: комірка<список<ПараметрДії>> = обʼєкт_значення.тип.параметри_дії;
      змінна ціль тип_результату: комірка<ОбʼєктТипу> = обʼєкт_значення.тип.тип_результату_дії;
      змінна ціль llvm_function_type = обʼєкт_значення.тип.llvm_function_type;
      змінна ціль llvm_value: комірка<LLVM::Value> = обʼєкт_значення.llvm_value;
      змінна ціль ах: позитивне = 0;
      поки ах < кількість_аргументів {
        ціль параметр = параметри.дані[ах];
        ціль результат_аргумента_як_значення = отримати_як_значення(К, інформація_середовища, аргументи[ах].місцезнаходження, аргументи[ах].обʼєкт, параметр.тип);
        якщо результат_аргумента_як_значення.помилка != пусто {
          вернути Результат { помилка = результат_аргумента_як_значення.помилка };
        }
        ціль обʼєкт_значення_аргумента = результат_аргумента_як_значення.обʼєкт_значення;
        ціль результат_перевірки_типу_значення = перевірити_тип_значення_і_перетворити_якщо_треба(К, параметр.тип, обʼєкт_значення_аргумента);
        якщо результат_перевірки_типу_значення.успіх == ні {
          ціль помилка_компіляції = виділити_помилку_компіляції_невірний_тип_аргумента(місцезнаходження, параметр.назва, параметр.тип, обʼєкт_значення_аргумента.тип);
          вернути Результат { помилка = помилка_компіляції };
        }
        обʼєкт_значення_аргумента = результат_перевірки_типу_значення.обʼєкт_значення;
        args_llvm_values[ах] = обʼєкт_значення_аргумента.llvm_value;
        ах = ах + 1;
      }
      ціль llvm_value_call = LLVM::call(К.L, інформація_середовища.llvm_block, llvm_function_type як комірка<LLVM::Type>, llvm_value, параметри.довжина, args_llvm_values);
      ціль обʼєкт_значення_виконання = ОбʼєктЗначення {};
      обʼєкт_значення_виконання.тип = тип_результату;
      обʼєкт_значення_виконання.llvm_value = llvm_value_call;
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_виконання }, помилка = пусто };
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось виконати");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_виконати_шаблон(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, кількість_аргументів: позитивне, аргументи: памʼять<Аргумент>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось виконати_шаблон");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_змінити_властивість(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, аргумент: Аргумент): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось змінити_властивість");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_змінити_в_секції(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, аргумент: Аргумент): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось змінити_в_секції");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  місцева дія обʼєкт_значення_змінити_за_позицією(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, позиція: Аргумент, аргумент: Аргумент): Результат {
    якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
      ціль тип = обʼєкт_значення.тип.тип_адреси;
      ціль результат_отримання_позиції_як_значення = отримати_як_значення(К, інформація_середовища, місцезнаходження, позиція.обʼєкт, К.тип_ц32);
      якщо результат_отримання_позиції_як_значення.помилка != пусто {
        вернути Результат { помилка = результат_отримання_позиції_як_значення.помилка };
      }
      ціль обʼєкт_значення_позиції = результат_отримання_позиції_як_значення.обʼєкт_значення;
      ціль gep_positions_llvm_values = виділити<комірка<LLVM::Value>>(1);
      gep_positions_llvm_values[0] = обʼєкт_значення_позиції.llvm_value;
      ціль llvm_value_gep = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, тип.llvm_type, обʼєкт_значення.llvm_value, 1, gep_positions_llvm_values);
      ціль результат_аргумента_як_значення = отримати_як_значення(К, інформація_середовища, аргумент.місцезнаходження, аргумент.обʼєкт, тип);
      якщо результат_аргумента_як_значення.помилка != пусто {
        вернути Результат { помилка = результат_аргумента_як_значення.помилка };
      }
      ціль обʼєкт_значення_аргумента = результат_аргумента_як_значення.обʼєкт_значення;
      якщо тип.вид == ВидТипуВаріація {
        змінна ціль знайдений_тип_варіації: комірка<ОбʼєктТипу> = пусто;
        змінна ціль пх: позитивне = 0;
        поки пх < тип.типи_варіації.довжина {
          якщо перевірити_тип(обʼєкт_значення_аргумента.тип, тип.типи_варіації.дані[пх]) == так {
            знайдений_тип_варіації = тип.типи_варіації.дані[пх];
          }
          пх = пх + 1;
        }
        якщо знайдений_тип_варіації == пусто {
          ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Вітання помилка");
          вернути Результат { помилка = помилка_компіляції };
        }
      } інакше {
        якщо перевірити_тип(обʼєкт_значення_аргумента.тип, тип) == ні {
          ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Вітання помилка");
          вернути Результат { помилка = помилка_компіляції };
        }
      }
      LLVM::store(К.L, інформація_середовища.llvm_block, обʼєкт_значення_аргумента.llvm_value, llvm_value_gep);
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_аргумента }, помилка = пусто };
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось змінити_за_позицією");
    вернути Результат { помилка = помилка_компіляції };
  }
}