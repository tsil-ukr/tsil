взяти визначення КЦ;

секція КЦ {
  дія обʼєкт_значення_арифметична_операція(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, д: (крок: адреса<ПМ::Крок>, ліво: адреса<ПМ::Значення>, право: адреса<ПМ::Значення>) -> адреса<ПМ::Значення>, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    змінна обʼєкт_значення_аргумента: ОбʼєктЗначення;

    якщо аргумент.обʼєкт.вид == ВидОбʼєктаЗначення {
      обʼєкт_значення_аргумента = аргумент.обʼєкт.дані як ОбʼєктЗначення;
    } інакше якщо аргумент.обʼєкт.вид == ВидОбʼєктаНезавантаженеЗначення {
      змінна обʼєкт_незавантаженого_значення_для_аргумента = аргумент.обʼєкт.дані як ОбʼєктНезавантаженогоЗначення;
      обʼєкт_значення_аргумента.тип = обʼєкт_незавантаженого_значення_для_аргумента.тип;
      обʼєкт_значення_аргумента.пм_значення = ПМ::вказівка_прочитати(контекст.кк_дії.поточний_крок.пм_крок, обʼєкт_незавантаженого_значення_для_аргумента.тип.пм_тип, обʼєкт_незавантаженого_значення_для_аргумента.пм_значення);
    } інакше {
      вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
    }

    якщо обʼєкт_значення_аргумента.тип == обʼєкт_значення.тип {
      змінна пм_значення = д(контекст.кк_дії.поточний_крок.пм_крок, обʼєкт_значення.пм_значення, обʼєкт_значення_аргумента.пм_значення);

      змінна обʼєкт_для_результату = Обʼєкт {
        ВидОбʼєктаЗначення,
        ОбʼєктЗначення { обʼєкт_значення.тип, пм_значення }
      };

      вернути РезультатОбʼєкта { обʼєкт_для_результату, помилка = пусто };
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_додати(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_додати_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_додати_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_додати_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_додати_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_додати_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_додати_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_додати_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_додати_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_додати_п64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_додати_д32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_додати_д64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуАдреса {
      змінна новий_обʼєкт_значення: ОбʼєктЗначення;
      новий_обʼєкт_значення.тип = компілятор.тип_п64;
      новий_обʼєкт_значення.пм_значення = ПМ::перетворити_адресу_на_п64(контекст.кк_дії.поточний_крок.пм_крок, обʼєкт_значення.пм_значення);

      змінна результат_додавання_адреси = обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_додати_п64, новий_обʼєкт_значення, аргумент);
      якщо результат_додавання_адреси.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_додавання_адреси.помилка };
      }

      якщо результат_додавання_адреси.обʼєкт.вид == ВидОбʼєктаЗначення {
        змінна доданий_обʼєкт_значення = результат_додавання_адреси.обʼєкт.дані як ОбʼєктЗначення;

        якщо доданий_обʼєкт_значення.тип == компілятор.тип_п64 {
          новий_обʼєкт_значення.тип = обʼєкт_значення.тип;
          новий_обʼєкт_значення.пм_значення = ПМ::перетворити_п64_на_адресу(контекст.кк_дії.поточний_крок.пм_крок, доданий_обʼєкт_значення.пм_значення);

          вернути РезультатОбʼєкта { Обʼєкт { ВидОбʼєктаЗначення, дані = новий_обʼєкт_значення }, помилка = пусто };
        }
      }
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_відняти(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_відняти_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_відняти_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_відняти_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_відняти_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_відняти_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_відняти_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_відняти_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_відняти_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_відняти_п64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_відняти_д32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_відняти_д64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуАдреса {
      змінна новий_обʼєкт_значення: ОбʼєктЗначення;
      новий_обʼєкт_значення.тип = компілятор.тип_п64;
      новий_обʼєкт_значення.пм_значення = ПМ::перетворити_адресу_на_п64(контекст.кк_дії.поточний_крок.пм_крок, обʼєкт_значення.пм_значення);

      змінна результат_додавання_адреси = обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_відняти_п64, новий_обʼєкт_значення, аргумент);
      якщо результат_додавання_адреси.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_додавання_адреси.помилка };
      }

      якщо результат_додавання_адреси.обʼєкт.вид == ВидОбʼєктаЗначення {
        змінна доданий_обʼєкт_значення = результат_додавання_адреси.обʼєкт.дані як ОбʼєктЗначення;

        якщо доданий_обʼєкт_значення.тип == компілятор.тип_п64 {
          новий_обʼєкт_значення.тип = обʼєкт_значення.тип;
          новий_обʼєкт_значення.пм_значення = ПМ::перетворити_п64_на_адресу(контекст.кк_дії.поточний_крок.пм_крок, доданий_обʼєкт_значення.пм_значення);

          вернути РезультатОбʼєкта { Обʼєкт { ВидОбʼєктаЗначення, дані = новий_обʼєкт_значення }, помилка = пусто };
        }
      }
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_помножити(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_помножити_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_помножити_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_помножити_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_помножити_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_помножити_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_помножити_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_помножити_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_помножити_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_помножити_п64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_помножити_д32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_помножити_д64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуАдреса {
      змінна новий_обʼєкт_значення: ОбʼєктЗначення;
      новий_обʼєкт_значення.тип = компілятор.тип_п64;
      новий_обʼєкт_значення.пм_значення = ПМ::перетворити_адресу_на_п64(контекст.кк_дії.поточний_крок.пм_крок, обʼєкт_значення.пм_значення);

      змінна результат_додавання_адреси = обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_помножити_п64, новий_обʼєкт_значення, аргумент);
      якщо результат_додавання_адреси.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_додавання_адреси.помилка };
      }

      якщо результат_додавання_адреси.обʼєкт.вид == ВидОбʼєктаЗначення {
        змінна доданий_обʼєкт_значення = результат_додавання_адреси.обʼєкт.дані як ОбʼєктЗначення;

        якщо доданий_обʼєкт_значення.тип == компілятор.тип_п64 {
          новий_обʼєкт_значення.тип = обʼєкт_значення.тип;
          новий_обʼєкт_значення.пм_значення = ПМ::перетворити_п64_на_адресу(контекст.кк_дії.поточний_крок.пм_крок, доданий_обʼєкт_значення.пм_значення);

          вернути РезультатОбʼєкта { Обʼєкт { ВидОбʼєктаЗначення, дані = новий_обʼєкт_значення }, помилка = пусто };
        }
      }
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_поділити(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_поділити_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_поділити_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_поділити_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_поділити_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_поділити_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_поділити_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_поділити_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_поділити_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_поділити_п64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_поділити_д32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_поділити_д64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуАдреса {
      змінна новий_обʼєкт_значення: ОбʼєктЗначення;
      новий_обʼєкт_значення.тип = компілятор.тип_п64;
      новий_обʼєкт_значення.пм_значення = ПМ::перетворити_адресу_на_п64(контекст.кк_дії.поточний_крок.пм_крок, обʼєкт_значення.пм_значення);

      змінна результат_додавання_адреси = обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_поділити_п64, новий_обʼєкт_значення, аргумент);
      якщо результат_додавання_адреси.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_додавання_адреси.помилка };
      }

      якщо результат_додавання_адреси.обʼєкт.вид == ВидОбʼєктаЗначення {
        змінна доданий_обʼєкт_значення = результат_додавання_адреси.обʼєкт.дані як ОбʼєктЗначення;

        якщо доданий_обʼєкт_значення.тип == компілятор.тип_п64 {
          новий_обʼєкт_значення.тип = обʼєкт_значення.тип;
          новий_обʼєкт_значення.пм_значення = ПМ::перетворити_п64_на_адресу(контекст.кк_дії.поточний_крок.пм_крок, доданий_обʼєкт_значення.пм_значення);

          вернути РезультатОбʼєкта { Обʼєкт { ВидОбʼєктаЗначення, дані = новий_обʼєкт_значення }, помилка = пусто };
        }
      }
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_поділити_за_модулем(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_остача_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_остача_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_остача_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_остача_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_остача_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_остача_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_остача_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_остача_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_остача_п64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_остача_д32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_остача_д64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуАдреса {
      змінна новий_обʼєкт_значення: ОбʼєктЗначення;
      новий_обʼєкт_значення.тип = компілятор.тип_п64;
      новий_обʼєкт_значення.пм_значення = ПМ::перетворити_адресу_на_п64(контекст.кк_дії.поточний_крок.пм_крок, обʼєкт_значення.пм_значення);

      змінна результат_додавання_адреси = обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_остача_п64, новий_обʼєкт_значення, аргумент);
      якщо результат_додавання_адреси.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_додавання_адреси.помилка };
      }

      якщо результат_додавання_адреси.обʼєкт.вид == ВидОбʼєктаЗначення {
        змінна доданий_обʼєкт_значення = результат_додавання_адреси.обʼєкт.дані як ОбʼєктЗначення;

        якщо доданий_обʼєкт_значення.тип == компілятор.тип_п64 {
          новий_обʼєкт_значення.тип = обʼєкт_значення.тип;
          новий_обʼєкт_значення.пм_значення = ПМ::перетворити_п64_на_адресу(контекст.кк_дії.поточний_крок.пм_крок, доданий_обʼєкт_значення.пм_значення);

          вернути РезультатОбʼєкта { Обʼєкт { ВидОбʼєктаЗначення, дані = новий_обʼєкт_значення }, помилка = пусто };
        }
      }
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  дія обʼєкт_значення_порівняльна_операція(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, д: (крок: адреса<ПМ::Крок>, ліво: адреса<ПМ::Значення>, право: адреса<ПМ::Значення>) -> адреса<ПМ::Значення>, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    змінна обʼєкт_значення_аргумента: ОбʼєктЗначення;

    якщо аргумент.обʼєкт.вид == ВидОбʼєктаЗначення {
      обʼєкт_значення_аргумента = аргумент.обʼєкт.дані як ОбʼєктЗначення;
    } інакше якщо аргумент.обʼєкт.вид == ВидОбʼєктаНезавантаженеЗначення {
      змінна обʼєкт_незавантаженого_значення_для_аргумента = аргумент.обʼєкт.дані як ОбʼєктНезавантаженогоЗначення;
      обʼєкт_значення_аргумента.тип = обʼєкт_незавантаженого_значення_для_аргумента.тип;
      обʼєкт_значення_аргумента.пм_значення = ПМ::вказівка_прочитати(контекст.кк_дії.поточний_крок.пм_крок, обʼєкт_незавантаженого_значення_для_аргумента.тип.пм_тип, обʼєкт_незавантаженого_значення_для_аргумента.пм_значення);
    } інакше якщо аргумент.обʼєкт.вид == ВидОбʼєктаДія {
      змінна дані_дії = аргумент.обʼєкт.дані як адреса<ОбʼєктДії>;
      обʼєкт_значення_аргумента = ОбʼєктЗначення {
        дані_дії.тип,
        дані_дії.пм_інструкція як адреса<ПМ::Значення>
      };
    } інакше {
      вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
    }

    якщо обʼєкт_значення_аргумента.тип != обʼєкт_значення.тип {
      якщо обʼєкт_значення_аргумента.тип.вид == ВидОбʼєктаТипуАдреса {
        якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуАдреса {
        } інакше якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуПамʼять {
        } інакше якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуДія {
        } інакше {
          вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
        }
      } інакше якщо обʼєкт_значення_аргумента.тип.вид == ВидОбʼєктаТипуПамʼять {
        якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуАдреса {
        } інакше якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуПамʼять {
        } інакше якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуДія {
        } інакше {
          вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
        }
      } інакше якщо обʼєкт_значення_аргумента.тип.вид == ВидОбʼєктаТипуДія {
        якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуАдреса {
        } інакше якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуПамʼять {
        } інакше якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуДія {
        } інакше {
          вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
        }
      } інакше {
        вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
      }
    }

    змінна пм_значення = д(контекст.кк_дії.поточний_крок.пм_крок, обʼєкт_значення.пм_значення, обʼєкт_значення_аргумента.пм_значення);

    змінна обʼєкт_для_результату = Обʼєкт {
      ВидОбʼєктаЗначення,
      ОбʼєктЗначення { компілятор.тип_логічне, пм_значення }
    };

    вернути РезультатОбʼєкта { обʼєкт_для_результату, помилка = пусто };
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_більше(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_п64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_д32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_д64, обʼєкт_значення, аргумент);
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_менше(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_п64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_д32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_д64, обʼєкт_значення, аргумент);
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_більше_рівно(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_рівно_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_рівно_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_рівно_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_рівно_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_рівно_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_рівно_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_рівно_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_рівно_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_рівно_п64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_рівно_д32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_більше_рівно_д64, обʼєкт_значення, аргумент);
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_менше_рівно(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_рівно_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_рівно_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_рівно_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_рівно_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_рівно_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_рівно_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_рівно_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_рівно_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_рівно_п64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_рівно_д32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_менше_рівно_д64, обʼєкт_значення, аргумент);
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_рівно(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_рівно_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_рівно_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_рівно_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_рівно_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_рівно_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_рівно_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_рівно_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_рівно_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_рівно_п64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_рівно_д32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_рівно_д64, обʼєкт_значення, аргумент);
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_не_рівно(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_не_рівно_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_не_рівно_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_не_рівно_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_не_рівно_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_не_рівно_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_не_рівно_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_не_рівно_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_не_рівно_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_не_рівно_п64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_не_рівно_д32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
      вернути обʼєкт_значення_порівняльна_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_не_рівно_д64, обʼєкт_значення, аргумент);
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_зсунути_вліво(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вліво_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вліво_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вліво_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вліво_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вліво_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вліво_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вліво_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вліво_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вліво_п64, обʼєкт_значення, аргумент);
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_зсунути_вправо(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вправо_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вправо_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вправо_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вправо_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вправо_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вправо_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вправо_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вправо_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_зсунути_вправо_п64, обʼєкт_значення, аргумент);
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_ді(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_і_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_і_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_і_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_і_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_і_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_і_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_і_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_і_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_і_п64, обʼєкт_значення, аргумент);
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_дабо(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_або_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_або_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_або_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_або_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_або_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_або_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_або_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_або_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_або_п64, обʼєкт_значення, аргумент);
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_вабо(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_виключне_або_ц8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_виключне_або_ц16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_виключне_або_ц32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_виключне_або_ц64, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_виключне_або_логічне, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_виключне_або_п8, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_виключне_або_п16, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_виключне_або_п32, обʼєкт_значення, аргумент);
    } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
      вернути обʼєкт_значення_арифметична_операція(компілятор, контекст, місцезнаходження, ПМ::вказівка_двійкове_виключне_або_п64, обʼєкт_значення, аргумент);
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_як(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, аргумент: Аргумент): РезультатОбʼєкта {
//    якщо аргумент.обʼєкт.вид != ВидОбʼєктаТип {
//      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
//      вернути результат_помилка(помилка_компіляції);
//    }
//    ціль новий_тип = аргумент.обʼєкт.дані як адреса<ОбʼєктТипу>;
//    якщо новий_тип == обʼєкт_значення.тип {
//      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
//    }
//    якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
//      якщо новий_тип.вид == ВидТипуАдреса {
//        обʼєкт_значення.тип = новий_тип;
//        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
//      }
//      якщо новий_тип.вид == ВидТипуПамʼять {
//        обʼєкт_значення.тип = новий_тип;
//        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
//      }
//      якщо новий_тип.вид == ВидТипуДія {
//        // потім: перевірити чи це тип невідомої адреси
//        обʼєкт_значення.тип = новий_тип;
//        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
//      }
//    }
//    якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
//      якщо новий_тип.вид == ВидТипуАдреса {
//        обʼєкт_значення.тип = новий_тип;
//        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
//      }
//      якщо новий_тип.вид == ВидТипуПамʼять {
//        обʼєкт_значення.тип = новий_тип;
//        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
//      }
//    }
//    якщо обʼєкт_значення.тип.вид == ВидТипуДія {
//      // потім: перевірити тут тоже!!!
//      якщо новий_тип.вид == ВидТипуАдреса {
//        обʼєкт_значення.тип = новий_тип;
//        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
//      }
//    }
//    якщо обʼєкт_значення.тип.вид == ВидТипуВаріація {
//      змінна знайдений_тип_варіації: адреса<ОбʼєктТипу> = пусто;
//      змінна пх: позитивне = 0;
//      поки пх < обʼєкт_значення.тип.типи_варіації.розмір {
//        якщо перевірити_тип(новий_тип, обʼєкт_значення.тип.типи_варіації.дані[пх]) {
//          знайдений_тип_варіації = обʼєкт_значення.тип.типи_варіації.дані[пх];
//        }
//        пх = пх + 1;
//      }
//      якщо знайдений_тип_варіації == пусто {
//        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
//        вернути результат_помилка(помилка_компіляції);
//      }
//      обʼєкт_значення.тип = знайдений_тип_варіації;
//      обʼєкт_значення.llvm_value = LLVM::bitcast(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, знайдений_тип_варіації.llvm_type);
//      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
//    }
//    якщо обʼєкт_значення.тип.вид == ВидТипуПерелік {
//      змінна пе: позитивне = 0;
//      поки пе < обʼєкт_значення.тип.елементи_переліку.розмір {
//        якщо обʼєкт_значення.тип.елементи_переліку.дані[пе] == новий_тип {
//          обʼєкт_значення.тип = новий_тип;
//          обʼєкт_значення.llvm_value = LLVM::bitcast(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
//          вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
//        }
//        пе += 1;
//      }
//      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
//      вернути результат_помилка(помилка_компіляції);
//    }
//    якщо обʼєкт_значення.тип.вид == ВидТипуЕлементПереліку {
//      якщо обʼєкт_значення.тип.обʼєкт_типу_переліку_елемента_переліку == новий_тип {
//        обʼєкт_значення.тип = новий_тип;
//        обʼєкт_значення.llvm_value = LLVM::bitcast(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
//        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
//      }
//      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
//      вернути результат_помилка(помилка_компіляції);
//    }
//    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
//    вернути результат_помилка(помилка_компіляції);
    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_отримати_властивість(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, назва: Назва, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєкта {
    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_отримати_властивість_секції(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, назва: Назва, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєкта {
//    якщо назва == К.БН.вміст {
//      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
//        ціль тип = обʼєкт_значення.тип.тип_адреси;
//        ціль gep_positions_llvm_values = виділити<адреса<LLVM::Value>>(1);
//        gep_positions_llvm_values[0] = LLVM::const_int32(К.L, 0);
//        ціль llvm_value_gep = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, тип.llvm_type, обʼєкт_значення.llvm_value, 1, gep_positions_llvm_values);
//        ціль обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення;
//        обʼєкт_незавантаженого_значення.тип = тип;
//        обʼєкт_незавантаженого_значення.llvm_value = llvm_value_gep;
//        обʼєкт_незавантаженого_значення.змінний = позитивне(так);
//        вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, дані = обʼєкт_незавантаженого_значення }, помилка = пусто };
//      }
//    }
//    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість_секції");
//    вернути результат_помилка(помилка_компіляції);
    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_отримати_за_позицією(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, позиція: Аргумент, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєкта {
//    якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
//      ціль тип = обʼєкт_значення.тип.тип_памʼяті;
//      ціль результат_отримання_позиції_як_значення = отримати_як_значення(К, інформація_середовища, місцезнаходження, позиція.обʼєкт, компілятор.тип_ц32);
//      якщо результат_отримання_позиції_як_значення.помилка != пусто {
//        вернути результат_помилка(результат_отримання_позиції_як_значення.помилка);
//      }
//      ціль обʼєкт_значення_позиції = результат_отримання_позиції_як_значення.обʼєкт_значення;
//      ціль gep_positions_llvm_values = виділити<адреса<LLVM::Value>>(1);
//      gep_positions_llvm_values[0] = обʼєкт_значення_позиції.llvm_value;
//      ціль llvm_value_gep = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, тип.llvm_type, обʼєкт_значення.llvm_value, 1, gep_positions_llvm_values);
//      ціль обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення;
//      обʼєкт_незавантаженого_значення.тип = тип;
//      обʼєкт_незавантаженого_значення.llvm_value = llvm_value_gep;
//      обʼєкт_незавантаженого_значення.змінний = позитивне(так);
//      вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, дані = обʼєкт_незавантаженого_значення }, помилка = пусто };
//    }
//    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_за_позицією");
//    вернути результат_помилка(помилка_компіляції);
    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_виконати(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, кількість_аргументів: позитивне, аргументи: памʼять<Аргумент>): РезультатОбʼєкта {
    якщо обʼєкт_значення.тип.вид == ВидОбʼєктаТипуДія {
      змінна дані_типу_дії = обʼєкт_значення.тип.дані як ДаніОбʼєктаТипуДія;

      якщо кількість_аргументів != дані_типу_дії.параметри.розмір {
        вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Недостатньо аргументів");
      }

      змінна параметри = дані_типу_дії.параметри;
      змінна тип_результату = дані_типу_дії.тип_результату;
      змінна пм_тип_інструкції = дані_типу_дії.пм_тип_інструкції;
      змінна пм_значення = обʼєкт_значення.пм_значення;

      ціль пм_аргументи = виділити_памʼять<адреса<ПМ::Значення>>(компілятор, кількість_аргументів);

      змінна п: позитивне = 0;
      поки п < кількість_аргументів {
        змінна параметр = параметри.дані[п];

        змінна результат_аргумента_як_значення = отримати_як_значення(компілятор, контекст, аргументи[п].місцезнаходження, аргументи[п].обʼєкт, параметр.тип);
        якщо результат_аргумента_як_значення.помилка != пусто {
          вернути РезультатОбʼєкта { ..., помилка = результат_аргумента_як_значення.помилка };
        }

        змінна обʼєкт_значення_аргумента = результат_аргумента_як_значення.обʼєкт_значення;

        якщо перевірити_тип_на_запис_і_конвертувати_якщо_треба(компілятор, параметр.тип, обʼєкт_значення_аргумента::адреса) == ні {
          вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, аргументи[п].місцезнаходження, "Неочікуваний тип аргумента");
        }

        пм_аргументи[п] = обʼєкт_значення_аргумента.пм_значення;

        п += 1;
      }

      змінна пм_значення_виконання = ПМ::виконати_дію(
        контекст.кк_дії.поточний_крок.пм_крок,
        пм_тип_інструкції як адреса<ПМ::Тип>,
        пм_значення,
        параметри.розмір,
        пм_аргументи
      );

      звільнити_памʼять(компілятор, пм_аргументи);

      змінна обʼєкт_значення_виконання: ОбʼєктЗначення;
      обʼєкт_значення_виконання.тип = тип_результату;
      обʼєкт_значення_виконання.пм_значення = пм_значення_виконання;

      вернути РезультатОбʼєкта { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_виконання }, помилка = пусто };
    }

    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати виконання дії");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_виконати_шаблон(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, кількість_аргументів: позитивне, аргументи: памʼять<Аргумент>): РезультатОбʼєкта {
    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_змінити_властивість(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, назва: Назва, аргумент: Аргумент): РезультатОбʼєкта {
    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_змінити_в_секції(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, назва: Назва, аргумент: Аргумент): РезультатОбʼєкта {
//    якщо назва == К.БН.вміст {
//      якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
//        ціль тип = обʼєкт_значення.тип.тип_адреси;
//        ціль gep_positions_llvm_values = виділити<адреса<LLVM::Value>>(1);
//        gep_positions_llvm_values[0] = LLVM::const_int32(К.L, 0);
//        ціль llvm_value_gep = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, тип.llvm_type, обʼєкт_значення.llvm_value, 1, gep_positions_llvm_values);
//        ціль результат_аргумента_як_значення = отримати_як_значення(К, інформація_середовища, аргумент.місцезнаходження, аргумент.обʼєкт, тип);
//        якщо результат_аргумента_як_значення.помилка != пусто {
//          вернути результат_помилка(результат_аргумента_як_значення.помилка);
//        }
//        ціль обʼєкт_значення_аргумента = результат_аргумента_як_значення.обʼєкт_значення;
//        якщо тип.вид == ВидТипуВаріація {
//          змінна знайдений_тип_варіації: адреса<ОбʼєктТипу> = пусто;
//          змінна пх: позитивне = 0;
//          поки пх < тип.типи_варіації.розмір {
//            якщо перевірити_тип(обʼєкт_значення_аргумента.тип, тип.типи_варіації.дані[пх]) == так {
//              знайдений_тип_варіації = тип.типи_варіації.дані[пх];
//            }
//            пх = пх + 1;
//          }
//          якщо знайдений_тип_варіації == пусто {
//            ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Вітання помилка");
//            вернути результат_помилка(помилка_компіляції);
//          }
//        } інакше {
//          якщо перевірити_тип(обʼєкт_значення_аргумента.тип, тип) == ні {
//            ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Вітання помилка");
//            вернути результат_помилка(помилка_компіляції);
//          }
//        }
//        LLVM::store(К.L, інформація_середовища.llvm_block, обʼєкт_значення_аргумента.llvm_value, llvm_value_gep);
//        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_аргумента }, помилка = пусто };
//      }
//    }
//    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось змінити_в_секції");
//    вернути результат_помилка(помилка_компіляції);
    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_змінити_за_позицією(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення, позиція: Аргумент, аргумент: Аргумент): РезультатОбʼєкта {
//    якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
//      ціль тип = обʼєкт_значення.тип.тип_памʼяті;
//      ціль результат_отримання_позиції_як_значення = отримати_як_значення(К, інформація_середовища, місцезнаходження, позиція.обʼєкт, компілятор.тип_ц32);
//      якщо результат_отримання_позиції_як_значення.помилка != пусто {
//        вернути результат_помилка(результат_отримання_позиції_як_значення.помилка);
//      }
//      ціль обʼєкт_значення_позиції = результат_отримання_позиції_як_значення.обʼєкт_значення;
//      ціль gep_positions_llvm_values = виділити<адреса<LLVM::Value>>(1);
//      gep_positions_llvm_values[0] = обʼєкт_значення_позиції.llvm_value;
//      ціль llvm_value_gep = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, тип.llvm_type, обʼєкт_значення.llvm_value, 1, gep_positions_llvm_values);
//      ціль результат_аргумента_як_значення = отримати_як_значення(К, інформація_середовища, аргумент.місцезнаходження, аргумент.обʼєкт, тип);
//      якщо результат_аргумента_як_значення.помилка != пусто {
//        вернути результат_помилка(результат_аргумента_як_значення.помилка);
//      }
//      ціль обʼєкт_значення_аргумента = результат_аргумента_як_значення.обʼєкт_значення;
//      якщо тип.вид == ВидТипуВаріація {
//        змінна знайдений_тип_варіації: адреса<ОбʼєктТипу> = пусто;
//        змінна пх: позитивне = 0;
//        поки пх < тип.типи_варіації.розмір {
//          якщо перевірити_тип(обʼєкт_значення_аргумента.тип, тип.типи_варіації.дані[пх]) == так {
//            знайдений_тип_варіації = тип.типи_варіації.дані[пх];
//          }
//          пх = пх + 1;
//        }
//        якщо знайдений_тип_варіації == пусто {
//          ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Вітання помилка");
//          вернути результат_помилка(помилка_компіляції);
//        }
//      } інакше {
//        якщо перевірити_тип(обʼєкт_значення_аргумента.тип, тип) == ні {
//          ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Вітання помилка");
//          вернути результат_помилка(помилка_компіляції);
//        }
//      }
//      LLVM::store(К.L, інформація_середовища.llvm_block, обʼєкт_значення_аргумента.llvm_value, llvm_value_gep);
//      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_аргумента }, помилка = пусто };
//    }
//    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось змінити_за_позицією");
//    вернути результат_помилка(помилка_компіляції);
    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}

секція КЦ {
  зовнішня дія обʼєкт_значення_унарний_мінус(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт_значення: ОбʼєктЗначення): РезультатОбʼєкта {
//    якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
//      ціль обʼєкт_значення_ліво = ОбʼєктЗначення { компілятор.тип_ц8, LLVM::const_int8(К.L, 0) };
//      вернути обʼєкт_значення_відняти(обʼєкт_значення_компілятор, контекст, місцезнаходження, ліво, Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, місцезнаходження });
//    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
//      ціль обʼєкт_значення_ліво = ОбʼєктЗначення { компілятор.тип_ц16, LLVM::const_int16(К.L, 0) };
//      вернути обʼєкт_значення_відняти(обʼєкт_значення_компілятор, контекст, місцезнаходження, ліво, Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, місцезнаходження });
//    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
//      ціль обʼєкт_значення_ліво = ОбʼєктЗначення { компілятор.тип_ц32, LLVM::const_int32(К.L, 0) };
//      вернути обʼєкт_значення_відняти(обʼєкт_значення_компілятор, контекст, місцезнаходження, ліво, Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, місцезнаходження });
//    } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
//      ціль обʼєкт_значення_ліво = ОбʼєктЗначення { компілятор.тип_ц64, LLVM::const_int64(К.L, 0) };
//      вернути обʼєкт_значення_відняти(обʼєкт_значення_компілятор, контекст, місцезнаходження, ліво, Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, місцезнаходження });
//    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
//      ціль обʼєкт_значення_ліво = ОбʼєктЗначення { компілятор.тип_д32, LLVM::const_float(К.L, 0.0) };
//      вернути обʼєкт_значення_відняти(обʼєкт_значення_компілятор, контекст, місцезнаходження, ліво, Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, місцезнаходження });
//    } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
//      ціль обʼєкт_значення_ліво = ОбʼєктЗначення { компілятор.тип_д64, LLVM::const_double(К.L, 0.0) };
//      вернути обʼєкт_значення_відняти(обʼєкт_значення_компілятор, контекст, місцезнаходження, ліво, Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, місцезнаходження });
//    }
//    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось унарний_мінус");
//    вернути результат_помилка(помилка_компіляції);
    вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження,"Не вдалось скомпілювати");
  }
}