взяти визначення ./КЦ;

зовнішня дія __КЦ__прочитати_файл(виділяч: адреса<біб::Виділяч>, шлях: адреса<КЦ::Шлях>, вихід: адреса<КЦ::Байти>, вихід_успіху: адреса<логічне>);
зовнішня дія __КЦ__перевірити_чи_шлях_існує(виділяч: адреса<біб::Виділяч>, шлях: адреса<КЦ::Шлях>): логічне;
зовнішня дія __КЦ__отримати_директорію_шляху_до_файлу(виділяч: адреса<біб::Виділяч>, вхід: адреса<КЦ::Шлях>, вихід: адреса<КЦ::Шлях>): логічне;
зовнішня дія __КЦ__отримати_поточну_директорію_процесу(виділяч: адреса<біб::Виділяч>, вихід: адреса<КЦ::Шлях>): логічне;
зовнішня дія __КЦ__отримати_абсолютний_шлях(виділяч: адреса<біб::Виділяч>, вхід: адреса<КЦ::Шлях>, вихід: адреса<КЦ::Шлях>): логічне;

секція КЦ {
  зовнішня дія змішати_назву_шлях_для_реєстру(ключ: Назва, аргумент: невідома_адреса): позитивне {
    змінна змішане: позитивне = 5381;
    змінна п: позитивне = 0;

    поки п < ключ.значення.розмір {
      змішане = (змішане * 33) + позитивне(ключ.значення.дані[п]);
      п += 1;
    }

    вернути змішане;
  }

  дія створити_простий_тип(компілятор: адреса<Компілятор>, назва: Назва, пм_тип: адреса<ПМ::Тип>): адреса<ОбʼєктТипу> {
    змінна обʼєкт_типу = виділити_обʼєкт_типу(компілятор);
    обʼєкт_типу.вид = ВидОбʼєктаТипуПростий;
    обʼєкт_типу.пм_тип = пм_тип;
    обʼєкт_типу.дані = ДаніОбʼєктаТипуПростий {
      назва = назва
    };
    вернути обʼєкт_типу;
  }

  зовнішня дія створити_тип_адреси(компілятор: адреса<Компілятор>, тип_даних: адреса<ОбʼєктТипу>): адреса<ОбʼєктТипу> {
    змінна обʼєкт_типу = виділити_обʼєкт_типу(компілятор);
    обʼєкт_типу.вид = ВидОбʼєктаТипуАдреса;
    обʼєкт_типу.пм_тип = компілятор.тип_адреса.пм_тип;
    обʼєкт_типу.дані = ДаніОбʼєктаТипуАдреса {
      тип_даних = тип_даних
    };
    вернути обʼєкт_типу;
  }

  зовнішня дія створити_тип_памʼяті(компілятор: адреса<Компілятор>, тип_даних: адреса<ОбʼєктТипу>): адреса<ОбʼєктТипу> {
    змінна обʼєкт_типу = виділити_обʼєкт_типу(компілятор);
    обʼєкт_типу.вид = ВидОбʼєктаТипуПамʼять;
    обʼєкт_типу.пм_тип = компілятор.тип_памʼять.пм_тип;
    обʼєкт_типу.дані = ДаніОбʼєктаТипуПамʼять {
      тип_даних = тип_даних
    };
    вернути обʼєкт_типу;
  }

  зовнішня дія створити_тип_дії(компілятор: адреса<Компілятор>, параметри: Параметри, тип_результату: адреса<ОбʼєктТипу>): адреса<ОбʼєктТипу> {
    змінна обʼєкт_типу = виділити_обʼєкт_типу(компілятор);
    обʼєкт_типу.вид = ВидОбʼєктаТипуДія;
    обʼєкт_типу.пм_тип = компілятор.тип_адреса.пм_тип;

    змінна пм_параметри = ПМ::Параметри { 0, пусто, 0 };
    змінна п: позитивне = 0;
    поки п < параметри.розмір {
      ПМ::покласти_параметр(компілятор.пм_модуль, пм_параметри::адреса, ПМ::Параметр { параметри.дані[п].тип.пм_тип });
      п += 1;
    }

    змінна пм_тип_інструкції = ПМ::створити_тип_інструкції(
      компілятор.пм_модуль,
      пм_параметри,
      тип_результату.пм_тип
    );

    обʼєкт_типу.дані = ДаніОбʼєктаТипуДія {
      параметри = параметри,
      тип_результату = тип_результату,
      пм_тип_інструкції = пм_тип_інструкції
    };
    вернути обʼєкт_типу;
  }

  зовнішня дія створити_варіативний_тип(компілятор: адреса<Компілятор>, кількість_типів: позитивне, типи: памʼять<адреса<ОбʼєктТипу>>): адреса<ОбʼєктТипу> {
    змінна обʼєкт_типу = виділити_обʼєкт_типу(компілятор);
    обʼєкт_типу.вид = ВидОбʼєктаТипуВаріація;

    змінна найбільший_тип = типи[0];
    змінна розмір_найбільшого_типу: позитивне = ПМ::отримати_розмір_типу_для_виділення(компілятор.пм_модуль, типи[0].пм_тип);

    змінна п: позитивне = 1;

    поки п < кількість_типів {
      змінна тип = типи[п];
      змінна розмір = ПМ::отримати_розмір_типу_для_виділення(компілятор.пм_модуль, тип.пм_тип);

      якщо розмір > розмір_найбільшого_типу {
        найбільший_тип = тип;
        розмір_найбільшого_типу = розмір;
      }

      п += 1;
    }

    обʼєкт_типу.пм_тип = найбільший_тип.пм_тип;

    обʼєкт_типу.дані = ДаніОбʼєктаТипуВаріація {
      кількість_типів = кількість_типів,
      типи = типи,
      найбільший_тип = найбільший_тип
    };
    вернути обʼєкт_типу;
  }

  зовнішня дія створити_тип_т8(компілятор: адреса<Компілятор>): адреса<ОбʼєктТипу> {
    змінна параметри = Параметри { 2, виділити_памʼять<Параметр>(компілятор, 2), 2 };

    параметри.дані[0] = Параметр {
      назва = назва_зовнішня("розмір"),
      тип = компілятор.тип_н64,
      Місцезнаходження { пусто, 0 },
      Місцезнаходження { пусто, 0 }
    };
    параметри.дані[1] = Параметр {
      назва = назва_зовнішня("дані"),
      тип = створити_тип_памʼяті(компілятор, компілятор.тип_н8),
      Місцезнаходження { пусто, 0 },
      Місцезнаходження { пусто, 0 }
    };

    змінна обʼєкт_типу_структура = виділити_обʼєкт_типу(компілятор);
    обʼєкт_типу_структура.вид = ВидОбʼєктаТипуСтруктура;
    обʼєкт_типу_структура.дані = ДаніОбʼєктаТипуСтруктура {
      назва = назва_зовнішня("т8"),
      параметри = параметри,
      повна_назва = назва_зовнішня("т8"),
      готові_аргументи_шаблону = ГотовіАргументиШаблону { 0, пусто },
      обʼєкт_секції = пусто
    };

    змінна пм_параметри = ПМ::Параметри { 0, пусто, 0 };
    змінна п: позитивне = 0;
    поки п < параметри.розмір {
      ПМ::покласти_параметр(компілятор.пм_модуль, пм_параметри::адреса, ПМ::Параметр { параметри.дані[п].тип.пм_тип });
      п += 1;
    }

    обʼєкт_типу_структура.пм_тип = ПМ::створити_структуру(
      компілятор.пм_модуль,
      "т8",
      пм_параметри
    );

    вернути обʼєкт_типу_структура;
  }

  зовнішня дія створити_тип_т32(компілятор: адреса<Компілятор>): адреса<ОбʼєктТипу> {
    змінна параметри = Параметри { 2, виділити_памʼять<Параметр>(компілятор, 2), 2 };

    параметри.дані[0] = Параметр {
      назва = назва_зовнішня("розмір"),
      тип = компілятор.тип_н64,
      Місцезнаходження { пусто, 0 },
      Місцезнаходження { пусто, 0 }
    };
    параметри.дані[1] = Параметр {
      назва = назва_зовнішня("дані"),
      тип = створити_тип_памʼяті(компілятор, компілятор.тип_н8),
      Місцезнаходження { пусто, 0 },
      Місцезнаходження { пусто, 0 }
    };

    змінна обʼєкт_типу_структура = виділити_обʼєкт_типу(компілятор);
    обʼєкт_типу_структура.вид = ВидОбʼєктаТипуСтруктура;
    обʼєкт_типу_структура.дані = ДаніОбʼєктаТипуСтруктура {
      назва = назва_зовнішня("т32"),
      параметри = параметри,
      повна_назва = назва_зовнішня("т32"),
      готові_аргументи_шаблону = ГотовіАргументиШаблону { 0, пусто },
      обʼєкт_секції = пусто
    };

    змінна пм_параметри = ПМ::Параметри { 0, пусто, 0 };
    змінна п: позитивне = 0;
    поки п < параметри.розмір {
      ПМ::покласти_параметр(компілятор.пм_модуль, пм_параметри::адреса, ПМ::Параметр { параметри.дані[п].тип.пм_тип });
      п += 1;
    }

    обʼєкт_типу_структура.пм_тип = ПМ::створити_структуру(
      компілятор.пм_модуль,
      "т32",
      пм_параметри
    );

    вернути обʼєкт_типу_структура;
  }

  зовнішня дія створити_тип_ю8(компілятор: адреса<Компілятор>): адреса<ОбʼєктТипу> {
    змінна параметри = Параметри { 2, виділити_памʼять<Параметр>(компілятор, 2), 2 };

    параметри.дані[0] = Параметр {
      назва = назва_зовнішня("розмір"),
      тип = компілятор.тип_н64,
      Місцезнаходження { пусто, 0 },
      Місцезнаходження { пусто, 0 }
    };
    параметри.дані[1] = Параметр {
      назва = назва_зовнішня("дані"),
      тип = створити_тип_памʼяті(компілятор, компілятор.тип_н8),
      Місцезнаходження { пусто, 0 },
      Місцезнаходження { пусто, 0 }
    };

    змінна обʼєкт_типу_структура = виділити_обʼєкт_типу(компілятор);
    обʼєкт_типу_структура.вид = ВидОбʼєктаТипуСтруктура;
    обʼєкт_типу_структура.дані = ДаніОбʼєктаТипуСтруктура {
      назва = назва_зовнішня("ю8"),
      параметри = параметри,
      повна_назва = назва_зовнішня("ю8"),
      готові_аргументи_шаблону = ГотовіАргументиШаблону { 0, пусто },
      обʼєкт_секції = пусто
    };

    змінна пм_параметри = ПМ::Параметри { 0, пусто, 0 };
    змінна п: позитивне = 0;
    поки п < параметри.розмір {
      ПМ::покласти_параметр(компілятор.пм_модуль, пм_параметри::адреса, ПМ::Параметр { параметри.дані[п].тип.пм_тип });
      п += 1;
    }

    обʼєкт_типу_структура.пм_тип = ПМ::створити_структуру(
      компілятор.пм_модуль,
      "ю8",
      пм_параметри
    );

    вернути обʼєкт_типу_структура;
  }

  зовнішня дія створити_тип_ю32(компілятор: адреса<Компілятор>): адреса<ОбʼєктТипу> {
    змінна параметри = Параметри { 2, виділити_памʼять<Параметр>(компілятор, 2), 2 };

    параметри.дані[0] = Параметр {
      назва = назва_зовнішня("розмір"),
      тип = компілятор.тип_н64,
      Місцезнаходження { пусто, 0 },
      Місцезнаходження { пусто, 0 }
    };
    параметри.дані[1] = Параметр {
      назва = назва_зовнішня("дані"),
      тип = створити_тип_памʼяті(компілятор, компілятор.тип_н32),
      Місцезнаходження { пусто, 0 },
      Місцезнаходження { пусто, 0 }
    };

    змінна обʼєкт_типу_структура = виділити_обʼєкт_типу(компілятор);
    обʼєкт_типу_структура.вид = ВидОбʼєктаТипуСтруктура;
    обʼєкт_типу_структура.дані = ДаніОбʼєктаТипуСтруктура {
      назва = назва_зовнішня("ю32"),
      параметри = параметри,
      повна_назва = назва_зовнішня("ю32"),
      готові_аргументи_шаблону = ГотовіАргументиШаблону { 0, пусто },
      обʼєкт_секції = пусто
    };

    змінна пм_параметри = ПМ::Параметри { 0, пусто, 0 };
    змінна п: позитивне = 0;
    поки п < параметри.розмір {
      ПМ::покласти_параметр(компілятор.пм_модуль, пм_параметри::адреса, ПМ::Параметр { параметри.дані[п].тип.пм_тип });
      п += 1;
    }

    обʼєкт_типу_структура.пм_тип = ПМ::створити_структуру(
      компілятор.пм_модуль,
      "ю32",
      пм_параметри
    );

    вернути обʼєкт_типу_структура;
  }

  зовнішня дія створити_компілятор(виділяч: адреса<біб::Виділяч>, пм_модуль: адреса<ПМ::Модуль>): адреса<Компілятор> {
    змінна компілятор = біб::виділити<Компілятор>(виділяч);

    компілятор.виділяч = виділяч;
    компілятор.пм_модуль = пм_модуль;

    компілятор.кореневий_шлях = Шлях { 0, пусто };
    компілятор.взяті_файли = створити_взяті_файли(компілятор);

    компілятор.перше_середовище = пусто;
    компілятор.останнє_середовище = пусто;
    компілятор.перший_обʼєкт_дії = пусто;
    компілятор.останній_обʼєкт_дії = пусто;
    компілятор.перший_обʼєкт_типу = пусто;
    компілятор.останній_обʼєкт_типу = пусто;
    компілятор.перший_обʼєкт_секції = пусто;
    компілятор.останній_обʼєкт_секції = пусто;
    компілятор.перший_обʼєкт_шаблону = пусто;
    компілятор.останній_обʼєкт_шаблону = пусто;
    компілятор.перший_розібраний_текст = пусто;
    компілятор.останній_розібраний_текст = пусто;
    компілятор.перший_текст_коду = пусто;
    компілятор.останній_текст_коду = пусто;

    компілятор.глобальне_середовище = створити_середовище(компілятор, пусто);

    компілятор.тип_ніщо = створити_простий_тип(компілятор, назва_зовнішня("ніщо"), ПМ::отримати_тип_ніщо(компілятор.пм_модуль));
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("ніщо"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_ніщо });

    компілятор.тип_адреса = виділити_обʼєкт_типу(компілятор);
    компілятор.тип_адреса.вид = ВидОбʼєктаТипуАдреса;
    компілятор.тип_адреса.пм_тип = ПМ::отримати_тип_адреса(компілятор.пм_модуль);
    компілятор.тип_адреса.дані = ДаніОбʼєктаТипуАдреса {
      тип_даних = компілятор.тип_ніщо
    };
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("адреса"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_адреса });
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("невідома_адреса"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_адреса });

    компілятор.тип_памʼять = виділити_обʼєкт_типу(компілятор);
    компілятор.тип_памʼять.вид = ВидОбʼєктаТипуПамʼять;
    компілятор.тип_памʼять.пм_тип = ПМ::отримати_тип_адреса(компілятор.пм_модуль);
    компілятор.тип_памʼять.дані = ДаніОбʼєктаТипуПамʼять {
      тип_даних = компілятор.тип_ніщо
    };
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("памʼять"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_памʼять });
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("невідома_памʼять"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_памʼять });

    компілятор.тип_логічне = створити_простий_тип(компілятор, назва_зовнішня("логічне"), ПМ::отримати_тип_б1(компілятор.пм_модуль));
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("логічне"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_логічне });

    компілятор.тип_ц8 = створити_простий_тип(компілятор, назва_зовнішня("ц8"), ПМ::отримати_тип_б8(компілятор.пм_модуль));
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("ц8"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_ц8 });

    компілятор.тип_ц16 = створити_простий_тип(компілятор, назва_зовнішня("ц16"), ПМ::отримати_тип_б16(компілятор.пм_модуль));
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("ц16"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_ц16 });

    компілятор.тип_ц32 = створити_простий_тип(компілятор, назва_зовнішня("ц32"), ПМ::отримати_тип_б32(компілятор.пм_модуль));
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("ц32"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_ц32 });

    компілятор.тип_ц64 = створити_простий_тип(компілятор, назва_зовнішня("ц64"), ПМ::отримати_тип_б64(компілятор.пм_модуль));
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("ц64"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_ц64 });

    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("ціле"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_ц64 });

    компілятор.тип_н8 = створити_простий_тип(компілятор, назва_зовнішня("н8"), ПМ::отримати_тип_б8(компілятор.пм_модуль));
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("н8"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_н8 });
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("п8"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_н8 });

    компілятор.тип_н16 = створити_простий_тип(компілятор, назва_зовнішня("н16"), ПМ::отримати_тип_б16(компілятор.пм_модуль));
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("н16"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_н16 });
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("п16"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_н16 });

    компілятор.тип_н32 = створити_простий_тип(компілятор, назва_зовнішня("н32"), ПМ::отримати_тип_б32(компілятор.пм_модуль));
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("н32"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_н32 });
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("п32"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_н32 });

    компілятор.тип_н64 = створити_простий_тип(компілятор, назва_зовнішня("н64"), ПМ::отримати_тип_б64(компілятор.пм_модуль));
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("н64"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_н64 });
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("п64"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_н64 });

    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("натуральне"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_н64 });
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("позитивне"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_н64 });

    компілятор.тип_р32 = створити_простий_тип(компілятор, назва_зовнішня("р32"), ПМ::отримати_тип_р32(компілятор.пм_модуль));
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("р32"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_р32 });
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("д32"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_р32 });

    компілятор.тип_р64 = створити_простий_тип(компілятор, назва_зовнішня("р64"), ПМ::отримати_тип_р64(компілятор.пм_модуль));
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("р64"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_р64 });
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("д64"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_р64 });

    компілятор.обʼєкт_значення_так = ОбʼєктЗначення { компілятор.тип_логічне, ПМ::створити_логічне(компілятор.пм_модуль, так) };
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("так"), Обʼєкт { ВидОбʼєктаЗначення, компілятор.обʼєкт_значення_так });

    компілятор.обʼєкт_значення_ні = ОбʼєктЗначення { компілятор.тип_логічне, ПМ::створити_логічне(компілятор.пм_модуль, ні) };
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("ні"), Обʼєкт { ВидОбʼєктаЗначення, компілятор.обʼєкт_значення_ні });

    компілятор.обʼєкт_значення_пусто = ОбʼєктЗначення { компілятор.тип_адреса, ПМ::отримати_значення_пусто(компілятор.пм_модуль) };
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("пусто"), Обʼєкт { ВидОбʼєктаЗначення, компілятор.обʼєкт_значення_пусто });

    компілятор.тип_т8 = створити_тип_т8(компілятор);
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("т8"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_т8 });

    компілятор.тип_т32 = створити_тип_т32(компілятор);
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("т32"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_т32 });

    компілятор.тип_ю8 = створити_тип_ю8(компілятор);
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("ю8"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_ю8 });

    компілятор.тип_ю32 = створити_тип_ю32(компілятор);
    змінити_в_середовищі(компілятор.глобальне_середовище, назва_зовнішня("ю32"), Обʼєкт { ВидОбʼєктаТип, компілятор.тип_ю32 });

    вернути компілятор;
  }

  дія знищити_назву(компілятор: адреса<Компілятор>, назва: Назва) {
    якщо назва.вид == ВидНазвиКопія {
      звільнити_памʼять(компілятор, назва.значення.дані);
    }
  }

  дія знищити_параметр(компілятор: адреса<Компілятор>, параметр: Параметр) {
    знищити_назву(компілятор, параметр.назва);
  }

  дія знищити_параметри(компілятор: адреса<Компілятор>, параметри: Параметри) {
    змінна п: позитивне = 0;

    поки п < параметри.розмір {
      знищити_параметр(компілятор, параметри.дані[п]);

      п += 1;
    }

    звільнити_памʼять(компілятор, параметри.дані);
  }

  дія знищити_крок(компілятор: адреса<Компілятор>, крок: Крок) {
    знищити_назву(компілятор, крок.назва);
  }

  дія знищити_кроки(компілятор: адреса<Компілятор>, кроки: Кроки) {
    змінна п: позитивне = 0;

    поки п < кроки.розмір {
      знищити_крок(компілятор, кроки.дані[п]);

      п += 1;
    }

    звільнити_памʼять(компілятор, кроки.дані);
  }

  дія знищити_стрибок(компілятор: адреса<Компілятор>, стрибок: Стрибок) {
    знищити_назву(компілятор, стрибок.назва);
  }

  дія знищити_стрибки(компілятор: адреса<Компілятор>, стрибки: Стрибки) {
    змінна п: позитивне = 0;

    поки п < стрибки.розмір {
      знищити_стрибок(компілятор, стрибки.дані[п]);

      п += 1;
    }

    звільнити_памʼять(компілятор, стрибки.дані);
  }

  дія знищити_готовий_аргумент_шаблону(компілятор: адреса<Компілятор>, готовий_аргумент_шаблону: ГотовийАргументШаблону) {
  }

  дія знищити_готові_аргументи_шаблону(компілятор: адреса<Компілятор>, готові_аргументи_шаблону: ГотовіАргументиШаблону) {
    змінна п: позитивне = 0;

    поки п < готові_аргументи_шаблону.розмір {
      знищити_готовий_аргумент_шаблону(компілятор, готові_аргументи_шаблону.дані[п]);

      п += 1;
    }

    звільнити_памʼять(компілятор, готові_аргументи_шаблону.дані);
  }

  дія знищити_обʼєкт_дії(компілятор: адреса<Компілятор>, обʼєкт_дії: адреса<ОбʼєктДії>) {
    знищити_назву(компілятор, обʼєкт_дії.назва);
    знищити_назву(компілятор, обʼєкт_дії.повна_назва);
    знищити_параметри(компілятор, обʼєкт_дії.параметри);
    знищити_кроки(компілятор, обʼєкт_дії.кроки);
    знищити_стрибки(компілятор, обʼєкт_дії.стрибки);

    звільнити(компілятор, обʼєкт_дії);
  }

  дія знищити_обʼєкт_секції(компілятор: адреса<Компілятор>, обʼєкт_секції: адреса<ОбʼєктСекції>) {
    знищити_назву(компілятор, обʼєкт_секції.назва);

    звільнити(компілятор, обʼєкт_секції);
  }

  дія знищити_обʼєкт_типу(компілятор: адреса<Компілятор>, обʼєкт_типу: адреса<ОбʼєктТипу>) {
    якщо обʼєкт_типу.вид == ВидОбʼєктаТипуСтруктура {
      змінна дані = обʼєкт_типу.дані як ДаніОбʼєктаТипуСтруктура;

      знищити_назву(компілятор, дані.назва);
      знищити_параметри(компілятор, дані.параметри);
      знищити_назву(компілятор, дані.повна_назва);
      знищити_готові_аргументи_шаблону(компілятор, дані.готові_аргументи_шаблону);
    } інакше якщо обʼєкт_типу.вид == ВидОбʼєктаТипуДія {
      змінна дані = обʼєкт_типу.дані як ДаніОбʼєктаТипуДія;

      знищити_параметри(компілятор, дані.параметри);
    } інакше якщо обʼєкт_типу.вид == ВидОбʼєктаТипуВаріація {
      змінна дані = обʼєкт_типу.дані як ДаніОбʼєктаТипуВаріація;

      звільнити_памʼять(компілятор, дані.типи);
    }

    звільнити(компілятор, обʼєкт_типу);
  }

  дія знищити_обʼєкт_шаблону(компілятор: адреса<Компілятор>, обʼєкт_шаблону: адреса<ОбʼєктШаблону>) {
    звільнити(компілятор, обʼєкт_шаблону);
  }

  зовнішня дія знищити_компілятор(компілятор: адреса<Компілятор>) {
    знищити_шлях(компілятор, компілятор.кореневий_шлях);

    знищити_взяті_файли(компілятор.взяті_файли);

    змінна поточне_середовище = компілятор.перше_середовище;
    поки поточне_середовище != пусто {
      змінна наступне = поточне_середовище.наступне;
      знищити_середовище(поточне_середовище);
      поточне_середовище = наступне;
    }

    змінна поточний_обʼєкт_дії = компілятор.перший_обʼєкт_дії;
    поки поточний_обʼєкт_дії != пусто {
      змінна наступний = поточний_обʼєкт_дії.наступний;
      знищити_обʼєкт_дії(компілятор, поточний_обʼєкт_дії);
      поточний_обʼєкт_дії = наступний;
    }

    змінна поточний_обʼєкт_секції = компілятор.перший_обʼєкт_секції;
    поки поточний_обʼєкт_секції != пусто {
      змінна наступний = поточний_обʼєкт_секції.наступний;
      знищити_обʼєкт_секції(компілятор, поточний_обʼєкт_секції);
      поточний_обʼєкт_секції = наступний;
    }

    змінна поточний_обʼєкт_типу = компілятор.перший_обʼєкт_типу;
    поки поточний_обʼєкт_типу != пусто {
      змінна наступний = поточний_обʼєкт_типу.наступний;
      знищити_обʼєкт_типу(компілятор, поточний_обʼєкт_типу);
      поточний_обʼєкт_типу = наступний;
    }

    змінна поточний_обʼєкт_шаблону = компілятор.перший_обʼєкт_шаблону;
    поки поточний_обʼєкт_шаблону != пусто {
      змінна наступний = поточний_обʼєкт_шаблону.наступний;
      знищити_обʼєкт_шаблону(компілятор, поточний_обʼєкт_шаблону);
      поточний_обʼєкт_шаблону = наступний;
    }

    змінна поточний_розібраний_текст = компілятор.перший_розібраний_текст;
    поки поточний_розібраний_текст != пусто {
      змінна наступний = поточний_розібраний_текст.наступний;
      знищити_розібраний_текст(поточний_розібраний_текст);
      поточний_розібраний_текст = наступний;
    }

    змінна поточний_текст_коду = компілятор.перший_текст_коду;
    поки поточний_текст_коду != пусто {
      змінна наступний = поточний_текст_коду.наступний;
      знищити_текст_коду(поточний_текст_коду);
      поточний_текст_коду = наступний;
    }

    // потім: знищити всі реєстри, накопичувачі, обʼєкти і тд
    біб::звільнити(компілятор.виділяч, компілятор);
  }

  зовнішня дія перекодувати_ю8_в_т8_з_місцезнаходженнями(компілятор: адреса<Компілятор>, значення: ю8, вихід: адреса<т8>, вихід_місцезнаходжень: адреса<біб::МісцезнаходженняПерекодованого>): логічне {
    змінна позиція_помилки: позитивне = 0;

    вернути біб::перекодувати_ю8_в_т8(
      компілятор.виділяч,
      значення,
      так,
      ні,
      вихід,
      вихід_місцезнаходжень,
      позиція_помилки::адреса
    );
  }

  зовнішня дія отримати_т8_з_ю8(компілятор: адреса<Компілятор>, значення: ю8): т8 {
    змінна результат = т8 { 0, пусто };

    змінна позиція_помилки: позитивне = 0;

    якщо біб::перекодувати_ю8_в_т8(компілятор.виділяч, значення, так, ні, результат::адреса, пусто, позиція_помилки::адреса) == ні {
      // потім: обробити помилку
    }

    вернути результат;
  }

  зовнішня дія отримати_ю8_з_т8(компілятор: адреса<Компілятор>, значення: т8): ю8 {
    змінна результат = ю8 { 0, пусто };

    змінна позиція_помилки: позитивне = 0;

    якщо біб::перекодувати_т8_в_ю8(компілятор.виділяч, значення, ні, результат::адреса, пусто, позиція_помилки::адреса) == ні {
      // потім: обробити помилку
    }

    вернути результат;
  }

  зовнішня дія прочитати_файл(компілятор: адреса<Компілятор>, шлях: Шлях, вихід: адреса<Байти>): логічне {
    змінна успіх = ні;
    __КЦ__прочитати_файл(компілятор.виділяч, шлях::адреса, вихід, успіх::адреса);
    вернути успіх;
  }

  зовнішня дія скомпілювати_текст_коду(компілятор: адреса<Компілятор>, текст_коду: адреса<ТекстКоду>, вихід_помилки: адреса<адреса<Помилка>>): логічне {
    змінна розбирач = КЦ::розбирач::створити(компілятор.виділяч);

    змінна успіх_розбору = ні;

    змінна розібраний_текст = створити_розібраний_текст(компілятор);
    розібраний_текст.текст_коду = текст_коду;
    розібраний_текст.розбирач = розбирач;

    покласти_взятий_файл(компілятор.взяті_файли, текст_коду.шлях, розібраний_текст);

    змінна помилка_розбору_на_слова: КЦ::розбирач::ПомилкаРозборуНаСлова;
    змінна помилка_розбору_на_сполуки: КЦ::розбирач::ПомилкаРозборуНаСполуки;

    успіх_розбору = КЦ::розбирач::розібрати_на_слова(
      розбирач,
      т8 { текст_коду.значення.розмір, текст_коду.значення.дані },
      розібраний_текст.слова::адреса,
      помилка_розбору_на_слова::адреса
    );
    якщо успіх_розбору == ні {
      змінна позиція_в_тексті = помилка_розбору_на_слова.позиція.позиція_в_тексті;
      змінна рядок = помилка_розбору_на_слова.позиція.рядок;
      змінна стовпець = помилка_розбору_на_слова.позиція.стовпець;

      вихід_помилки::вміст = створити_помилку(
        компілятор,
        "Неочікуваний символ.",
        створити_місцезнаходження_помилки(компілятор, текст_коду, позиція_в_тексті, рядок, стовпець)
      );

      вернути ні;
    }

//    біб::надрукувати_ю8(ю8 { текст_коду.шлях.розмір, текст_коду.шлях.дані });
//    біб::надрукувати_ю8(ю8"--- слова ---");
//    КЦ::розбирач::надрукувати_слова(розбирач, текст_коду.значення, розібраний_текст.слова);
//    біб::надрукувати_ю8(ю8"--- кінець слів ---");

    успіх_розбору = КЦ::розбирач::розібрати_слова_на_сполуки(розбирач, розібраний_текст.слова, розібраний_текст.сполуки::адреса, помилка_розбору_на_сполуки::адреса);
    якщо успіх_розбору == ні {
      змінна позиція_в_тексті = розібраний_текст.слова.дані[помилка_розбору_на_сполуки.позиція_слова].позиція_початку.позиція_в_тексті;
      змінна рядок = розібраний_текст.слова.дані[помилка_розбору_на_сполуки.позиція_слова].позиція_початку.рядок;
      змінна стовпець = розібраний_текст.слова.дані[помилка_розбору_на_сполуки.позиція_слова].позиція_початку.стовпець;

      вихід_помилки::вміст = створити_помилку(
        компілятор,
        "Неочікуване слово.",
        створити_місцезнаходження_помилки(компілятор, текст_коду, позиція_в_тексті, рядок, стовпець)
      );

      вернути ні;
    }

//    біб::надрукувати_ю8(ю8 { текст_коду.шлях.розмір, текст_коду.шлях.дані });
//    біб::надрукувати_ю8(ю8"--- сполуки ---");
//    КЦ::розбирач::надрукувати_сполуки(розбирач, текст_коду.значення, розібраний_текст.слова, розібраний_текст.сполуки, 0);
//    біб::надрукувати_ю8(ю8"--- кінець сполук ---");

    змінна результат_компіляції_тіла = скомпілювати_тіло(
      компілятор,
      Контекст {
        розібраний_текст = розібраний_текст,
        середовище = компілятор.глобальне_середовище,
        кк_дії = пусто
      },
      розібраний_текст.сполуки,
      КЦ::розбирач::Місцезнаходження { 0, 0 }
    );

    якщо результат_компіляції_тіла.помилка != пусто {
      вихід_помилки::вміст = результат_компіляції_тіла.помилка;
      вернути ні;
    }

    // ...

    вернути так;
  }

  зовнішня дія взяти_файл_ю8(компілятор: адреса<Компілятор>, шлях: Шлях, вихід_помилки: адреса<адреса<Помилка>>): логічне {
    змінна взятий_файл: адреса<РозібранийТекст> = пусто;
    якщо знайти_взятий_файл(компілятор.взяті_файли, шлях, взятий_файл::адреса) {
      вернути так;
    }

    змінна код = Байти { 0, пусто };

    якщо прочитати_файл(компілятор, шлях, код::адреса) == ні {
      вихід_помилки::вміст = створити_помилку(компілятор, "Не вдалось прочитати файл.", пусто);

      вернути ні;
    }

    змінна текст_коду = створити_текст_коду(компілятор);

    текст_коду.шлях = клонувати_шлях(компілятор, шлях);
    текст_коду.значення = т8 { 0, пусто };
    текст_коду.кодування_оригінального_значення = КодуванняЮ8;
    текст_коду.оригінальне_значення = код;
    текст_коду.місцезнаходження_оригінального_значення = біб::МісцезнаходженняПерекодованого { 0, пусто, 0 };

    якщо перекодувати_ю8_в_т8_з_місцезнаходженнями(компілятор, ю8 { код.розмір, код.дані }, текст_коду.значення::адреса, текст_коду.місцезнаходження_оригінального_значення::адреса) == ні {
      вернути ні;
    }

    вернути скомпілювати_текст_коду(компілятор, текст_коду, вихід_помилки);
  }

  зовнішня дія перевірити_чи_шлях_існує(компілятор: адреса<Компілятор>, шлях: Шлях): логічне {
    вернути __КЦ__перевірити_чи_шлях_існує(компілятор.виділяч, шлях::адреса);
  }

  зовнішня дія отримати_директорію_шляху_до_файлу(компілятор: адреса<Компілятор>, вхід: Шлях, вихід: адреса<Шлях>): логічне {
    вернути __КЦ__отримати_директорію_шляху_до_файлу(компілятор.виділяч, вхід::адреса, вихід);
  }

  зовнішня дія отримати_поточну_директорію_процесу(компілятор: адреса<Компілятор>, вихід: адреса<Шлях>): логічне {
    вернути __КЦ__отримати_поточну_директорію_процесу(компілятор.виділяч, вихід);
  }

  зовнішня дія отримати_абсолютний_шлях(компілятор: адреса<Компілятор>, вхід: Шлях, вихід: адреса<Шлях>): логічне {
    вернути __КЦ__отримати_абсолютний_шлях(компілятор.виділяч, вхід::адреса, вихід);
  }

  зовнішня дія отримати_лл(компілятор: адреса<Компілятор>, вихід: адреса<ю8>, вихід_помилки: адреса<адреса<Помилка>>): логічне {
    ПМ::отримати_лл(компілятор.пм_модуль, вихід.розмір::адреса, вихід.дані::адреса);

    вернути так;
  }

  синонім СИМВОЛ_ПЛЮС = КД::символи::Хрестик;
  синонім СИМВОЛ_МІНУС = КД::символи::Риска;
  синонім СИМВОЛ_0 = КД::символи::Нуль;
  синонім СИМВОЛ_1 = КД::символи::Один;
  синонім СИМВОЛ_2 = КД::символи::Два;
  синонім СИМВОЛ_3 = КД::символи::Три;
  синонім СИМВОЛ_4 = КД::символи::Чотири;
  синонім СИМВОЛ_5 = КД::символи::Пʼять;
  синонім СИМВОЛ_6 = КД::символи::Шість;
  синонім СИМВОЛ_7 = КД::символи::Сім;
  синонім СИМВОЛ_8 = КД::символи::Вісім;
  синонім СИМВОЛ_9 = КД::символи::Девʼять;
  синонім СИМВОЛ_КРАПКА = КД::символи::Крапка;


  зовнішня дія спробувати_розібрати_ціле_число(компілятор: адреса<Компілятор>, значення: т8, вихід: адреса<ц64>, вихід_помилки: адреса<т8>, вихід_позиції_помилки: адреса<позитивне>): логічне {
    змінна вихідне: ціле = 0;
    змінна знак: ц8 = 1;
    змінна п: позитивне = 0;

    якщо п < значення.розмір {
      якщо значення.дані[п] == СИМВОЛ_МІНУС {
        знак = ц8(0) - 1;
        п += 1;
      } інакше якщо значення.дані[п] == СИМВОЛ_ПЛЮС {
        п += 1;
      }
    }

    поки п < значення.розмір {
      змінна с = значення.дані[п];

      якщо с == СИМВОЛ_0 {
      } інакше якщо с == СИМВОЛ_1 {
      } інакше якщо с == СИМВОЛ_2 {
      } інакше якщо с == СИМВОЛ_3 {
      } інакше якщо с == СИМВОЛ_4 {
      } інакше якщо с == СИМВОЛ_5 {
      } інакше якщо с == СИМВОЛ_6 {
      } інакше якщо с == СИМВОЛ_7 {
      } інакше якщо с == СИМВОЛ_8 {
      } інакше якщо с == СИМВОЛ_9 {
      } інакше {
        стрибнути успіх;
      }

      вихідне = вихідне * 10 + (ціле(с) - СИМВОЛ_0);

      п += 1;
    }

  успіх:
    вихід::вміст = вихідне * ціле(знак);
    вернути так;
  }

  зовнішня дія спробувати_розібрати_позитивне_число(компілятор: адреса<Компілятор>, значення: т8, вихід: адреса<п64>, вихід_помилки: адреса<т8>, вихід_позиції_помилки: адреса<позитивне>): логічне {
    змінна вихідне: позитивне = 0;
    змінна п: позитивне = 0;

    поки п < значення.розмір {
      змінна с = значення.дані[п];

      якщо с == СИМВОЛ_0 {
      } інакше якщо с == СИМВОЛ_1 {
      } інакше якщо с == СИМВОЛ_2 {
      } інакше якщо с == СИМВОЛ_3 {
      } інакше якщо с == СИМВОЛ_4 {
      } інакше якщо с == СИМВОЛ_5 {
      } інакше якщо с == СИМВОЛ_6 {
      } інакше якщо с == СИМВОЛ_7 {
      } інакше якщо с == СИМВОЛ_8 {
      } інакше якщо с == СИМВОЛ_9 {
      } інакше {
        стрибнути успіх;
      }

      вихідне = вихідне * 10 + (позитивне(с) - СИМВОЛ_0);

      п += 1;
    }

  успіх:
    вихід::вміст = вихідне;
    вернути так;
  }

  зовнішня дія спробувати_розібрати_дійсне_число(компілятор: адреса<Компілятор>, значення: т8, вихід: адреса<д64>, вихід_помилки: адреса<т8>, вихід_позиції_помилки: адреса<позитивне>): логічне {
    змінна вихідне: д64 = 0.0;
    змінна фрак: д64 = 0.0;
    змінна дів: д64 = 10.0;
    змінна п: позитивне = 0;
    змінна знак: ц8 = 1;
    змінна була_крапка = ні;

    якщо п < значення.розмір {
      змінна с = значення.дані[п];

      якщо с == СИМВОЛ_МІНУС {
        знак = ц8(0)-1;
        п += 1;
      } інакше {
        якщо с == СИМВОЛ_ПЛЮС {
          п += 1;
        }
      }
    }

    поки п < значення.розмір {
      змінна с = значення.дані[п];
      змінна с_крапка = с == СИМВОЛ_КРАПКА;
      змінна с_цбр_0 = с >= СИМВОЛ_0;
      змінна с_цмр_9 = с <= СИМВОЛ_9;
      змінна с_цифра = с_цбр_0 * с_цмр_9;

      змінна вже_була_крапка = була_крапка;

      якщо с_крапка {
        якщо вже_була_крапка {
          стрибнути успіх;
        }

        була_крапка = так;

        п += 1;
      } інакше {
        якщо с_цифра == ні {
          стрибнути успіх;
        }

        якщо вже_була_крапка {
          фрак = фрак + (д64(с) - СИМВОЛ_0) / дів;
          дів = дів * 10.0;
        } інакше {
          вихідне = вихідне * 10.0 + (д64(с) - СИМВОЛ_0);
        }

        п += 1;
      }
    }

  успіх:
    вихід::вміст = д64(знак) * (вихідне + фрак);
    вернути так;
  }

  зовнішня дія перетворити_позитивне_на_т8(компілятор: адреса<Компілятор>, значення: позитивне, вихід: адреса<т8>): логічне {
    змінна довжина: позитивне = 0;
    змінна тимч: позитивне = значення;

    довжина += 1;
    тимч /= 10;

    поки тимч != 0 {
      довжина += 1;
      тимч /= 10;
    }

    змінна значення_т8 = т8 { довжина, виділити_памʼять<п8>(компілятор, довжина) };

    змінна п = ціле(довжина - 1);
    поки п >= 0 {
      значення_т8.дані[п] = п8(СИМВОЛ_0) + п8(значення % 10);
      значення /= 10;
      п -= 1;
    }

    вихід::вміст = значення_т8;

    вернути так;
  }

  зовнішня дія отримати_повну_назву_в_контексті(компілятор: адреса<Компілятор>, контекст: Контекст, назва: т8): т8 {
    змінна накопичувач_т8 = зробити_накопичувач_т8(компілятор);

    покласти_в_накопичувач_т8(компілятор, накопичувач_т8::адреса, назва);

    змінна поточне_середовище = контекст.середовище;

    поки поточне_середовище != пусто {
      якщо поточне_середовище.обʼєкт_секції != пусто {
        якщо поточне_середовище.обʼєкт_секції.назва.значення.розмір > 0 {
          покласти_спереду_накопичувача_т8(компілятор, накопичувач_т8::адреса, "::");
          покласти_спереду_накопичувача_т8(компілятор, накопичувач_т8::адреса, поточне_середовище.обʼєкт_секції.назва.значення);
        }
      } інакше якщо поточне_середовище.обʼєкт_дії != пусто {
        якщо поточне_середовище.обʼєкт_дії.назва.значення.розмір > 0 {
          покласти_спереду_накопичувача_т8(компілятор, накопичувач_т8::адреса, "::");
          покласти_спереду_накопичувача_т8(компілятор, накопичувач_т8::адреса, поточне_середовище.обʼєкт_дії.назва.значення);
        }
      }

      поточне_середовище = поточне_середовище.зовнішнє;
    }

    вернути накопичувач_т8.значення;
  }
}