взяти визначення ./КЦ;

зовнішня дія __КЦ__прочитати_файл(виділяч: адреса<біб::Виділяч>, шлях: адреса<КЦ::Шлях>, вихід: адреса<КЦ::Байти>, вихід_успіху: адреса<логічне>);
зовнішня дія __КЦ__записати_файл(виділяч: адреса<біб::Виділяч>, шлях: адреса<КЦ::Шлях>, значення: адреса<КЦ::Байти>, вихід_успіху: адреса<логічне>);
зовнішня дія __КЦ__перевірити_чи_шлях_існує(виділяч: адреса<біб::Виділяч>, шлях: адреса<КЦ::Шлях>): логічне;
зовнішня дія __КЦ__отримати_директорію_шляху_до_файлу(виділяч: адреса<біб::Виділяч>, вхід: адреса<КЦ::Шлях>, вихід: адреса<КЦ::Шлях>): логічне;
зовнішня дія __КЦ__отримати_поточну_директорію_процесу(виділяч: адреса<біб::Виділяч>, вихід: адреса<КЦ::Шлях>): логічне;
зовнішня дія __КЦ__отримати_абсолютний_шлях(виділяч: адреса<біб::Виділяч>, вхід: адреса<КЦ::Шлях>, вихід: адреса<КЦ::Шлях>): логічне;

секція КЦ {
  місцева дія перекодувати_ю8_в_т8_з_місцезнаходженнями(компілятор: адреса<Компілятор>, значення: ю8, вихід: адреса<т8>, вихід_місцезнаходжень: адреса<біб::МісцезнаходженняПерекодованого>): логічне {
    змінна позиція_помилки: позитивне = 0;

    вернути біб::перекодувати_ю8_в_т8(
      компілятор.виділяч,
      значення,
      так,
      ні,
      вихід,
      вихід_місцезнаходжень,
      позиція_помилки::адреса
    );
  }

  місцева дія прочитати_файл(компілятор: адреса<Компілятор>, шлях: Шлях, вихід: адреса<Байти>): логічне {
    змінна успіх = ні;
    __КЦ__прочитати_файл(компілятор.виділяч, шлях::адреса, вихід, успіх::адреса);
    вернути успіх;
  }

  місцева дія записати_файл(компілятор: адреса<Компілятор>, шлях: Шлях, значення: Байти): логічне {
    змінна успіх = ні;
    __КЦ__записати_файл(компілятор.виділяч, шлях::адреса, значення::адреса, успіх::адреса);
    вернути успіх;
  }

  місцева дія скомпілювати_текст_коду(компілятор: адреса<Компілятор>, середовище: адреса<Середовище>, текст_коду: адреса<ТекстКоду>, вихід_помилки: адреса<адреса<Помилка>>): логічне {
    змінна розбирач = КЦ::розбирач::створити(компілятор.виділяч);

    змінна успіх_розбору = ні;

    змінна розібраний_текст = створити_розібраний_текст(компілятор);
    розібраний_текст.текст_коду = текст_коду;
    розібраний_текст.розбирач = розбирач;

    покласти_взятий_файл(компілятор.взяті_файли, текст_коду.шлях, розібраний_текст);

    змінна помилка_розбору_на_слова: КЦ::розбирач::ПомилкаРозборуНаСлова;
    змінна помилка_розбору_на_сполуки: КЦ::розбирач::ПомилкаРозборуНаСполуки;

    успіх_розбору = КЦ::розбирач::розібрати_на_слова(
      розбирач,
      ю8 { текст_коду.значення.розмір, текст_коду.значення.дані },
      розібраний_текст.слова::адреса,
      помилка_розбору_на_слова::адреса
    );
    якщо успіх_розбору == ні {
      змінна позиція_в_тексті = помилка_розбору_на_слова.позиція.позиція_в_тексті;
      змінна рядок = помилка_розбору_на_слова.позиція.рядок;
      змінна стовпець = помилка_розбору_на_слова.позиція.стовпець;

      вихід_помилки::вміст = створити_помилку(
        компілятор,
        "Неочікуваний символ.",
        створити_місцезнаходження_помилки(компілятор, текст_коду, позиція_в_тексті, рядок, стовпець)
      );

      вернути ні;
    }

//    біб::надрукувати_ю8(ю8 { текст_коду.шлях.розмір, текст_коду.шлях.дані });
//    біб::надрукувати_ю8(ю8"--- слова ---");
//    КЦ::розбирач::надрукувати_слова(розбирач, текст_коду.значення, розібраний_текст.слова);
//    біб::надрукувати_ю8(ю8"--- кінець слів ---");

    успіх_розбору = КЦ::розбирач::розібрати_слова_на_сполуки(розбирач, розібраний_текст.слова, розібраний_текст.сполуки::адреса, помилка_розбору_на_сполуки::адреса);
    якщо успіх_розбору == ні {
      змінна позиція_в_тексті = розібраний_текст.слова.дані[помилка_розбору_на_сполуки.позиція_слова].позиція_початку.позиція_в_тексті;
      змінна рядок = розібраний_текст.слова.дані[помилка_розбору_на_сполуки.позиція_слова].позиція_початку.рядок;
      змінна стовпець = розібраний_текст.слова.дані[помилка_розбору_на_сполуки.позиція_слова].позиція_початку.стовпець;

      вихід_помилки::вміст = створити_помилку(
        компілятор,
        "Неочікуване слово.",
        створити_місцезнаходження_помилки(компілятор, текст_коду, позиція_в_тексті, рядок, стовпець)
      );

      вернути ні;
    }

//    біб::надрукувати_ю8(ю8 { текст_коду.шлях.розмір, текст_коду.шлях.дані });
//    біб::надрукувати_ю8(ю8"--- сполуки ---");
//    КЦ::розбирач::надрукувати_сполуки(розбирач, текст_коду.значення, розібраний_текст.слова, розібраний_текст.сполуки, 0);
//    біб::надрукувати_ю8(ю8"--- кінець сполук ---");

    змінна результат_компіляції_тіла = скомпілювати_тіло(
      компілятор,
      Контекст {
        розібраний_текст = розібраний_текст,
        середовище = середовище,
        кк_дії = пусто
      },
      розібраний_текст.сполуки,
      КЦ::розбирач::Місцезнаходження { 0, 0 }
    );

    якщо результат_компіляції_тіла.помилка != пусто {
      вихід_помилки::вміст = результат_компіляції_тіла.помилка;
      вернути ні;
    }

    // ...

    вернути так;
  }

  місцева дія взяти_файл_ю8(компілятор: адреса<Компілятор>, середовище: адреса<Середовище>, шлях: Шлях, вихід_помилки: адреса<адреса<Помилка>>): логічне {
    змінна взятий_файл: адреса<РозібранийТекст> = пусто;
    якщо знайти_взятий_файл(компілятор.взяті_файли, шлях, взятий_файл::адреса) {
      вернути так;
    }

    змінна код = Байти { 0, пусто };

    якщо прочитати_файл(компілятор, шлях, код::адреса) == ні {
      вихід_помилки::вміст = створити_помилку(компілятор, "Не вдалось прочитати файл.", пусто);
      вернути ні;
    }

    змінна текст_коду = створити_текст_коду(компілятор);

    текст_коду.шлях = клонувати_шлях(компілятор, шлях);
    текст_коду.значення = ю8 { код.розмір, код.дані };

    вернути скомпілювати_текст_коду(компілятор, середовище, текст_коду, вихід_помилки);
  }

  місцева дія перевірити_чи_шлях_існує(компілятор: адреса<Компілятор>, шлях: Шлях): логічне {
    вернути __КЦ__перевірити_чи_шлях_існує(компілятор.виділяч, шлях::адреса);
  }

  місцева дія отримати_директорію_шляху_до_файлу(компілятор: адреса<Компілятор>, вхід: Шлях, вихід: адреса<Шлях>): логічне {
    вернути __КЦ__отримати_директорію_шляху_до_файлу(компілятор.виділяч, вхід::адреса, вихід);
  }

  місцева дія отримати_поточну_директорію_процесу(компілятор: адреса<Компілятор>, вихід: адреса<Шлях>): логічне {
    вернути __КЦ__отримати_поточну_директорію_процесу(компілятор.виділяч, вихід);
  }

  місцева дія отримати_абсолютний_шлях(компілятор: адреса<Компілятор>, вхід: Шлях, вихід: адреса<Шлях>): логічне {
    вернути __КЦ__отримати_абсолютний_шлях(компілятор.виділяч, вхід::адреса, вихід);
  }

  стала СИМВОЛ_ПЛЮС = КД::символи::Хрестик;
  стала СИМВОЛ_МІНУС = КД::символи::Риска;
  стала СИМВОЛ_0 = КД::символи::Нуль;
  стала СИМВОЛ_1 = КД::символи::Один;
  стала СИМВОЛ_2 = КД::символи::Два;
  стала СИМВОЛ_3 = КД::символи::Три;
  стала СИМВОЛ_4 = КД::символи::Чотири;
  стала СИМВОЛ_5 = КД::символи::Пʼять;
  стала СИМВОЛ_6 = КД::символи::Шість;
  стала СИМВОЛ_7 = КД::символи::Сім;
  стала СИМВОЛ_8 = КД::символи::Вісім;
  стала СИМВОЛ_9 = КД::символи::Девʼять;
  стала СИМВОЛ_КРАПКА = КД::символи::Крапка;

  місцева дія спробувати_розібрати_ціле_число(компілятор: адреса<Компілятор>, значення: т8, вихід: адреса<ц64>, вихід_помилки: адреса<т8>, вихід_позиції_помилки: адреса<позитивне>): логічне {
    змінна вихідне: ціле = 0;
    змінна знак: ц8 = 1;
    змінна п: позитивне = 0;

    якщо п < значення.розмір {
      якщо значення.дані[п] == СИМВОЛ_МІНУС {
        знак = ц8(0) - 1;
        п += 1;
      } інакше якщо значення.дані[п] == СИМВОЛ_ПЛЮС {
        п += 1;
      }
    }

    поки п < значення.розмір {
      змінна с = значення.дані[п];

      якщо с == СИМВОЛ_0 {
      } інакше якщо с == СИМВОЛ_1 {
      } інакше якщо с == СИМВОЛ_2 {
      } інакше якщо с == СИМВОЛ_3 {
      } інакше якщо с == СИМВОЛ_4 {
      } інакше якщо с == СИМВОЛ_5 {
      } інакше якщо с == СИМВОЛ_6 {
      } інакше якщо с == СИМВОЛ_7 {
      } інакше якщо с == СИМВОЛ_8 {
      } інакше якщо с == СИМВОЛ_9 {
      } інакше {
        стрибнути успіх;
      }

      вихідне = вихідне * 10 + (ціле(с) - СИМВОЛ_0);

      п += 1;
    }

  успіх:
    вихід::вміст = вихідне * ціле(знак);
    вернути так;
  }

  місцева дія спробувати_розібрати_позитивне_число(компілятор: адреса<Компілятор>, значення: т8, вихід: адреса<п64>, вихід_помилки: адреса<т8>, вихід_позиції_помилки: адреса<позитивне>): логічне {
    змінна вихідне: позитивне = 0;
    змінна п: позитивне = 0;

    поки п < значення.розмір {
      змінна с = значення.дані[п];

      якщо с == СИМВОЛ_0 {
      } інакше якщо с == СИМВОЛ_1 {
      } інакше якщо с == СИМВОЛ_2 {
      } інакше якщо с == СИМВОЛ_3 {
      } інакше якщо с == СИМВОЛ_4 {
      } інакше якщо с == СИМВОЛ_5 {
      } інакше якщо с == СИМВОЛ_6 {
      } інакше якщо с == СИМВОЛ_7 {
      } інакше якщо с == СИМВОЛ_8 {
      } інакше якщо с == СИМВОЛ_9 {
      } інакше {
        стрибнути успіх;
      }

      вихідне = вихідне * 10 + (позитивне(с) - СИМВОЛ_0);

      п += 1;
    }

  успіх:
    вихід::вміст = вихідне;
    вернути так;
  }

  місцева дія спробувати_розібрати_дійсне_число(компілятор: адреса<Компілятор>, значення: т8, вихід: адреса<д64>, вихід_помилки: адреса<т8>, вихід_позиції_помилки: адреса<позитивне>): логічне {
    змінна число: д64 = 0.0;
    змінна п: позитивне = 0;
    змінна с: п8 = значення.дані[0];
    
    поки п < значення.розмір {
      якщо с == СИМВОЛ_0 { // 0
        число = число * 10;
      } інакше якщо с == СИМВОЛ_1 { // 1
        число = число * 10 + 1;
      } інакше якщо с == СИМВОЛ_2 { // 2
        число = число * 10 + 2;
      } інакше якщо с == СИМВОЛ_3 { // 3
        число = число * 10 + 3;
      } інакше якщо с == СИМВОЛ_4 { // 4
        число = число * 10 + 4;
      } інакше якщо с == СИМВОЛ_5 { // 5
        число = число * 10 + 5;
      } інакше якщо с == СИМВОЛ_6 { // 6
        число = число * 10 + 6;
      } інакше якщо с == СИМВОЛ_7 { // 7
        число = число * 10 + 7;
      } інакше якщо с == СИМВОЛ_8 { // 8
        число = число * 10 + 8;
      } інакше якщо с == СИМВОЛ_9 { // 9
        число = число * 10 + 9;
      } інакше якщо с == СИМВОЛ_КРАПКА { // .
        п += 1;
        с = значення.дані[п];

        змінна дробна_частина: д64 = 0.0;
        змінна дільник: д64 = 1.0;

        поки п < значення.розмір {
          якщо с == СИМВОЛ_0 { // 0
            дробна_частина = дробна_частина * 10;
          } інакше якщо с == СИМВОЛ_1 { // 1
            дробна_частина = дробна_частина * 10 + 1;
          } інакше якщо с == СИМВОЛ_2 { // 2
            дробна_частина = дробна_частина * 10 + 2;
          } інакше якщо с == СИМВОЛ_3 { // 3
            дробна_частина = дробна_частина * 10 + 3;
          } інакше якщо с == СИМВОЛ_4 { // 4
            дробна_частина = дробна_частина * 10 + 4;
          } інакше якщо с == СИМВОЛ_5 { // 5
            дробна_частина = дробна_частина * 10 + 5;
          } інакше якщо с == СИМВОЛ_6 { // 6
            дробна_частина = дробна_частина * 10 + 6;
          } інакше якщо с == СИМВОЛ_7 { // 7
            дробна_частина = дробна_частина * 10 + 7;
          } інакше якщо с == СИМВОЛ_8 { // 8
            дробна_частина = дробна_частина * 10 + 8;
          } інакше якщо с == СИМВОЛ_9 { // 9
            дробна_частина = дробна_частина * 10 + 9;
          } інакше {
            вихід_позиції_помилки::вміст = п;
            вернути ні;
          }

          п += 1;
          с = значення.дані[п];
          дільник = дільник * 10;
        }

        число = число + дробна_частина / дільник;

        вихід::вміст = число;
        вернути так;
      } інакше {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }

      п += 1;
      с = значення.дані[п];
    }

    вихід::вміст = число;
    вернути так;
  }

  місцева дія перетворити_позитивне_на_т8(компілятор: адреса<Компілятор>, значення: позитивне, вихід: адреса<т8>): логічне {
    змінна довжина: позитивне = 0;
    змінна тимч: позитивне = значення;

    довжина += 1;
    тимч /= 10;

    поки тимч != 0 {
      довжина += 1;
      тимч /= 10;
    }

    змінна значення_т8 = т8 { довжина, виділити_памʼять<п8>(компілятор, довжина) };

    змінна п = ціле(довжина - 1);
    поки п >= 0 {
      значення_т8.дані[п] = п8(СИМВОЛ_0) + п8(значення % 10);
      значення /= 10;
      п -= 1;
    }

    вихід::вміст = значення_т8;

    вернути так;
  }

  місцева дія отримати_повну_назву_в_контексті(компілятор: адреса<Компілятор>, контекст: Контекст, назва: т8): т8 {
    змінна накопичувач_т8 = зробити_накопичувач_т8(компілятор);

    покласти_в_накопичувач_т8(компілятор, накопичувач_т8::адреса, назва);

    змінна поточне_середовище = контекст.середовище;

    поки поточне_середовище != пусто {
      якщо поточне_середовище.обʼєкт_секції != пусто {
        якщо поточне_середовище.обʼєкт_секції.назва.значення.розмір > 0 {
          покласти_спереду_накопичувача_т8(компілятор, накопичувач_т8::адреса, "::");
          покласти_спереду_накопичувача_т8(компілятор, накопичувач_т8::адреса, поточне_середовище.обʼєкт_секції.назва.значення);
        }
      } інакше якщо поточне_середовище.обʼєкт_дії != пусто {
        якщо поточне_середовище.обʼєкт_дії.назва.значення.розмір > 0 {
          покласти_спереду_накопичувача_т8(компілятор, накопичувач_т8::адреса, "::");
          покласти_спереду_накопичувача_т8(компілятор, накопичувач_т8::адреса, поточне_середовище.обʼєкт_дії.назва.значення);
        }
      }

      поточне_середовище = поточне_середовище.зовнішнє;
    }

    вернути накопичувач_т8.значення;
  }

  місцева дія отримати_назву(компілятор: адреса<Компілятор>, значення: т8): адреса<Назва> {
    вернути ПМ::отримати_назву(компілятор.пм_сховище_назв, значення);
  }

  місцева дія назва_без_копіювання(компілятор: адреса<Компілятор>, значення: т8): адреса<Назва> {
    вернути ПМ::отримати_назву_без_копіювання(компілятор.пм_сховище_назв, значення);
  }
}