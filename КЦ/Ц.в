взяти визначення розбирач;
взяти визначення LLVM;
взяти біб друк;

зовнішня дія зʼєднати_ю8(значення: памʼять<п8>, значення2: памʼять<п8>): памʼять<п8>;

зовнішня дія strcmp(а: памʼять<п8>, б: памʼять<п8>): ц32;

структура карта_субʼєктів;
структура карта_комірок;

зовнішня дія отримати_з_карти_субʼєктів(карта: комірка<карта_субʼєктів>, назва: памʼять<п8>, комірка_типу: комірка<позитивне>, комірка_даних: комірка<невідома_комірка>): позитивне;
зовнішня дія змінити_в_карті_субʼєктів(карта: комірка<карта_субʼєктів>, назва: памʼять<п8>, тип: позитивне, дані: невідома_комірка);
зовнішня дія створити_карту_субʼєктів(): комірка<карта_субʼєктів>;

зовнішня дія отримати_з_карти_комірок(карта: комірка<карта_комірок>, назва: памʼять<п8>, комірка_значення: комірка<невідома_комірка>): позитивне;
зовнішня дія змінити_в_карті_комірок(карта: комірка<карта_комірок>, назва: памʼять<п8>, значення: невідома_комірка);
зовнішня дія створити_карту_комірок(): комірка<карта_комірок>;

структура список<Т> {
  дані: памʼять<Т>;
  довжина: позитивне;
  вмісткість: позитивне;
}

дія виділити_список<Т>(): комірка<список<Т>> {
  ціль с = виділити<список<Т>>();
  с.дані = пусто;
  с.довжина = 0;
  с.вмісткість = 0;
  вернути с;
}

дія додати_до_списку<Т>(с: комірка<список<Т>>, значення: Т) {
  якщо с.довжина == с.вмісткість {
    якщо с.вмісткість == 0 {
      с.дані = виділити<Т>(1);
    } інакше {
      с.дані = перевиділити<Т>(с.дані, с.вмісткість + 1);
    }
    с.вмісткість = с.вмісткість + 1;
  }
  с.дані[с.довжина] = значення;
  с.довжина = с.довжина + 1;
}

дія звільнити_список<Т>(с: комірка<список<Т>>) {
  звільнити(с.дані);
  звільнити(с);
}

структура ЕлементКарти<К, З> {
  ключ: К;
  значення: З;
}

структура карта<К, З> {
  елементи: комірка<список<ЕлементКарти<К, З>>>;
  перевірити_ключ: (К, К) -> логічне;
}

дія виділити_карту<К, З>(перевірити_ключ: (К, К) -> логічне): комірка<карта<К, З>> {
  ціль с = виділити<карта<К, З>>();
  с.елементи = виділити_список<ЕлементКарти<К, З>>();
  с.перевірити_ключ = перевірити_ключ;
  вернути с;
}

дія отримати_значення_з_карти<К, З>(с: комірка<карта<К, З>>, ключ: К, пусте_значення: З): З {
  змінна х = 0;
  поки х < с.елементи.довжина {
    якщо с.перевірити_ключ(с.елементи.дані[х].ключ, ключ) == так {
      вернути с.елементи.дані[х].значення;
    }
    х = х + 1;
  }
  вернути пусте_значення;
}

дія перевірити_чи_карта_містить_значення<К, З>(с: комірка<карта<К, З>>, ключ: К): логічне {
  змінна х = 0;
  поки х < с.елементи.довжина {
    якщо с.перевірити_ключ(с.елементи.дані[х].ключ, ключ) == так {
      вернути так;
    }
    х = х + 1;
  }
  вернути ні;
}

дія змінити_значення_карти<К, З>(с: комірка<карта<К, З>>, ключ: К, значення: З): ціле {
  змінна х = 0;
  поки х < с.елементи.довжина {
    якщо с.перевірити_ключ(с.елементи.дані[х].ключ, ключ) == 1 {
      с.елементи.дані[х].значення = значення;
      вернути с.елементи.довжина;
    }
    х = х + 1;
  }
  додати_до_списку<ЕлементКарти<К, З>>(с.елементи, ЕлементКарти<К, З> { ключ, значення });
  вернути с.елементи.довжина;
}

дія видалити_з_карти<К, З>(с: комірка<карта<К, З>>, ключ: К): позитивне {
  змінна х = 0;
  поки х < с.елементи.довжина {
    якщо с.перевірити_ключ(с.елементи.дані[х].ключ, ключ) == 1 {
      змінна у = х;
      поки у < с.елементи.довжина - 1 {
        с.елементи.дані[у] = с.елементи.дані[у + 1];
        у = у + 1;
      }
      с.елементи.довжина = с.елементи.довжина - 1;
      вернути 1;
    }
    х = х + 1;
  }
  вернути 0;
}

дія звільнити_карту<К, З>(с: комірка<карта<К, З>>) {
  звільнити_список<ЕлементКарти<К, З>>(с.елементи);
  звільнити(с);
}

синонім буфер_ю8 = список<п8>;

дія створити_буфер_ю8(): комірка<список<п8>> {
  вернути виділити_список<п8>();
}

дія додати_до_буфера_ю8(буфер: комірка<список<п8>>, значення: памʼять<п8>) {
  змінна х = 0;
  поки значення[х] != 0 {
    додати_до_списку<п8>(буфер, значення[х]);
    х = х + 1;
  }
}

дія додати_символ_до_буфера_ю8(буфер: комірка<список<п8>>, значення: п8) {
  додати_до_списку<п8>(буфер, значення);
}

дія звільнити_буфер_ю8(буфер: комірка<список<п8>>) {
  звільнити_список<п8>(буфер);
}

дія створити_ю8_сі_з_буфера(буфер: комірка<список<п8>>): памʼять<п8> {
  ціль значення = виділити<п8>(буфер.довжина + 1);
  змінна х = 0;
  поки х < буфер.довжина {
    значення[х] = буфер.дані[х];
    х = х + 1;
  }
  значення[буфер.довжина] = 0;
  вернути значення;
}

секція цк {
  синонім ВидТипуНативний = 1;
  синонім ВидТипуСтруктура = 2;
  синонім ВидТипуДія = 3;
  синонім ВидТипуКомірка = 4;

  синонім ВидОКТип = 1;
  синонім ВидОКДія = 2;
  синонім ВидОКЦіль = 3;
  синонім ВидОКШаблон = 4;
  синонім ВидОКСинонім = 5;
  синонім ВидОКСекція = 6;
  синонім ВидОКСпецОбʼєкт = 7;

  структура Параметр;

  структура ДаніТипуНативний;
  структура ДаніТипуСтруктура;
  структура ДаніТипуДія;
  структура ДаніТипуКомірка;
  структура Тип;
  структура Дія;
  структура Ціль;
  структура Шаблон;
  структура Синонім;
  структура Секція;
  структура СпецОбʼєкт;

  структура ОбʼєктКомпіляції;
  структура ОбʼєктВиконання;

  структура Параметр {
    назва: памʼять<п8>;
    тип: Тип;
  }

  структура ДаніТипуНативний {
    л_тип: комірка<LLVM::Type>;
  }

  структура ДаніТипуСтруктура {
    л_тип: комірка<LLVM::Type>;
    параметри: комірка<список<Параметр>>;
    середовище_створення_структури: комірка<Середовище>;
  }

  структура ДаніТипуДія {
    л_тип_функції: комірка<LLVM::FunctionType>;
    параметри: комірка<список<Параметр>>;
    тип_результату: Тип;
  }

  структура ДаніТипуКомірка {
    л_тип: комірка<LLVM::Type>;
    тип_елемента: Тип;
  }

  структура Тип {
    вид: позитивне;
    дані: комірка<ДаніТипуНативний> | комірка<ДаніТипуСтруктура> | комірка<ДаніТипуДія> | комірка<ДаніТипуКомірка>;
  }

  структура Дія {
    видимість: позитивне;
    середовище_створення_дії: комірка<Середовище>;
    назва: памʼять<п8>;
    параметри: комірка<список<Параметр>>;
    тип_результату: Тип;
    середовище_тіла_дії: комірка<Середовище>;
    л_функція: комірка<LLVM::Function>;
    дані_типу_дія: комірка<ДаніТипуДія>;
  }

  структура Ціль {
    тип: Тип;
    llvm_alloca_value: комірка<LLVM::Value>;
  }

  структура Шаблон {
    зовнішнє_середовище: комірка<Середовище>;
    параметри: комірка<список<памʼять<п8>>>;
    асд_значення: комірка<АСДЗначення>;
    карта_готових_значень: комірка<карта<комірка<список<Значення>>, Значення>>;
  }

  структура Синонім {
    зовнішнє_середовище: комірка<Середовище>;
    асд_значення: комірка<АСДЗначення>;
  }

  структура Секція {
    назва: памʼять<п8>;
    середовище: комірка<Середовище>;
  }

  структура ОбʼєктКомпіляції {
    вид: позитивне;
    дані: комірка<Тип> | комірка<Дія> | комірка<Ціль> | комірка<Шаблон> | комірка<Синонім> | комірка<Секція> | комірка<СпецОбʼєкт>;
  }

  структура ОбʼєктВиконання {
    тип: Тип;
    л_значення: комірка<LLVM::Value>;
    unloaded: логічне;
  }

  синонім ВидЗначенняОК = 1;
  синонім ВидЗначенняОВ = 2;

  структура Значення {
    вид: позитивне;
    к: ОбʼєктКомпіляції;
    в: ОбʼєктВиконання;
  }

  структура Блок {
    llvm_ret_value: комірка<LLVM::Value>;
    llvm_alloca_block: комірка<LLVM::BasicBlock>;
    llvm_block: комірка<LLVM::BasicBlock>;
    llvm_exit_block: комірка<LLVM::BasicBlock>;
    llvm_function_exit_block: комірка<LLVM::BasicBlock>;
  }

  структура ПомилкаКомпіляції {
    місцезнаходження: комірка<Місцезнаходження>;
    повідомлення: памʼять<п8>;
  }

  місцева дія створити_помилку_компіляції(місцезнаходження: комірка<Місцезнаходження>, повідомлення: памʼять<п8>): комірка<ПомилкаКомпіляції>;
  місцева дія створити_помилку_компіляції_субʼєкт_вже_визначено(місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>): комірка<ПомилкаКомпіляції>;
  місцева дія створити_помилку_компіляції_невірна_кількість_параметрів(місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікується: позитивне, отримано: позитивне): комірка<ПомилкаКомпіляції>;
  місцева дія створити_помилку_компіляції_невірна_видимість(місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікується: позитивне, отримано: позитивне): комірка<ПомилкаКомпіляції>;

  структура РезультатЗначення {
    значення: Значення;
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура РезультатЗначенняТип {
    тип: Тип;
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура РезультатЗначенняЗначення {
    в: ОбʼєктВиконання;
    помилка: комірка<ПомилкаКомпіляції>;
  }

  дія отримати_властивість(значення: Значення, блок: комірка<Блок>, назва_властивості: памʼять<п8>): РезультатЗначення;
  дія змінити_властивість(значення: Значення, блок: комірка<Блок>, назва_властивості: памʼять<п8>, значення_властивості: Значення): РезультатЗначення;
  дія виконати(значення: Значення, блок: комірка<Блок>, кількість_аргументів: позитивне, аргументи: памʼять<Значення>): РезультатЗначення;
  дія виконати_шаблон(значення: Значення, блок: комірка<Блок>, кількість_аргументів: позитивне, аргументи: памʼять<Значення>): РезультатЗначення;
  дія додати(значення: Значення, блок: комірка<Блок>, значення_аргумента: Значення): РезультатЗначення;

  структура Середовище {
    батьківське: комірка<Середовище>;
    субʼєкти: комірка<карта_субʼєктів>;
    _секція: комірка<Секція>;
  }

  місцева дія створити_середовище(батьківське: комірка<Середовище>): комірка<Середовище>;

  структура РезультатОтриманняЗСередовища {
    знайдено: логічне;
    субʼєкт: ОбʼєктКомпіляції;
  }

  місцева дія отримати_з_середовища(середовище: комірка<Середовище>, назва: памʼять<п8>): РезультатОтриманняЗСередовища;
  місцева дія отримати_з_локального_середовища(середовище: комірка<Середовище>, назва: памʼять<п8>): РезультатОтриманняЗСередовища;
  місцева дія змінити_в_середовищі(середовище: комірка<Середовище>, назва: памʼять<п8>, значення: ОбʼєктКомпіляції);

  структура Компілятор {
    глобальне_середовище: комірка<Середовище>;
    Л: комірка<LLVM::TL>;
    тип_ніщо: Тип;
    тип_невідома_комірка: Тип;
    тип_ц8: Тип;
    тип_ц16: Тип;
    тип_ц32: Тип;
    тип_ц64: Тип;
    тип_п8: Тип;
    тип_п16: Тип;
    тип_п32: Тип;
    тип_п64: Тип;
    тип_д32: Тип;
    тип_д64: Тип;
    шлях: комірка<список<комірка<Місцезнаходження>>>;
  }

  місцева дія створити_компілятор(Л: комірка<LLVM::TL>): комірка<Компілятор>;
  місцева дія визначити_нативний_тип(К: комірка<Компілятор>, назва: памʼять<п8>, л_тип: комірка<LLVM::Type>): Тип;
  місцева дія додати_до_шляху_компілятора(К: комірка<Компілятор>, місцезнаходження: комірка<Місцезнаходження>);
  місцева дія забрати_з_шляху_компілятора(К: комірка<Компілятор>);

  структура РезультатКомпіляціїТілаСекції {
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура РезультатКомпіляціїБлоку {
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура ІнформаціяВиконанняШаблону {
    шаблон: комірка<Шаблон>;
    аргументи: комірка<список<Значення>>;
  }

  місцева дія отримати_ЛТип(К: комірка<Компілятор>, тип: Тип): комірка<LLVM::Type>;
  місцева дія перевірити_тип(К: комірка<Компілятор>, тип: Тип, очікуваний_тип: Тип): логічне;
  місцева дія зробити_тип_з_дії(К: комірка<Компілятор>, д: комірка<Дія>): Тип;

  структура СпецОбʼєкт {
    назва: памʼять<п8>;
    дані: невідома_комірка;
    виконати_шаблон: (комірка<СпецОбʼєкт>, комірка<Компілятор>, комірка<Блок>, комірка<ІнформаціяВиконанняШаблону>, комірка<Середовище>, комірка<Місцезнаходження>, комірка<список<Значення>>) -> РезультатЗначення;
  }

  дія створити_пустий_спец_обʼєкт(): комірка<СпецОбʼєкт> {
    ціль спец_обʼєкт = виділити<СпецОбʼєкт>();
    спец_обʼєкт.назва = пусто;
    спец_обʼєкт.дані = пусто;
    спец_обʼєкт.виконати_шаблон = пусто;
    вернути спец_обʼєкт;
  }

  дія отримати_повну_назву(назва: памʼять<п8>, середовище: комірка<Середовище>): памʼять<п8> {
    ціль накопичувач_назви: памʼять<п8> = пусто;
    змінна останнє_середовище = середовище;
    поки середовище != пусто {
      якщо середовище._секція != пусто {
        якщо середовище._секція.назва != пусто {
        }
      }
      середовище = середовище.батьківське;
    }
  }

  місцева дія отримати_префікс_назви(середовище: комірка<Середовище>): памʼять<п8>;
}