взяти визначення розбирач;
взяти визначення LLVM;
взяти біб друк;

зовнішня дія strcmp(а: памʼять<п8>, б: памʼять<п8>): ц32;

структура карта_субʼєктів;
структура карта_комірок;

зовнішня дія отримати_з_карти_субʼєктів(карта: комірка<карта_субʼєктів>, назва: памʼять<п8>, комірка_типу: комірка<позитивне>, комірка_даних: комірка<невідома_комірка>): позитивне;
зовнішня дія змінити_в_карті_субʼєктів(карта: комірка<карта_субʼєктів>, назва: памʼять<п8>, тип: позитивне, дані: невідома_комірка);
зовнішня дія створити_карту_субʼєктів(): комірка<карта_субʼєктів>;

зовнішня дія отримати_з_карти_комірок(карта: комірка<карта_комірок>, назва: памʼять<п8>, комірка_значення: комірка<невідома_комірка>): позитивне;
зовнішня дія змінити_в_карті_комірок(карта: комірка<карта_комірок>, назва: памʼять<п8>, значення: невідома_комірка);
зовнішня дія створити_карту_комірок(): комірка<карта_комірок>;

структура список<Т> {
  дані: памʼять<Т>;
  довжина: позитивне;
  вмісткість: позитивне;
}

дія виділити_список<Т>(): комірка<список<Т>> {
  ціль с = виділити<список<Т>>();
  с.дані = пусто;
  с.довжина = 0;
  с.вмісткість = 0;
  вернути с;
}

дія додати_до_списку<Т>(с: комірка<список<Т>>, значення: Т) {
  якщо с.довжина == с.вмісткість {
    якщо с.вмісткість == 0 {
      с.дані = виділити<Т>(1);
    } інакше {
      с.дані = перевиділити<Т>(с.дані, с.вмісткість + 1);
    }
    с.вмісткість = с.вмісткість + 1;
  }
  с.дані[с.довжина] = значення;
  с.довжина = с.довжина + 1;
}

дія звільнити_список<Т>(с: комірка<список<Т>>) {
  звільнити(с.дані);
  звільнити(с);
}

секція ц {
  синонім ВидСубʼєктаНативнийТип = 1;
  синонім ВидСубʼєктаДія = 2;
  синонім ВидСубʼєктаЦіль = 3;
  синонім ВидСубʼєктаСтруктура = 4;
  синонім ВидСубʼєктаКонстанта = 5;
  синонім ВидСубʼєктаШаблон = 6;

  синонім ВидТипуНативний = 1;
  синонім ВидТипуСтруктура = 2;
  синонім ВидТипуДія = 3;
  синонім ВидТипуКомірка = 4;
  синонім ВидТипуШаблон = 5;

  структура Компілятор;
  структура ПомилкаКомпіляції;
  структура Середовище;
  структура Субʼєкт;
  структура Тип;
  структура Параметр;
  структура ОбʼєктНативногоТипу;
  структура ОбʼєктТипуДії;
  структура ОбʼєктДії;
  структура ОбʼєктСтруктури;
  структура ОбʼєктЦілі;
  структура ОбʼєктКонстанти;
  структура ОбʼєктТипуКомірка;
  структура ОбʼєктШаблону;

  структура Компілятор {
    глобальне_середовище: комірка<Середовище>;
    Л: комірка<ЛМодуль>;
    тип_ніщо: Тип;
    тип_комірка: Тип;
    тип_ц8: Тип;
    тип_ц16: Тип;
    тип_ц32: Тип;
    тип_ц64: Тип;
    тип_п8: Тип;
    тип_п16: Тип;
    тип_п32: Тип;
    тип_п64: Тип;
    тип_д32: Тип;
    тип_д64: Тип;
    константа_пусто: комірка<ОбʼєктКонстанти>;
  }

  структура ПомилкаКомпіляції {
    місцезнаходження: комірка<Місцезнаходження>;
    повідомлення: памʼять<п8>;
  }

  дія створити_помилку_компіляції(місцезнаходження: комірка<Місцезнаходження>, повідомлення: памʼять<п8>): комірка<ПомилкаКомпіляції> {
    ціль помилка_компіляції = виділити<ПомилкаКомпіляції>();
    помилка_компіляції.місцезнаходження = місцезнаходження;
    помилка_компіляції.повідомлення = повідомлення;
    вернути помилка_компіляції;
  }

  структура Середовище {
    батьківське: комірка<Середовище>;
    субʼєкти: комірка<карта_субʼєктів>;
  }

  структура Субʼєкт {
    вид: позитивне;
    дані: комірка<ОбʼєктНативногоТипу> | комірка<ОбʼєктДії> | комірка<ОбʼєктСтруктури> | комірка<ОбʼєктЦілі> | комірка<ОбʼєктКонстанти> | комірка<ОбʼєктШаблону>;
  }

  структура Тип {
    вид: позитивне;
    дані: комірка<ОбʼєктНативногоТипу> | комірка<ОбʼєктСтруктури> | комірка<ОбʼєктТипуДії> | комірка<ОбʼєктТипуКомірка> | комірка<ОбʼєктШаблону>;
  }

  структура Параметр {
    назва: памʼять<п8>;
    тип: Тип;
  }

  структура ОбʼєктНативногоТипу {
    назва: памʼять<п8>;
    л_тип: комірка<ЛТип>;
  }

  структура ОбʼєктТипуДії {
    параметри: комірка<список<комірка<Параметр>>>;
    тип_результату: Тип;
    л_тип_функції: комірка<ЛТипФункції>;
  }

  структура ОбʼєктДії {
    назва: памʼять<п8>;
    параметри: комірка<список<комірка<Параметр>>>;
    тип_результату: Тип;
    обʼєкт_типу_дії: комірка<ОбʼєктТипуДії>;
    л_функція: комірка<ЛФункція>;
  }

  структура ОбʼєктСтруктури {
    назва: памʼять<п8>;
    параметри: комірка<список<комірка<Параметр>>>;
    л_тип: комірка<ЛТип>;
  }

  структура ОбʼєктЦілі {
    назва: памʼять<п8>;
    тип: Тип;
    л_значення: комірка<ЛЗначення>;
  }

  структура ОбʼєктКонстанти {
    тип: Тип;
    л_значення: комірка<ЛЗначення>;
  }

  структура ОбʼєктТипуКомірка {
    тип_елемента: Тип;
    л_тип: комірка<ЛТип>;
  }

  структура ОбʼєктШаблону {
    зовнішнє_середовище: комірка<Середовище>;
    параметри: комірка<список<памʼять<п8>>>;
    асд_значення: комірка<АСДЗначення>;
  }

  дія створити_середовище(батьківське: комірка<Середовище>): комірка<Середовище> {
    ціль с = виділити<Середовище>();
    с.батьківське = батьківське;
    с.субʼєкти = створити_карту_субʼєктів();
    вернути с;
  }

  структура РезультатОтриманняЗСередовища {
    знайдено: логічне;
    субʼєкт: Субʼєкт;
  }

  дія отримати_з_середовища(середовище: комірка<Середовище>, назва: памʼять<п8>): РезультатОтриманняЗСередовища {
    змінна останнє_середовище = середовище;
    поки останнє_середовище != пусто {
      ціль вид: позитивне = 0;
      ціль дані: невідома_комірка = пусто;
      ціль знайдено = отримати_з_карти_субʼєктів(останнє_середовище.субʼєкти, назва, комірка(вид), комірка(дані));
      якщо знайдено == так {
        вернути РезультатОтриманняЗСередовища { так, Субʼєкт { вид, дані як комірка<ОбʼєктНативногоТипу> } };
      }
      останнє_середовище = останнє_середовище.батьківське;
    }
    вернути РезультатОтриманняЗСередовища { ні };
  }

  дія отримати_з_локального_середовища(середовище: комірка<Середовище>, назва: памʼять<п8>): РезультатОтриманняЗСередовища {
    ціль вид: позитивне = 0;
    ціль дані: невідома_комірка = пусто;
    ціль знайдено = отримати_з_карти_субʼєктів(середовище.субʼєкти, назва, комірка(вид), комірка(дані));
    якщо знайдено == так {
      вернути РезультатОтриманняЗСередовища { так, Субʼєкт { вид, дані як комірка<ОбʼєктНативногоТипу> } };
    }
    вернути РезультатОтриманняЗСередовища { ні };
  }

  дія змінити_в_середовищі(середовище: комірка<Середовище>, назва: памʼять<п8>, значення: Субʼєкт) {
    змінити_в_карті_субʼєктів(середовище.субʼєкти, назва, значення.вид, (значення.дані як комірка<ОбʼєктНативногоТипу>) як невідома_комірка);
  }

  дія визначити_нативний_тип(К: комірка<Компілятор>, назва: памʼять<п8>, л_тип: комірка<ЛТип>): Тип {
    ціль обʼєкт_нативного_типу = виділити<ОбʼєктНативногоТипу>();
    обʼєкт_нативного_типу.назва = назва;
    обʼєкт_нативного_типу.л_тип = л_тип;
    змінити_в_середовищі(К.глобальне_середовище, назва, Субʼєкт { ВидСубʼєктаНативнийТип, обʼєкт_нативного_типу });
    вернути Тип { ВидТипуНативний, обʼєкт_нативного_типу };
  }

  дія створити_компілятор(Л: комірка<ЛМодуль>): комірка<Компілятор> {
    ціль глобальне_середовище = створити_середовище(пусто);

    ціль К = виділити<Компілятор>();
    К.глобальне_середовище = глобальне_середовище;
    К.Л = Л;

    К.тип_ніщо = визначити_нативний_тип(К, ю8"ніщо", LLVM::void(К.Л));
    К.тип_комірка = визначити_нативний_тип(К, ю8"комірка", LLVM::pointer(К.Л));
    змінити_в_середовищі(К.глобальне_середовище, ю8"невідома_комірка", Субʼєкт { ВидСубʼєктаНативнийТип, К.тип_комірка.дані як комірка<ОбʼєктНативногоТипу> });
    К.тип_ц8 = визначити_нативний_тип(К, ю8"ц8", LLVM::і8(К.Л));
    К.тип_ц16 = визначити_нативний_тип(К, ю8"ц16", LLVM::і16(К.Л));
    К.тип_ц32 = визначити_нативний_тип(К, ю8"ц32", LLVM::і32(К.Л));
    К.тип_ц64 = визначити_нативний_тип(К, ю8"ц64", LLVM::і64(К.Л));
    К.тип_п8 = визначити_нативний_тип(К, ю8"п8", LLVM::і8(К.Л));
    К.тип_п16 = визначити_нативний_тип(К, ю8"п16", LLVM::і16(К.Л));
    К.тип_п32 = визначити_нативний_тип(К, ю8"п32", LLVM::і32(К.Л));
    К.тип_п64 = визначити_нативний_тип(К, ю8"п64", LLVM::і64(К.Л));
    К.тип_д32 = визначити_нативний_тип(К, ю8"д32", LLVM::f32(К.Л));
    К.тип_д64 = визначити_нативний_тип(К, ю8"д64", LLVM::f64(К.Л));

    К.константа_пусто = виділити<ОбʼєктКонстанти>();
    К.константа_пусто.тип = К.тип_комірка;
    К.константа_пусто.л_значення = LLVM::null(К.Л);
    змінити_в_середовищі(К.глобальне_середовище, ю8"пусто", Субʼєкт { ВидСубʼєктаКонстанта, К.константа_пусто });

    вернути К;
  }

  місцева дія отримати_ЛТип(К: комірка<Компілятор>, тип: Тип): комірка<ЛТип>;
  місцева дія перевірити_чи_тип_комірка(К: комірка<Компілятор>, тип: Тип): логічне;
  місцева дія перевірити_тип(К: комірка<Компілятор>, тип: Тип, очікуваний_тип: Тип): логічне;
  місцева дія перевірити_чи_тип_підтримує_add(К: комірка<Компілятор>, тип: Тип): логічне;
  місцева дія перевірити_чи_тип_підтримує_fadd(К: комірка<Компілятор>, тип: Тип): логічне;
  місцева дія перевірити_чи_тип_підтримує_sub(К: комірка<Компілятор>, тип: Тип): логічне;
  місцева дія перевірити_чи_тип_підтримує_fsub(К: комірка<Компілятор>, тип: Тип): логічне;

  дія тип_в_субʼєкт(К: комірка<Компілятор>, тип: Тип): Субʼєкт {
    якщо тип.вид == ВидТипуНативний {
      вернути Субʼєкт { ВидСубʼєктаНативнийТип, тип.дані як комірка<ОбʼєктНативногоТипу> };
    }
    якщо тип.вид == ВидТипуСтруктура {
      вернути Субʼєкт { ВидСубʼєктаСтруктура, тип.дані як комірка<ОбʼєктСтруктури> };
    }
//    якщо тип.вид == ВидТипуДія {
//      вернути Субʼєкт { ВидСубʼєктаДія, тип.дані як комірка<ОбʼєктТипуДії> };
//    }
    біб::друк_ю8(ю8"ОЙЙ!!! НЕ ВМІЮ ПЕРЕТВОРЮВАТИ ТИП В СУБʼЄКТ");
    біб::друк_позитивне(тип.вид);
  }
}

секція цк {
  синонім ВидТипуНативний = 1;
  синонім ВидТипуСтруктура = 2;
  синонім ВидТипуДія = 3;
  синонім ВидТипуКомірка = 4;

  синонім ВидОКТип = 1;
  синонім ВидОКДія = 2;
  синонім ВидОКЦіль = 3;
  синонім ВидОКШаблон = 4;
  синонім ВидОКСинонім = 5;
  синонім ВидОКСекція = 6;

  структура Параметр;

  структура ДаніТипуНативний;
  структура ДаніТипуСтруктура;
  структура ДаніТипуДія;
  структура ДаніТипуКомірка;
  структура Тип;
  структура Дія;
  структура Ціль;
  структура Шаблон;
  структура Синонім;
  структура Секція;

  структура ОбʼєктКомпіляції;
  структура ОбʼєктВиконання;
  структура Обʼєкт;

  структура Параметр {
    назва: памʼять<п8>;
    тип: Тип;
  }

  структура ДаніТипуНативний {
    л_тип: комірка<ЛТип>;
  }

  структура ДаніТипуСтруктура {
    л_тип: комірка<ЛТип>;
    параметри: комірка<список<Параметр>>;
  }

  структура ДаніТипуДія {
    л_тип_функції: комірка<ЛТипФункції>;
    параметри: комірка<список<Параметр>>;
    тип_результату: Тип;
  }

  структура ДаніТипуКомірка {
    л_тип: комірка<ЛТип>;
    тип_елемента: Тип;
  }

  структура Тип {
    вид: позитивне;
    дані: комірка<ДаніТипуНативний> | комірка<ДаніТипуСтруктура> | комірка<ДаніТипуДія> | комірка<ДаніТипуКомірка>;
  }

  структура Дія {
    назва: памʼять<п8>;
    параметри: комірка<список<Параметр>>;
    тип_результату: Тип;
    л_функція: комірка<ЛФункція>;
  }

  структура Ціль {
    тип: Тип;
    л_значення_alloca: комірка<ЛЗначення>;
  }

  структура Шаблон {
    зовнішнє_середовище: комірка<Середовище>;
    параметри: комірка<список<памʼять<п8>>>;
    асд_значення: комірка<АСДЗначення>;
  }

  структура Синонім {
    зовнішнє_середовище: комірка<Середовище>;
    асд_значення: комірка<АСДЗначення>;
  }

  структура Секція {
    субʼєкти: невідома_комірка;
  }

  структура ОбʼєктКомпіляції {
    вид: позитивне;
    дані: комірка<Тип> | комірка<Дія> | комірка<Ціль> | комірка<Шаблон> | комірка<Синонім> | комірка<Секція>;
  }

  структура ОбʼєктВиконання {
    тип: Тип;
    л_значення: комірка<ЛЗначення>;
    unloaded: логічне;
  }

  синонім ВидЗначенняОК = 1;
  синонім ВидЗначенняОВ = 2;

  структура Значення {
    вид: позитивне;
    к: ОбʼєктКомпіляції;
    в: ОбʼєктВиконання;
  }

  структура Блок {
    ret_value: комірка<ЛЗначення>;
    alloca_block: комірка<ЛБлок>;
    block: комірка<ЛБлок>;
    exit_block: комірка<ЛБлок>;
    function_exit_block: комірка<ЛБлок>;
  }

  структура ПомилкаКомпіляції {
    місцезнаходження: комірка<Місцезнаходження>;
    повідомлення: памʼять<п8>;
  }

  дія створити_помилку_компіляції(місцезнаходження: комірка<Місцезнаходження>, повідомлення: памʼять<п8>): комірка<ПомилкаКомпіляції> {
    ціль помилка_компіляції = виділити<ПомилкаКомпіляції>();
    помилка_компіляції.місцезнаходження = місцезнаходження;
    помилка_компіляції.повідомлення = повідомлення;
    вернути помилка_компіляції;
  }

  структура РезультатЗначення {
    значення: Значення;
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура РезультатЗначенняТип {
    тип: Тип;
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура РезультатЗначенняЗначення {
    в: ОбʼєктВиконання;
    помилка: комірка<ПомилкаКомпіляції>;
  }

  дія отримати_властивість(значення: Значення, блок: комірка<Блок>, назва_властивості: памʼять<п8>): РезультатЗначення;
  дія змінити_властивість(значення: Значення, блок: комірка<Блок>, назва_властивості: памʼять<п8>, значення_властивості: Значення): РезультатЗначення;
  дія виконати(значення: Значення, блок: комірка<Блок>, кількість_аргументів: позитивне, аргументи: памʼять<Значення>): РезультатЗначення;
  дія виконати_шаблон(значення: Значення, блок: комірка<Блок>, кількість_аргументів: позитивне, аргументи: памʼять<Значення>): РезультатЗначення;
  дія додати(значення: Значення, блок: комірка<Блок>, значення_аргумента: Значення): РезультатЗначення;

  структура Середовище {
    батьківське: комірка<Середовище>;
    субʼєкти: комірка<карта_субʼєктів>;
  }

  дія створити_середовище(батьківське: комірка<Середовище>): комірка<Середовище> {
    ціль с = виділити<Середовище>();
    с.батьківське = батьківське;
    с.субʼєкти = створити_карту_субʼєктів();
    вернути с;
  }

  структура РезультатОтриманняЗСередовища {
    знайдено: логічне;
    субʼєкт: ОбʼєктКомпіляції;
  }

  дія отримати_з_середовища(середовище: комірка<Середовище>, назва: памʼять<п8>): РезультатОтриманняЗСередовища {
    змінна останнє_середовище = середовище;
    поки останнє_середовище != пусто {
      ціль вид: позитивне = 0;
      ціль дані: невідома_комірка = пусто;
      ціль знайдено = отримати_з_карти_субʼєктів(останнє_середовище.субʼєкти, назва, комірка(вид), комірка(дані));
      якщо знайдено == так {
        вернути РезультатОтриманняЗСередовища { так, ОбʼєктКомпіляції { вид, дані як комірка<Тип> } };
      }
      останнє_середовище = останнє_середовище.батьківське;
    }
    вернути РезультатОтриманняЗСередовища { ні };
  }

  дія отримати_з_локального_середовища(середовище: комірка<Середовище>, назва: памʼять<п8>): РезультатОтриманняЗСередовища {
    ціль вид: позитивне = 0;
    ціль дані: невідома_комірка = пусто;
    ціль знайдено = отримати_з_карти_субʼєктів(середовище.субʼєкти, назва, комірка(вид), комірка(дані));
    якщо знайдено == так {
      вернути РезультатОтриманняЗСередовища { так, ОбʼєктКомпіляції { вид, дані як комірка<Тип> } };
    }
    вернути РезультатОтриманняЗСередовища { ні };
  }

  дія змінити_в_середовищі(середовище: комірка<Середовище>, назва: памʼять<п8>, значення: ОбʼєктКомпіляції) {
    змінити_в_карті_субʼєктів(середовище.субʼєкти, назва, значення.вид, (значення.дані як комірка<Тип>) як невідома_комірка);
  }

  структура Компілятор {
    глобальне_середовище: комірка<Середовище>;
    Л: комірка<ЛМодуль>;
    тип_ніщо: Тип;
    тип_невідома_комірка: Тип;
    тип_ц8: Тип;
    тип_ц16: Тип;
    тип_ц32: Тип;
    тип_ц64: Тип;
    тип_п8: Тип;
    тип_п16: Тип;
    тип_п32: Тип;
    тип_п64: Тип;
    тип_д32: Тип;
    тип_д64: Тип;
  }

  дія визначити_нативний_тип(К: комірка<Компілятор>, назва: памʼять<п8>, л_тип: комірка<ЛТип>): Тип {
    ціль тип = виділити<Тип>();
    ціль дані_типу = виділити<ДаніТипуНативний>();
    дані_типу.л_тип = л_тип;
    тип.вид = ВидТипуНативний;
    тип.дані = дані_типу;
    ціль обʼєкт_компіляції = ОбʼєктКомпіляції {};
    обʼєкт_компіляції.вид = ВидОКТип;
    обʼєкт_компіляції.дані = тип;
    змінити_в_середовищі(К.глобальне_середовище, назва, обʼєкт_компіляції);
    вернути вміст(тип);
  }

  дія створити_компілятор(Л: комірка<ЛМодуль>): комірка<Компілятор> {
    ціль глобальне_середовище = створити_середовище(пусто);

    ціль К = виділити<Компілятор>();
    К.глобальне_середовище = глобальне_середовище;
    К.Л = Л;

    К.тип_ніщо = визначити_нативний_тип(К, ю8"ніщо", LLVM::void(К.Л));
    К.тип_невідома_комірка = визначити_нативний_тип(К, ю8"невідома_комірка", LLVM::pointer(К.Л));
    К.тип_ц8 = визначити_нативний_тип(К, ю8"ц8", LLVM::і8(К.Л));
    К.тип_ц16 = визначити_нативний_тип(К, ю8"ц16", LLVM::і16(К.Л));
    К.тип_ц32 = визначити_нативний_тип(К, ю8"ц32", LLVM::і32(К.Л));
    К.тип_ц64 = визначити_нативний_тип(К, ю8"ц64", LLVM::і64(К.Л));
    К.тип_п8 = визначити_нативний_тип(К, ю8"п8", LLVM::і8(К.Л));
    К.тип_п16 = визначити_нативний_тип(К, ю8"п16", LLVM::і16(К.Л));
    К.тип_п32 = визначити_нативний_тип(К, ю8"п32", LLVM::і32(К.Л));
    К.тип_п64 = визначити_нативний_тип(К, ю8"п64", LLVM::і64(К.Л));
    К.тип_д32 = визначити_нативний_тип(К, ю8"д32", LLVM::f32(К.Л));
    К.тип_д64 = визначити_нативний_тип(К, ю8"д64", LLVM::f64(К.Л));

    вернути К;
  }

  структура РезультатКомпіляціїТілаСекції {
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура РезультатКомпіляціїБлоку {
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура ІнформаціяШаблону {
    шаблон: комірка<Шаблон>;
    кількість_аргументів: позитивне;
    аргументи: памʼять<Значення>;
  }

  дія отримати_ЛТип(К: комірка<Компілятор>, тип: Тип): комірка<ЛТип> {
    якщо тип.вид == ВидТипуНативний {
      ціль дані = тип.дані як комірка<ДаніТипуНативний>;
      вернути дані.л_тип;
    }
    якщо тип.вид == ВидТипуСтруктура {
      ціль дані = тип.дані як комірка<ДаніТипуСтруктура>;
      вернути дані.л_тип;
    }
    якщо тип.вид == ВидТипуДія {
      ціль дані = тип.дані як комірка<ДаніТипуДія>;
      вернути дані.л_тип_функції як комірка<ЛТип>;
    }
    біб::друк_ю8(ю8"ОЙЙ!!! НЕ ВМІЮ ОТРИМУВАТИ ЛТИП");
    біб::друк_позитивне(тип.вид);
  }

  дія перевірити_тип(К: комірка<Компілятор>, тип: Тип, очікуваний_тип: Тип): логічне {
    якщо тип.вид == очікуваний_тип.вид {
      ціль дані_типу = тип.дані як комірка<ДаніТипуНативний>;
      ціль дані_очікуваного_типу = очікуваний_тип.дані як комірка<ДаніТипуНативний>;
      якщо дані_типу.л_тип == дані_очікуваного_типу.л_тип {
        вернути так;
      }
    }
    вернути ні;
  }

  дія зробити_тип_з_дії(К: комірка<Компілятор>, д: комірка<Дія>): Тип {
    ціль тип = Тип {};
    ціль дані_типу = виділити<ДаніТипуДія>();
    дані_типу.л_тип_функції = LLVM::type_of_function(К.Л, д.л_функція);
    дані_типу.параметри = д.параметри;
    дані_типу.тип_результату = д.тип_результату;
    тип.вид = ВидТипуДія;
    тип.дані = дані_типу;
    вернути тип;
  }

  дія скомпілювати_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначення;
  дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначенняТип;
  дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, load: логічне): РезультатЗначенняЗначення;
  дія скомпілювати_створити_дію(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСтворитиДію>): РезультатЗначення;
  дія скомпілювати_створити_структуру(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСтворитиСтруктуру>): РезультатЗначення;
  дія скомпілювати_блок(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку;
  дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції;

  // потім: робити load тут
  дія скомпілювати_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначення {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      ціль назва = дані.ідентифікатор.значення;
      ціль обʼєкт_компіляції_з_середовища = отримати_з_середовища(середовище, назва);
      якщо обʼєкт_компіляції_з_середовища.знайдено == ні {
        ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Субʼєкт не визначено");
        вернути РезультатЗначення { Значення {}, створити_помилку_компіляції };
      }
      вернути РезультатЗначення { Значення { ВидЗначенняОК, к = обʼєкт_компіляції_з_середовища.субʼєкт }, пусто };
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      ціль результат_компіляції_обʼєкта_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.обʼєкт, ні);
      якщо результат_компіляції_обʼєкта_значення.помилка != пусто {
        вернути РезультатЗначення { Значення{}, результат_компіляції_обʼєкта_значення.помилка };
      }
      ціль тип = результат_компіляції_обʼєкта_значення.в.тип;
      якщо тип.вид != ВидТипуСтруктура {
        ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Тип не є структурою");
        вернути РезультатЗначення { Значення{}, помилка_компіляції };
      }
      ціль дані_типу_структури = тип.дані як комірка<ДаніТипуСтруктура>;
      ціль назва_властивості = дані.ідентифікатор.значення;
      змінна параметр: Параметр;
      змінна позиція_параметра: позитивне = 0;
      змінна параметр_знайдено: логічне = ні;
      змінна пх: позитивне = 0;
      поки пх < дані_типу_структури.параметри.довжина {
        якщо strcmp(дані_типу_структури.параметри.дані[пх].назва, назва_властивості) == 0 {
          параметр = дані_типу_структури.параметри.дані[пх];
          позиція_параметра = пх;
          параметр_знайдено = так;
        }
        пх = пх + 1;
      }
      якщо параметр_знайдено == ні {
        ціль помилка_компіляції = створити_помилку_компіляції(дані.ідентифікатор.місцезнаходження, ю8"Параметр не знайдено");
        вернути РезультатЗначення { Значення{}, помилка_компіляції };
      }
      ціль позиції_gep = виділити<комірка<ЛЗначення>>(2);
      позиції_gep[0] = LLVM::const_int32(К.Л, 0);
      позиції_gep[1] = LLVM::const_int32(К.Л, позиція_параметра);

      ціль л_значення_gep = LLVM::getelementptr(К.Л, блок.block, отримати_ЛТип(К, тип), результат_компіляції_обʼєкта_значення.в.л_значення, 2, позиції_gep);

      ціль обʼєкт_виконання = ОбʼєктВиконання { параметр.тип, л_значення = л_значення_gep, unloaded = так };

      вернути РезультатЗначення { Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, пусто };
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;

      ціль результат_компіляції_обʼєкта_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.обʼєкт, так);
      якщо результат_компіляції_обʼєкта_значення.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_обʼєкта_значення.помилка };
      }

      ціль тип = результат_компіляції_обʼєкта_значення.в.тип;
      ціль л_значення = результат_компіляції_обʼєкта_значення.в.л_значення;

      якщо тип.вид != ВидТипуДія {
        ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Тип не є дією");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }

      ціль дані_типу_дії = тип.дані як комірка<ДаніТипуДія>;

      якщо дані_типу_дії.параметри.довжина != дані.аргументи.довжина {
        ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Невірна кількість аргументів");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }

      ціль л_значення_аргументів = виділити<комірка<ЛЗначення>>(дані.аргументи.довжина);

      змінна ах: позитивне = 0;
      поки ах < дані.аргументи.довжина {
        ціль аргумент = дані.аргументи.елементи[ах];
        ціль результат_компіляції_значення_аргумента = скомпілювати_значення_як_значення(К, блок, середовище, аргумент, так);
        якщо результат_компіляції_значення_аргумента.помилка != пусто {
          вернути РезультатЗначення { Значення {}, результат_компіляції_значення_аргумента.помилка };
        }
        ціль тип_аргумента = результат_компіляції_значення_аргумента.в.тип;
        ціль л_значення_аргумента = результат_компіляції_значення_аргумента.в.л_значення;
        ціль параметр = дані_типу_дії.параметри.дані[ах];
        якщо перевірити_тип(К, тип_аргумента, параметр.тип) == ні {
          ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Невірний тип аргумента");
          вернути РезультатЗначення { Значення {}, помилка_компіляції };
        }
        л_значення_аргументів[ах] = л_значення_аргумента;
        ах = ах + 1;
      }

      ціль л_значення_call = LLVM::call(К.Л, блок.block, отримати_ЛТип(К, тип), л_значення, дані.аргументи.довжина, л_значення_аргументів);

      ціль обʼєкт_виконання = ОбʼєктВиконання { дані_типу_дії.тип_результату, л_значення_call, unloaded = ні };

      вернути РезультатЗначення { Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, пусто };
    }

    ціль помилка = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення");
    вернути РезультатЗначення { Значення {}, помилка };
  }

  дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначенняТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняТип { Тип {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОВ {
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням типу");
      вернути РезультатЗначенняТип { Тип {}, створити_помилку_компіляції };
    }
    ціль обʼєкт_компіляції = значення.к;
    якщо обʼєкт_компіляції.вид != ВидОКТип {
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є типом");
      вернути РезультатЗначенняТип { Тип {}, створити_помилку_компіляції };
    }
    ціль комірка_типу = обʼєкт_компіляції.дані як комірка<Тип>;
    ціль тип = вміст(комірка_типу);
    вернути РезультатЗначенняТип { тип, пусто };
  }

  дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, load: логічне): РезультатЗначенняЗначення {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОК {
      ціль ок = значення.к;
      якщо ок.вид == ВидОКЦіль {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль ц = ок.дані як комірка<Ціль>;
        якщо load == так {
          ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, ц.тип), ц.л_значення_alloca);
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, л_значення }, пусто };
        } інакше {
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, ц.л_значення_alloca }, пусто };
        }
      } інакше якщо ок.вид == ВидОКДія {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль д = ок.дані як комірка<Дія>;
        ціль тип = зробити_тип_з_дії(К, д);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { тип, д.л_функція як комірка<ЛЗначення> }, пусто };
      }
      біб::друк_позитивне(ок.вид);
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням");
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
    }
    якщо load == так {
      якщо значення.в.unloaded == так {
        ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, значення.в.тип), значення.в.л_значення);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { значення.в.тип, л_значення, unloaded = ні }, пусто };
      }
    }
    вернути РезультатЗначенняЗначення { значення.в, пусто };
  }

  дія скомпілювати_створити_дію(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСтворитиДію>): РезультатЗначення {
    якщо інформація_шаблону != пусто {
      якщо дані.тіло == пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Тіло дії не вказано");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }
    }

    ціль назва = дані.ідентифікатор.значення;
    ціль параметри = виділити_список<Параметр>();
    ціль тип_результату = К.тип_ніщо;

    ціль л_типи_параметрів = виділити<комірка<ЛТип>>(дані.кількість_параметрів);

    змінна пх: позитивне = 0;
    поки пх < дані.кількість_параметрів {
      ціль асд_параметр = дані.параметри[пх];
      ціль параметр = Параметр {};
      параметр.назва = асд_параметр.ідентифікатор.значення;
      ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, пусто, середовище, асд_параметр.тип);
      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_типу.помилка };
      }
      параметр.тип = результат_компіляції_типу.тип;
      додати_до_списку<Параметр>(параметри, параметр);
      л_типи_параметрів[пх] = отримати_ЛТип(К, результат_компіляції_типу.тип);
      пх = пх + 1;
    }

    якщо дані.тип_результату != пусто {
      ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, пусто, середовище, дані.тип_результату);
      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_типу.помилка };
      }
      тип_результату = результат_компіляції_типу.тип;
    }

    змінна лінкування: позитивне = 0;
    якщо дані.видимість == АСДВидимістьЗовнішня {
      лінкування = LLVM::LINKAGE_EXTERNAL;
    } інакше якщо дані.видимість == АСДВидимістьМісцева {
      лінкування = LLVM::LINKAGE_DSO_LOCAL;
    } інакше {
      лінкування = LLVM::LINKAGE_INTERNAL;
    }

    якщо strcmp(назва, ю8"main") == 0 {
      лінкування = LLVM::LINKAGE_EXTERNAL;
    }

    ціль д = виділити<Дія>();
    д.назва = назва;
    д.параметри = параметри;
    д.тип_результату = тип_результату;
    д.л_функція = LLVM::function(К.Л, лінкування, назва, отримати_ЛТип(К, тип_результату), параметри.довжина, л_типи_параметрів, ні);

    ціль дтд = виділити<ДаніТипуДія>();
    дтд.л_тип_функції = LLVM::type_of_function(К.Л, д.л_функція);
    дтд.параметри = параметри;
    дтд.тип_результату = тип_результату;

    ціль дт = Тип {};
    дт.вид = ВидТипуДія;
    дт.дані = дтд;

    ціль значення = Значення {};
    значення.вид = ВидЗначенняОВ;
    значення.в = ОбʼєктВиконання { дт, д.л_функція як комірка<ЛЗначення> };

    змінити_в_середовищі(середовище, назва, ОбʼєктКомпіляції { ВидОКДія, д });

    якщо інформація_шаблону != пусто {
      // потім: обробляти шаблон
    }

    якщо дані.тіло != пусто {
      ціль середовище_дії = створити_середовище(середовище);

      ціль блок = виділити<Блок>();
      блок.ret_value = пусто;
      блок.alloca_block = LLVM::block(К.Л, д.л_функція, ю8"alloca");
      блок.block = LLVM::block(К.Л, д.л_функція, ю8"entry");
      блок.exit_block = LLVM::block(К.Л, д.л_функція, ю8"exit");
      блок.function_exit_block = блок.exit_block;

      якщо перевірити_тип(К, д.тип_результату, К.тип_ніщо) == ні {
        блок.ret_value = LLVM::alloca(К.Л, блок.alloca_block, ю8"return", отримати_ЛТип(К, д.тип_результату));
      }

      змінна пх: позитивне = 0;
      поки пх < д.параметри.довжина {
        ціль параметр = д.параметри.дані[пх];
        ціль arg = LLVM::function_arg(К.Л, д.л_функція, пх);
        ціль л_значення = LLVM::alloca(К.Л, блок.alloca_block, параметр.назва, отримати_ЛТип(К, параметр.тип));
        LLVM::store(К.Л, блок.alloca_block, arg, л_значення);
        ціль ц = виділити<Ціль>();
        ц.тип = параметр.тип;
        ц.л_значення_alloca = л_значення;
        змінити_в_середовищі(середовище_дії, параметр.назва, ОбʼєктКомпіляції { ВидОКЦіль, ц });
        пх = пх + 1;
      }

      ціль результат_компіляції_блоку = скомпілювати_блок(К, блок, середовище_дії, дані.тіло);
      якщо результат_компіляції_блоку.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_блоку.помилка };
      }

      LLVM::br(К.Л, блок.alloca_block, блок.block);
      якщо блок.ret_value == пусто {
        LLVM::ret(К.Л, блок.exit_block, пусто);
      } інакше {
        ціль л_значення = LLVM::load(К.Л, блок.exit_block, отримати_ЛТип(К, д.тип_результату), блок.ret_value);
        LLVM::ret(К.Л, блок.exit_block, л_значення);
      }
    }

    вернути РезультатЗначення { значення, пусто };
  }

  дія скомпілювати_створити_структуру(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСтворитиСтруктуру>): РезультатЗначення {
    якщо інформація_шаблону != пусто {
      якщо дані.кількість_параметрів == 0 {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Кількість параметрів не вказано");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }
    }

    ціль назва = дані.ідентифікатор.значення;

    змінна дані_типу_структури: комірка<ДаніТипуСтруктура> = пусто;

    ціль результат_отримання_з_середовища = отримати_з_локального_середовища(середовище, назва);
    якщо результат_отримання_з_середовища.знайдено == так {
      ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
      якщо субʼєкт.вид == ВидОКТип {
        ціль тип = субʼєкт.дані як комірка<Тип>;
        якщо тип.вид == ВидТипуСтруктура {
          дані_типу_структури = тип.дані як комірка<ДаніТипуСтруктура>;
          якщо дані_типу_структури.параметри.довжина != 0 {
            ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Структура вже визначена");
            вернути РезультатЗначення { Значення {}, помилка_компіляції };
          }
        } інакше {
          ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт вже визначено");
          вернути РезультатЗначення { Значення {}, помилка_компіляції };
        }
      } інакше {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт вже визначено");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }
    } інакше {
      дані_типу_структури = виділити<ДаніТипуСтруктура>();
      дані_типу_структури.л_тип = LLVM::struct(К.Л, назва);
      дані_типу_структури.параметри = виділити_список<Параметр>();

      ціль тип = виділити<Тип>();
      тип.вид = ВидТипуСтруктура;
      тип.дані = дані_типу_структури;

      змінити_в_середовищі(середовище, назва, ОбʼєктКомпіляції { ВидОКТип, тип });

      якщо інформація_шаблону != пусто {
        // потім: обробляти шаблон
      }
    }

    ціль л_типи_параметрів = виділити<комірка<ЛТип>>(дані.кількість_параметрів);

    змінна пх: позитивне = 0;
    поки пх < дані.кількість_параметрів {
      ціль асд_параметр = дані.параметри[пх];
      ціль параметр = Параметр {};
      параметр.назва = асд_параметр.ідентифікатор.значення;
      ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, пусто, середовище, асд_параметр.тип);
      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_типу.помилка };
      }
      параметр.тип = результат_компіляції_типу.тип;
      додати_до_списку<Параметр>(дані_типу_структури.параметри, параметр);
      л_типи_параметрів[пх] = отримати_ЛТип(К, результат_компіляції_типу.тип);
      пх = пх + 1;
    }

    якщо дані.кількість_параметрів != 0 {
      LLVM::struct_set_fields(К.Л, дані_типу_структури.л_тип, дані.кількість_параметрів, л_типи_параметрів);
    }

    ціль тип = виділити<Тип>();
    тип.вид = ВидТипуСтруктура;
    тип.дані = дані_типу_структури;
    ціль обʼєкт_компіляції = ОбʼєктКомпіляції { ВидОКТип, тип };

    вернути РезультатЗначення { Значення { ВидЗначенняОК, к = обʼєкт_компіляції }, пусто };
  }

  дія скомпілювати_блок(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидСтворитиЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиЦіль>;
        ціль назва = дані.ідентифікатор.значення;

        ціль ц = виділити<Ціль>();

        якщо дані.тип == пусто {
          якщо дані.значення == пусто {
            ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вказано тип цілі");
            вернути РезультатКомпіляціїБлоку { помилка_компіляції };
          } інакше {
            ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.значення, так);
            якщо результат_компіляції_значення.помилка != пусто {
              вернути РезультатКомпіляціїБлоку { результат_компіляції_значення.помилка };
            }
            ціль тип = результат_компіляції_значення.в.тип;
            якщо тип.вид == ВидТипуНативний {
              якщо перевірити_тип(К, тип, К.тип_ніщо) == так {
                ціль помилка_компіляції = створити_помилку_компіляції(дані.значення.місцезнаходження, ю8"Тип не визначено");
                вернути РезультатКомпіляціїБлоку { помилка_компіляції };
              }
            }
            ц.тип = тип;
            ц.л_значення_alloca = LLVM::alloca(К.Л, блок.alloca_block, назва, отримати_ЛТип(К, тип));

            LLVM::store(К.Л, блок.block, результат_компіляції_значення.в.л_значення, ц.л_значення_alloca);
          }
        } інакше {
          ціль результат_компіляції_як_типу = скомпілювати_значення_як_тип(К, блок, середовище, дані.тип);
          якщо результат_компіляції_як_типу.помилка != пусто {
            вернути РезультатКомпіляціїБлоку { результат_компіляції_як_типу.помилка };
          }
          ціль тип = результат_компіляції_як_типу.тип;
          ц.тип = тип;
          ц.л_значення_alloca = LLVM::alloca(К.Л, блок.alloca_block, назва, отримати_ЛТип(К, тип));

          якщо дані.значення != пусто {
            ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.значення, так);
            якщо результат_компіляції_значення.помилка != пусто {
              вернути РезультатКомпіляціїБлоку { результат_компіляції_значення.помилка };
            }
            якщо перевірити_тип(К, результат_компіляції_значення.в.тип, тип) == ні {
              ціль помилка_компіляції = створити_помилку_компіляції(дані.значення.місцезнаходження, ю8"Невідповідні типи");
              вернути РезультатКомпіляціїБлоку { помилка_компіляції };
            }
            LLVM::store(К.Л, блок.block, результат_компіляції_значення.в.л_значення, ц.л_значення_alloca);
          }
        }

        ціль обʼєкт_компіляції = ОбʼєктКомпіляції { ВидОКЦіль, ц };

        змінити_в_середовищі(середовище, назва, обʼєкт_компіляції);
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;

        ціль результат_компіляції_обʼєкта_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.обʼєкт, ні);
        якщо результат_компіляції_обʼєкта_значення.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_обʼєкта_значення.помилка };
        }
        ціль тип = результат_компіляції_обʼєкта_значення.в.тип;
        якщо тип.вид != ВидТипуСтруктура {
          ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Тип не є структурою");
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
        ціль дані_типу_структури = тип.дані як комірка<ДаніТипуСтруктура>;
        ціль назва_властивості = дані.ідентифікатор.значення;
        змінна параметр: Параметр;
        змінна позиція_параметра: позитивне = 0;
        змінна параметр_знайдено: логічне = ні;
        змінна пх: позитивне = 0;
        поки пх < дані_типу_структури.параметри.довжина {
          якщо strcmp(дані_типу_структури.параметри.дані[пх].назва, назва_властивості) == 0 {
            параметр = дані_типу_структури.параметри.дані[пх];
            позиція_параметра = пх;
            параметр_знайдено = так;
          }
          пх = пх + 1;
        }
        якщо параметр_знайдено == ні {
          ціль помилка_компіляції = створити_помилку_компіляції(дані.ідентифікатор.місцезнаходження, ю8"Параметр не знайдено");
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
        ціль позиції_gep = виділити<комірка<ЛЗначення>>(2);
        позиції_gep[0] = LLVM::const_int32(К.Л, 0);
        позиції_gep[1] = LLVM::const_int32(К.Л, позиція_параметра);

        ціль л_значення_gep = LLVM::getelementptr(К.Л, блок.block, отримати_ЛТип(К, тип), результат_компіляції_обʼєкта_значення.в.л_значення, 2, позиції_gep);

        ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.значення, так);
        якщо результат_компіляції_значення.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_значення.помилка };
        }

        якщо перевірити_тип(К, результат_компіляції_значення.в.тип, параметр.тип) == ні {
          ціль помилка_компіляції = створити_помилку_компіляції(дані.значення.місцезнаходження, ю8"Невідповідні типи");
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }

        LLVM::store(К.Л, блок.block, результат_компіляції_значення.в.л_значення, л_значення_gep);
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль результат_компіляції_виконання = скомпілювати_значення_як_значення(К, блок, середовище, асд_значення, так);
        якщо результат_компіляції_виконання.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_виконання.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль назва = дані.ідентифікатор.значення;

        ціль результат_отримання_з_середовища = отримати_з_середовища(середовище, назва);
        якщо результат_отримання_з_середовища.знайдено == ні {
          ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Субʼєкт не визначено");
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        } інакше {
          ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
          якщо субʼєкт.вид == ВидОКЦіль {
            ціль ц = субʼєкт.дані як комірка<Ціль>;
            ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.значення, так);
            якщо результат_компіляції_значення.помилка != пусто {
              вернути РезультатКомпіляціїБлоку { результат_компіляції_значення.помилка };
            }
            якщо перевірити_тип(К, результат_компіляції_значення.в.тип, ц.тип) == ні {
              ціль помилка_компіляції = створити_помилку_компіляції(дані.значення.місцезнаходження, ю8"Невідповідні типи");
              вернути РезультатКомпіляціїБлоку { помилка_компіляції };
            }
            LLVM::store(К.Л, блок.block, результат_компіляції_значення.в.л_значення, ц.л_значення_alloca);
          } інакше {
            ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Субʼєкт не є ціллю");
            вернути РезультатКомпіляціїБлоку { помилка_компіляції };
          }
        }
      }

      х = х + 1;
    }
    LLVM::br(К.Л, блок.block, блок.exit_block);
    вернути РезультатКомпіляціїБлоку { пусто };
  }

  дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидСтворитиДію {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиДію>;
        ціль результат_створення_дії = скомпілювати_створити_дію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо результат_створення_дії.помилка != пусто {
          вернути РезультатКомпіляціїТілаСекції { результат_створення_дії.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидСтворитиСтруктуру {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСтруктуру>;
        ціль результат_створення_структури = скомпілювати_створити_структуру(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо результат_створення_структури.помилка != пусто {
          вернути РезультатКомпіляціїТілаСекції { результат_створення_структури.помилка };
        }
      }

      х = х + 1;
    }
    вернути РезультатКомпіляціїТілаСекції { пусто };
  }
}