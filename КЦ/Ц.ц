взяти визначення Ц;

зовнішня дія strcmp(а: памʼять<п8>, б: памʼять<п8>): ц32;

секція ц {
  структура РезультатКомпіляціїЗначенняЯкЗначення {
    тип: Тип;
    л_значення: комірка<ЛЗначення>;
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура РезультатКомпіляціїЗначенняЯкТипу {
    тип: Тип;
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура РезультатКомпіляціїТілаДії {
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура РезультатКомпіляціїТілаСекції {
    помилка: комірка<ПомилкаКомпіляції>;
  }

  дія скомпілювати_асд_значення_як_значення(К: комірка<Компілятор>, л_блок: комірка<ЛБлок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, load: логічне): РезультатКомпіляціїЗначенняЯкЗначення {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      ціль результат_отримання_з_середовища = отримати_з_середовища(середовище, дані.ідентифікатор.значення);
      якщо результат_отримання_з_середовища.знайдено == ні {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт не визначено");
        вернути РезультатКомпіляціїЗначенняЯкЗначення { Тип {}, пусто, помилка_компіляції };
      } інакше {
        ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
        якщо субʼєкт.вид == ВидСубʼєктаЦіль {
          ціль обʼєкт_цілі = субʼєкт.дані як комірка<ОбʼєктЦілі>;
          якщо load == так {
            ціль л_значення = л::load(К.Л, л_блок, отримати_ЛТип(обʼєкт_цілі.тип), обʼєкт_цілі.л_значення);
            вернути РезультатКомпіляціїЗначенняЯкЗначення { обʼєкт_цілі.тип, л_значення, пусто };
          } інакше {
            вернути РезультатКомпіляціїЗначенняЯкЗначення { обʼєкт_цілі.тип, обʼєкт_цілі.л_значення, пусто };
          }
        }
      }
    }
    ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати значення як значення");
    вернути РезультатКомпіляціїЗначенняЯкЗначення { Тип {}, пусто, помилка_компіляції };
  }

  дія скомпілювати_асд_значення_як_тип(К: комірка<Компілятор>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатКомпіляціїЗначенняЯкТипу {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      ціль результат_отримання_з_середовища = отримати_з_середовища(середовище, дані.ідентифікатор.значення);
      якщо результат_отримання_з_середовища.знайдено == ні {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт не визначено");
        вернути РезультатКомпіляціїЗначенняЯкТипу { Тип {}, помилка_компіляції };
      } інакше {
        ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
        якщо субʼєкт.вид == ВидСубʼєктаНативнийТип {
          ціль обʼєкт_нативного_типу = субʼєкт.дані як комірка<ОбʼєктНативногоТипу>;
          вернути РезультатКомпіляціїЗначенняЯкТипу { Тип { ВидТипуНативний, обʼєкт_нативного_типу }, пусто };
        } інакше якщо субʼєкт.вид == ВидСубʼєктаСтруктура {
          ціль обʼєкт_структури = субʼєкт.дані як комірка<ОбʼєктСтруктури>;
          вернути РезультатКомпіляціїЗначенняЯкТипу { Тип { ВидТипуСтруктура, обʼєкт_структури }, пусто };
        }
      }
    }
    ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати значення як тип");
    вернути РезультатКомпіляціїЗначенняЯкТипу { Тип {}, помилка_компіляції };
  }

  дія скомпілювати_блок(К: комірка<Компілятор>, обʼєкт_дії: комірка<ОбʼєктДії>, середовище: комірка<Середовище>, л_блок_алокацій: комірка<ЛБлок>, л_блок: комірка<ЛБлок>, вихідний_л_блок: комірка<ЛБлок>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаДії {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
      якщо асд_значення.вид == АСДВидСтворитиЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиЦіль>;
        ціль назва = дані.ідентифікатор.значення;

        ціль обʼєкт_цілі = виділити<ОбʼєктЦілі>();
        обʼєкт_цілі.назва = назва;

        якщо дані.тип == пусто {
          якщо дані.значення == пусто {
            ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вказано тип цілі");
            вернути РезультатКомпіляціїТілаДії { помилка_компіляції };
          } інакше {
            // потім: скомпілювати значення і визначити тип
            ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вказано тип цілі");
            вернути РезультатКомпіляціїТілаДії { помилка_компіляції };
          }
        } інакше {
          ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище, дані.тип);
          якщо результат_компіляції_як_типу.помилка != пусто {
            вернути РезультатКомпіляціїТілаДії { результат_компіляції_як_типу.помилка };
          }
          ціль тип = результат_компіляції_як_типу.тип;
          обʼєкт_цілі.тип = тип;
          обʼєкт_цілі.л_значення = л::alloca(К.Л, л_блок_алокацій, назва, отримати_ЛТип(тип));

          якщо дані.значення != пусто {
            // потім: скомпілювати значення і перевірити тип
          }
        }

        змінити_в_середовищі(середовище, назва, Субʼєкт { ВидСубʼєктаЦіль, обʼєкт_цілі });
      } інакше якщо асд_значення.вид == АСДВидВернути {
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль назва = дані.ідентифікатор.значення;
        ціль результат_отримання_з_середовища = отримати_з_середовища(середовище, назва);
        якщо результат_отримання_з_середовища.знайдено == ні {
          ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт не визначено");
          вернути РезультатКомпіляціїТілаДії { помилка_компіляції };
        } інакше {
          ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
          якщо субʼєкт.вид == ВидСубʼєктаЦіль {
            ціль обʼєкт_цілі = субʼєкт.дані як комірка<ОбʼєктЦілі>;

            // потім: перевірити типи

            ціль результат_компіляції_як_значення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.значення, так);
            якщо результат_компіляції_як_значення.помилка != пусто {
              вернути РезультатКомпіляціїТілаДії { результат_компіляції_як_значення.помилка };
            }

            л::store(К.Л, л_блок, результат_компіляції_як_значення.л_значення, обʼєкт_цілі.л_значення);
          }
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
        ціль результат_компіляції_обʼєкта_як_значення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.обʼєкт, ні);
        якщо результат_компіляції_обʼєкта_як_значення.помилка != пусто {
          вернути РезультатКомпіляціїТілаДії { результат_компіляції_обʼєкта_як_значення.помилка };
        }
        ціль тип = результат_компіляції_обʼєкта_як_значення.тип;
        якщо тип.вид != ВидТипуСтруктура {
          ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Обʼєкт не є структурою");
          вернути РезультатКомпіляціїТілаДії { помилка_компіляції };
        }
        ціль обʼєкт_структури = тип.дані як комірка<ОбʼєктСтруктури>;
        ціль назва = дані.ідентифікатор.значення;
        змінна параметр: комірка<Параметр> = пусто;
        змінна позиція_параметра: позитивне = 0;
        змінна пх: позитивне = 0;
        поки пх < обʼєкт_структури.параметри.довжина {
          якщо strcmp(обʼєкт_структури.параметри.дані[пх].назва, назва) == 0 {
            параметр = обʼєкт_структури.параметри.дані[пх];
            позиція_параметра = пх;
          }
          пх = пх + 1;
        }
        якщо параметр == пусто {
          ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Параметр не знайдено");
          вернути РезультатКомпіляціїТілаДії { помилка_компіляції };
        }
        ціль позиції_gep = виділити_список<комірка<ЛЗначення>>();
        // відкласти звільнити_список<комірка<ЛЗначення>>(позиції_gep);
        додати_до_списку<комірка<ЛЗначення>>(позиції_gep, л::const_int32(К.Л, 0));
        додати_до_списку<комірка<ЛЗначення>>(позиції_gep, л::const_int32(К.Л, позиція_параметра));
        ціль л_значення_gep = л::getelementptr(К.Л, л_блок, отримати_ЛТип(тип), результат_компіляції_обʼєкта_як_значення.л_значення, позиції_gep.довжина, позиції_gep.дані);

        ціль результат_компіляції_значення_як_значення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.значення, так);
        якщо результат_компіляції_значення_як_значення.помилка != пусто {
          вернути РезультатКомпіляціїТілаДії { результат_компіляції_значення_як_значення.помилка };
        }

        л::store(К.Л, л_блок, результат_компіляції_значення_як_значення.л_значення, л_значення_gep);
      } інакше {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати тіло дії");
        вернути РезультатКомпіляціїТілаДії { помилка_компіляції };
      }
      х = х + 1;
    }
    л::br(К.Л, л_блок, вихідний_л_блок);
    вернути РезультатКомпіляціїТілаДії { пусто };
  }

  дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
//      біб::вивести_позитивне(х);
//      біб::вивести_ю8(ю8" ");
//      біб::друк_позитивне(асд_значення.вид);
      якщо асд_значення.вид == АСДВидСтворитиДію {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиДію>;

        ціль обʼєкт_дії = виділити<ОбʼєктДії>();
        обʼєкт_дії.назва = дані.ідентифікатор.значення;
        обʼєкт_дії.параметри = виділити_список<комірка<Параметр>>();

        ціль список_лтипів_параметрів = виділити_список<комірка<ЛТип>>();
//        відкласти звільнити_список<комірка<ЛТип>>(список_лтипів_параметрів);

        змінна пх: позитивне = 0;
        поки пх < дані.кількість_параметрів {
          ціль асд_параметр = дані.параметри[пх];
          ціль параметр = виділити<Параметр>();
          параметр.назва = асд_параметр.ідентифікатор.значення;
          ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище_секції, асд_параметр.тип);
          якщо результат_компіляції_як_типу.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { результат_компіляції_як_типу.помилка };
          }
          параметр.тип = результат_компіляції_як_типу.тип;
          додати_до_списку<комірка<Параметр>>(обʼєкт_дії.параметри, параметр);
          додати_до_списку<комірка<ЛТип>>(список_лтипів_параметрів, отримати_ЛТип(результат_компіляції_як_типу.тип));
          пх = пх + 1;
        }

        якщо дані.тип_результату == пусто {
          обʼєкт_дії.тип_результату = К.тип_ніщо;
        } інакше {
          ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище_секції, дані.тип_результату);
          якщо результат_компіляції_як_типу.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { результат_компіляції_як_типу.помилка };
          }
          обʼєкт_дії.тип_результату = результат_компіляції_як_типу.тип;
        }

        ціль лф = л::створити_функцію(К.Л, обʼєкт_дії.назва, отримати_ЛТип(обʼєкт_дії.тип_результату), список_лтипів_параметрів.довжина, список_лтипів_параметрів.дані, ні);
        обʼєкт_дії.л_функція = лф;

        змінити_в_середовищі(середовище_секції, обʼєкт_дії.назва, Субʼєкт { ВидСубʼєктаДія, обʼєкт_дії });

        якщо дані.тіло != пусто {
          ціль середовище_дії = створити_середовище(середовище_секції);

          ціль л_блок_алокацій = л::створити_блок(К.Л, лф, ю8"alloca");
          ціль л_блок = л::створити_блок(К.Л, лф, ю8"entry");
          ціль вихідний_л_блок = л::створити_блок(К.Л, лф, ю8"exit");

          // потім: аргументи

          ціль результат_компіляції_тіла_дії = скомпілювати_блок(К, обʼєкт_дії, середовище_дії, л_блок_алокацій, л_блок, вихідний_л_блок, дані.тіло);
          якщо результат_компіляції_тіла_дії.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { результат_компіляції_тіла_дії.помилка };
          }

          л::br(К.Л, л_блок_алокацій, л_блок);
          л::ret(К.Л, вихідний_л_блок, пусто);
        }
      } інакше якщо асд_значення.вид == АСДВидСтворитиСтруктуру {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСтруктуру>;
        ціль назва = дані.ідентифікатор.значення;

        ціль обʼєкт_структури = виділити<ОбʼєктСтруктури>();
        обʼєкт_структури.назва = назва;
        обʼєкт_структури.параметри = виділити_список<комірка<Параметр>>();
        обʼєкт_структури.л_тип = л::struct(К.Л, назва);

        змінити_в_середовищі(середовище_секції, назва, Субʼєкт { ВидСубʼєктаСтруктура, обʼєкт_структури });

        ціль список_лтипів_параметрів = виділити_список<комірка<ЛТип>>();
        // відкласти звільнити_список<комірка<ЛТип>>(список_лтипів_параметрів);

        змінна пх: позитивне = 0;
        поки пх < дані.кількість_параметрів {
          ціль асд_параметр = дані.параметри[пх];
          ціль параметр = виділити<Параметр>();
          параметр.назва = асд_параметр.ідентифікатор.значення;
          ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище_секції, асд_параметр.тип);
          якщо результат_компіляції_як_типу.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { результат_компіляції_як_типу.помилка };
          }
          параметр.тип = результат_компіляції_як_типу.тип;
          додати_до_списку<комірка<Параметр>>(обʼєкт_структури.параметри, параметр);
          додати_до_списку<комірка<ЛТип>>(список_лтипів_параметрів, отримати_ЛТип(результат_компіляції_як_типу.тип));
          пх = пх + 1;
        }

        л::struct_set_fields(К.Л, обʼєкт_структури.л_тип, список_лтипів_параметрів.довжина, список_лтипів_параметрів.дані);
      } інакше {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати тіло секції");
        вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
      }
      х = х + 1;
    }

    вернути РезультатКомпіляціїТілаСекції { пусто };
  }
}

структура ПомилкаКомпіляціїЦілі {
  місцезнаходження: комірка<Місцезнаходження>;
  повідомлення: памʼять<п8>;
}

зовнішня дія скомпілювати_ціль_в_ll(Л: комірка<ЛМодуль>, текст_коду: комірка<ТекстКоду>): комірка<ПомилкаКомпіляціїЦілі> {
  ціль результат_розбору_цілі = розібрати_ціль(текст_коду);
  якщо результат_розбору_цілі.успіх == ні {
    ціль помилка_компіляції_цілі = виділити<ПомилкаКомпіляціїЦілі>();
    помилка_компіляції_цілі.місцезнаходження = результат_розбору_цілі.помилка.місцезнаходження;
    помилка_компіляції_цілі.повідомлення = результат_розбору_цілі.помилка.повідомлення;
    вернути помилка_компіляції_цілі;
  }
  ціль К = ц::створити_компілятор(Л);
  ціль початкове_середовище = ц::створити_середовище(К.глобальне_середовище);
  ціль результат_компіляції_тіла_секції = ц::скомпілювати_тіло_секції(К, початкове_середовище, результат_розбору_цілі.тіло);
  якщо результат_компіляції_тіла_секції.помилка != пусто {
    ціль помилка_компіляції_цілі = виділити<ПомилкаКомпіляціїЦілі>();
    помилка_компіляції_цілі.місцезнаходження = результат_компіляції_тіла_секції.помилка.місцезнаходження;
    помилка_компіляції_цілі.повідомлення = результат_компіляції_тіла_секції.помилка.повідомлення;
    вернути помилка_компіляції_цілі;
  }
  вернути пусто;
}