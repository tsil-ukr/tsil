взяти визначення Ц;
взяти визначення К;

структура ПомилкаКомпіляціїЦілі {
  місцезнаходження: комірка<Місцезнаходження>;
  повідомлення: памʼять<п8>;
  довжина_шляху: позитивне;
  шлях: памʼять<комірка<Місцезнаходження>>;
}

секція цк {
  дія дія_спец_обʼєкта_комірка_виконати_шаблон(я: комірка<СпецОбʼєкт>, К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, аргументи: комірка<список<Значення>>): РезультатЗначення {
    якщо аргументи.довжина != 1 {
      ціль помилка = цк::створити_помилку_компіляції(місцезнаходження, ю8"Очікується один аргумент");
      вернути РезультатЗначення { Значення {}, помилка };
    }

    ціль значення_аргументу = аргументи.дані[0];
    якщо значення_аргументу.вид != ВидЗначенняОК {
      ціль помилка = цк::створити_помилку_компіляції(місцезнаходження, ю8"Аргумент не є обʼєктом");
      вернути РезультатЗначення { Значення {}, помилка };
    }

    ціль ок = значення_аргументу.к;
    якщо ок.вид != ВидОКТип {
      ціль помилка = цк::створити_помилку_компіляції(місцезнаходження, ю8"Тип не є обʼєктом");
      вернути РезультатЗначення { Значення {}, помилка };
    }

    ціль тип = ок.дані як комірка<Тип>;

    ціль дані_типу_комірка = виділити<ДаніТипуКомірка>();
    дані_типу_комірка.llvm_type = LLVM::pointer(К.Л);
    дані_типу_комірка.тип_елемента = вміст(тип);

    ціль тип_комірки = виділити<Тип>();
    тип_комірки.вид = ВидТипуКомірка;
    тип_комірки.дані = дані_типу_комірка;

    ціль ок_типу = ОбʼєктКомпіляції { ВидОКТип, тип_комірки };

    вернути РезультатЗначення { Значення { ВидЗначенняОК, к = ок_типу }, пусто };
  }

  місцева дія створити_компілятор(Л: комірка<LLVM::TL>): комірка<Компілятор> {
    ціль глобальне_середовище = створити_середовище(пусто);

    ціль К = виділити<Компілятор>();
    К.глобальне_середовище = глобальне_середовище;
    К.Л = Л;

    К.тип_ніщо = визначити_нативний_тип(К, ю8"ніщо", LLVM::void(К.Л));
    К.тип_невідома_комірка = визначити_нативний_тип(К, ю8"невідома_комірка", LLVM::pointer(К.Л));
    К.тип_ц8 = визначити_нативний_тип(К, ю8"ц8", LLVM::і8(К.Л));
    К.тип_ц16 = визначити_нативний_тип(К, ю8"ц16", LLVM::і16(К.Л));
    К.тип_ц32 = визначити_нативний_тип(К, ю8"ц32", LLVM::і32(К.Л));
    К.тип_ц64 = визначити_нативний_тип(К, ю8"ц64", LLVM::і64(К.Л));
    К.тип_п8 = визначити_нативний_тип(К, ю8"п8", LLVM::і8(К.Л));
    К.тип_п16 = визначити_нативний_тип(К, ю8"п16", LLVM::і16(К.Л));
    К.тип_п32 = визначити_нативний_тип(К, ю8"п32", LLVM::і32(К.Л));
    К.тип_п64 = визначити_нативний_тип(К, ю8"п64", LLVM::і64(К.Л));
    К.тип_д32 = визначити_нативний_тип(К, ю8"д32", LLVM::f32(К.Л));
    К.тип_д64 = визначити_нативний_тип(К, ю8"д64", LLVM::f64(К.Л));

    ціль спец_обʼєкт_комірка = створити_пустий_спец_обʼєкт();
    спец_обʼєкт_комірка.назва = ю8"комірка";
    спец_обʼєкт_комірка.виконати_шаблон = дія_спец_обʼєкта_комірка_виконати_шаблон;
    ціль обʼєкт_компіляції = ОбʼєктКомпіляції { ВидОКСпецОбʼєкт, спец_обʼєкт_комірка };
    змінити_в_середовищі(глобальне_середовище, спец_обʼєкт_комірка.назва, обʼєкт_компіляції);

    К.шлях = виділити_список<комірка<Місцезнаходження>>();

    вернути К;
  }

  місцева дія додати_до_шляху_компілятора(К: комірка<Компілятор>, місцезнаходження: комірка<Місцезнаходження>) {
    додати_до_списку<комірка<Місцезнаходження>>(К.шлях, місцезнаходження);
  }

  місцева дія забрати_з_шляху_компілятора(К: комірка<Компілятор>) {
    К.шлях.довжина = К.шлях.довжина - 1;
  }
}

секція х {
  дія порівняти_ю8(а: памʼять<п8>, б: памʼять<п8>): логічне {
    змінна символ_: п8 = а[0];
    змінна х: позитивне = 0;
    поки символ_ != 0 {
      якщо символ_ != б[х] {
        вернути ні;
      }
      х = х + 1;
      символ_ = а[х];
    }
    якщо б[х] != 0 {
      вернути ні;
    }
    вернути так;
  }

  синонім ВидОбʼєктаНЕІСНУЄ = 0;
  синонім ВидОбʼєктаТипу = 1;
  синонім ВидОбʼєктаДії = 2;
  синонім ВидОбʼєктаЦілі = 3;
  синонім ВидОбʼєктаЗначення = 4;

  структура Компілятор;
  структура Середовище;
  структура Обʼєкт;
  структура Результат;
  структура ОбʼєктТипу;
  структура ОбʼєктДії;
  структура ОбʼєктЦілі;
  структура ОбʼєктЗначення;

  структура Компілятор {
    L: комірка<LLVM::TL>;
    глобальне_середовище: комірка<Середовище>;
    тип_ніщо: комірка<ОбʼєктТипу>;
    тип_ц8: комірка<ОбʼєктТипу>;
    тип_ц16: комірка<ОбʼєктТипу>;
    тип_ц32: комірка<ОбʼєктТипу>;
    тип_ц64: комірка<ОбʼєктТипу>;
    тип_п8: комірка<ОбʼєктТипу>;
    тип_п16: комірка<ОбʼєктТипу>;
    тип_п32: комірка<ОбʼєктТипу>;
    тип_п64: комірка<ОбʼєктТипу>;
    тип_д32: комірка<ОбʼєктТипу>;
    тип_д64: комірка<ОбʼєктТипу>;
  }

  структура Блок {
    llvm_ret_value: комірка<LLVM::Value>;
    llvm_alloca_block: комірка<LLVM::BasicBlock>;
    llvm_block: комірка<LLVM::BasicBlock>;
    llvm_exit_block: комірка<LLVM::BasicBlock>;
    llvm_function_exit_block: комірка<LLVM::BasicBlock>;
  }

  структура Обʼєкт {
    вид: позитивне;
    дані: комірка<ОбʼєктТипу> | комірка<ОбʼєктДії> | комірка<ОбʼєктЦілі> | комірка<ОбʼєктЗначення>;
  }

  структура Середовище {
    вище: комірка<Середовище>;
    субʼєкти: комірка<карта<памʼять<п8>, Обʼєкт>>;
  }

  дія отримати_зі_середовища(середовище: комірка<Середовище>, назва: памʼять<п8>, куда_записати: комірка<Обʼєкт>): логічне {
    ціль останнє_середовище = середовище;
    поки останнє_середовище != пусто {
      ціль обʼєкт = отримати_значення_з_карти<памʼять<п8>, Обʼєкт>(останнє_середовище.субʼєкти, назва, Обʼєкт { ВидОбʼєктаНЕІСНУЄ, пусто });
      якщо обʼєкт.вид != ВидОбʼєктаНЕІСНУЄ {
        куда_записати.вид = обʼєкт.вид;
        куда_записати.дані = обʼєкт.дані як комірка<ОбʼєктТипу>;
        вернути так;
      }
      останнє_середовище = останнє_середовище.вище;
    }
    вернути ні;
  }

  структура ПомилкаКомпіляції {
    місцезнаходження: комірка<Місцезнаходження>;
    повідомлення: памʼять<п8>;
  }

  дія виділити_помилку_компіляції(місцезнаходження: комірка<Місцезнаходження>, повідомлення: памʼять<п8>): комірка<ПомилкаКомпіляції> {
    ціль помилка = виділити<ПомилкаКомпіляції>();
    помилка.місцезнаходження = місцезнаходження;
    помилка.повідомлення = повідомлення;
    вернути помилка;
  }

  структура Результат {
    обʼєкт: Обʼєкт;
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура РезультатЯкТип {
    обʼєкт_типу: комірка<ОбʼєктТипу>;
    помилка: комірка<ПомилкаКомпіляції>;
  }

  синонім ВидТипуНативний = 1;
  синонім ВидТипуСтруктура = 2;
  синонім ВидТипуДія = 3;

  структура ВластивістьСтруктури {
    назва: памʼять<п8>;
    тип: комірка<ОбʼєктТипу>;
  }

  структура ПараметрДії {
    назва: памʼять<п8>;
    тип: комірка<ОбʼєктТипу>;
  }

  структура ОбʼєктТипу {
    вид: позитивне;
    назва: памʼять<п8>;
    властивості_структури: комірка<список<ВластивістьСтруктури>>;
    параметри_дії: комірка<список<ПараметрДії>>;
    тип_результату_дії: комірка<ОбʼєктТипу>;
    llvm_type: комірка<LLVM::Type>;
    додати: (я: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт) -> Результат;
  }
  структура ОбʼєктДії {
    назва: памʼять<п8>;
    параметри: комірка<список<ПараметрДії>>;
    тип_результату: комірка<ОбʼєктТипу>;
    тип: комірка<ОбʼєктТипу>;
    llvm_function: комірка<LLVM::Function>;
    додати: (я: комірка<ОбʼєктДії>, К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт) -> Результат;
  }
  структура ОбʼєктЦілі {
    тип: комірка<ОбʼєктТипу>;
    llvm_value: комірка<LLVM::Value>;
    додати: (я: комірка<ОбʼєктЦілі>, К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт) -> Результат;
  }
  структура ОбʼєктЗначення {
    тип: комірка<ОбʼєктТипу>;
    llvm_value: комірка<LLVM::Value>;
    додати: (я: комірка<ОбʼєктЗначення>, К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт) -> Результат;
  }

  дія змінити_в_середовищі(середовище: комірка<Середовище>, назва: памʼять<п8>, обʼєкт: Обʼєкт) {
    змінити_значення_карти<памʼять<п8>, Обʼєкт>(середовище.субʼєкти, назва, обʼєкт);
  }

  дія обʼєкт_додати(я: Обʼєкт, К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу.додати(обʼєкт_типу, К, блок, середовище, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії.додати(обʼєкт_дії, К, блок, середовище, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЦілі {
      ціль обʼєкт_цілі = я.дані як комірка<ОбʼєктЦілі>;
      вернути обʼєкт_цілі.додати(обʼєкт_цілі, К, блок, середовище, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як комірка<ОбʼєктЗначення>;
      вернути обʼєкт_значення.додати(обʼєкт_значення, К, блок, середовище, місцезнаходження, аргумент);
    }
  }

  дія створити_середовище(вище: комірка<Середовище>): комірка<Середовище> {
    ціль середовище = виділити<Середовище>();
    середовище.вище = вище;
    середовище.субʼєкти = виділити_карту<памʼять<п8>, Обʼєкт>(порівняти_ю8);
    вернути середовище;
  }

  структура РезультатКомпіляціїТілаСекції {
    помилка: комірка<ПомилкаКомпіляції>;
  }

  структура РезультатКомпіляціїБлоку {
    помилка: комірка<ПомилкаКомпіляції>;
  }

  дія скомпілювати_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: невідома_комірка, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): Результат {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      ціль назва = дані.ідентифікатор.значення;
      ціль обʼєкт: Обʼєкт;
      ціль успіх_отримання_зі_середовища = отримати_зі_середовища(середовище, назва, комірка(обʼєкт));
      якщо успіх_отримання_зі_середовища == так {
        вернути Результат { обʼєкт = обʼєкт, помилка = пусто };
      }
    }

    ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати значення");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: невідома_комірка, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЯкТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, інформація_виконання_шаблону, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЯкТип { помилка = результат_компіляції_значення.помилка };
    }
    якщо результат_компіляції_значення.обʼєкт.вид != ВидОбʼєктаТипу {
      ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Значення не є типом");
      вернути РезультатЯкТип { помилка = помилка_компіляції };
    }
    ціль обʼєкт = результат_компіляції_значення.обʼєкт;
    вернути РезультатЯкТип { обʼєкт_типу = обʼєкт.дані як комірка<ОбʼєктТипу>, помилка = пусто };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніЦіль>;
        ціль назва = дані.ідентифікатор.значення;
        ціль результат_компіляції_значення_типу = скомпілювати_значення_як_тип(К, пусто, пусто, середовище, дані.тип);
        якщо результат_компіляції_значення_типу.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { помилка = результат_компіляції_значення_типу.помилка };
        }
        ціль обʼєкт_типу_цілі = результат_компіляції_значення_типу.обʼєкт_типу;
        ціль обʼєкт_цілі = виділити<ОбʼєктЦілі>();
        обʼєкт_цілі.тип = обʼєкт_типу_цілі;
        обʼєкт_цілі.llvm_value = LLVM::alloca(К.L, блок.llvm_alloca_block, назва, обʼєкт_типу_цілі.llvm_type);
        обʼєкт_цілі.додати = пусто;
        ціль обʼєкт = Обʼєкт { ВидОбʼєктаЦілі, дані = обʼєкт_цілі };
        змінити_в_середовищі(середовище, назва, обʼєкт);
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
      }

      х = х + 1;
    }
    LLVM::br(К.L, блок.llvm_block, блок.llvm_exit_block);
    вернути РезультатКомпіляціїБлоку { пусто };
  }


  дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидДія {
        ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
        ціль назва = дані.ідентифікатор.значення;
        ціль обʼєкт_дії = виділити<ОбʼєктДії>();
        обʼєкт_дії.назва = назва;
        обʼєкт_дії.параметри = виділити_список<ПараметрДії>();
        обʼєкт_дії.тип_результату = К.тип_ніщо;
        обʼєкт_дії.тип = пусто;
        обʼєкт_дії.llvm_function = пусто;
        обʼєкт_дії.додати = пусто;
        ціль llvm_param_types = виділити<комірка<LLVM::Type>>(дані.кількість_параметрів);
        змінна пх: позитивне = 0;
        поки пх < дані.кількість_параметрів {
          ціль параметр = дані.параметри[пх];
          ціль назва_параметра = параметр.ідентифікатор.значення;
          ціль результат_компіляції_значення_типу_параметра = скомпілювати_значення_як_тип(К, пусто, пусто, середовище_секції, параметр.тип);
          якщо результат_компіляції_значення_типу_параметра.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { помилка = результат_компіляції_значення_типу_параметра.помилка };
          }
          ціль обʼєкт_типу_параметра = результат_компіляції_значення_типу_параметра.обʼєкт_типу;
          ціль параметр_дії = ПараметрДії { назва = назва_параметра, тип = обʼєкт_типу_параметра };
          додати_до_списку<ПараметрДії>(обʼєкт_дії.параметри, параметр_дії);
          llvm_param_types[пх] = обʼєкт_типу_параметра.llvm_type;
          пх = пх + 1;
        }
        якщо дані.тип_результату != пусто {
          ціль результат_компіляції_значення_типу_результату = скомпілювати_значення_як_тип(К, пусто, пусто, середовище_секції, дані.тип_результату);
          якщо результат_компіляції_значення_типу_результату.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { помилка = результат_компіляції_значення_типу_результату.помилка };
          }
          обʼєкт_дії.тип_результату = результат_компіляції_значення_типу_результату.обʼєкт_типу;
        }
        обʼєкт_дії.llvm_function = LLVM::function(К.L, LLVM::LINKAGE_INTERNAL, назва, обʼєкт_дії.тип_результату.llvm_type, обʼєкт_дії.параметри.довжина, llvm_param_types, ні);
        якщо дані.тіло != пусто {
          ціль блок = виділити<Блок>();
          блок.llvm_ret_value = пусто;
          блок.llvm_alloca_block = LLVM::block(К.L, обʼєкт_дії.llvm_function, ю8"alloca");
          блок.llvm_block = LLVM::block(К.L, обʼєкт_дії.llvm_function, ю8"entry");
          блок.llvm_exit_block = LLVM::block(К.L, обʼєкт_дії.llvm_function, ю8"exit");
          блок.llvm_function_exit_block = блок.llvm_exit_block;
          якщо обʼєкт_дії.тип_результату != К.тип_ніщо {
            блок.llvm_ret_value = LLVM::alloca(К.L, блок.llvm_alloca_block, ю8"return", обʼєкт_дії.тип_результату.llvm_type);
          }
          ціль результат_компіляції_блоку = скомпілювати_блок(К, блок, середовище_секції, дані.тіло);
          якщо результат_компіляції_блоку.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { помилка = результат_компіляції_блоку.помилка };
          }
          LLVM::br(К.L, блок.llvm_alloca_block, блок.llvm_block);
          якщо блок.llvm_ret_value == пусто {
            LLVM::ret(К.L, блок.llvm_exit_block, пусто);
          } інакше {
            ціль llvm_value = LLVM::load(К.L, блок.llvm_exit_block, обʼєкт_дії.тип_результату.llvm_type, блок.llvm_ret_value);
            LLVM::ret(К.L, блок.llvm_exit_block, llvm_value);
          }
        }
        ціль обʼєкт = Обʼєкт { ВидОбʼєктаДії, дані = обʼєкт_дії };
        змінити_в_середовищі(середовище_секції, назва, обʼєкт);
      } інакше якщо асд_значення.вид == АСДВидСтруктура {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
        ціль назва = дані.ідентифікатор.значення;
        ціль обʼєкт_типу = виділити<ОбʼєктТипу>();
        обʼєкт_типу.вид = ВидТипуСтруктура;
        обʼєкт_типу.назва = назва;
        обʼєкт_типу.властивості_структури = виділити_список<ВластивістьСтруктури>();
        обʼєкт_типу.параметри_дії = пусто;
        обʼєкт_типу.тип_результату_дії = пусто;
        обʼєкт_типу.llvm_type = LLVM::struct(К.L, назва);
        обʼєкт_типу.додати = пусто;
        ціль llvm_param_types = виділити<комірка<LLVM::Type>>(дані.кількість_параметрів);
        змінна пх: позитивне = 0;
        поки пх < дані.кількість_параметрів {
          ціль параметр = дані.параметри[пх];
          ціль назва_параметра = параметр.ідентифікатор.значення;
          ціль результат_компіляції_значення_типу_параметра = скомпілювати_значення_як_тип(К, пусто, пусто, середовище_секції, параметр.тип);
          якщо результат_компіляції_значення_типу_параметра.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { помилка = результат_компіляції_значення_типу_параметра.помилка };
          }
          ціль обʼєкт_типу_параметра = результат_компіляції_значення_типу_параметра.обʼєкт_типу;
          ціль властивість_структури = ВластивістьСтруктури { назва = назва_параметра, тип = обʼєкт_типу_параметра };
          додати_до_списку<ВластивістьСтруктури>(обʼєкт_типу.властивості_структури, властивість_структури);
          llvm_param_types[пх] = обʼєкт_типу_параметра.llvm_type;
          пх = пх + 1;
        }
        LLVM::struct_set_fields(К.L, обʼєкт_типу.llvm_type, дані.кількість_параметрів, llvm_param_types);
        ціль обʼєкт = Обʼєкт { ВидОбʼєктаТипу, дані = обʼєкт_типу };
        змінити_в_середовищі(середовище_секції, назва, обʼєкт);
      } інакше якщо асд_значення.вид == АСДВидШаблон {
        ціль дані = асд_значення.дані як комірка<АСДДаніШаблон>;
      } інакше якщо асд_значення.вид == АСДВидСинонім {
        ціль дані = асд_значення.дані як комірка<АСДДаніСинонім>;
      } інакше якщо асд_значення.вид == АСДВидСекція {
        ціль дані = асд_значення.дані як комірка<АСДДаніСекція>;
      }

      х = х + 1;
    }
    вернути РезультатКомпіляціїТілаСекції { помилка = пусто };
  }

  дія виділити_обʼєкт_типу(вид: позитивне): комірка<ОбʼєктТипу> {
    ціль обʼєкт_типу = виділити<ОбʼєктТипу>();
    обʼєкт_типу.вид = вид;
    обʼєкт_типу.назва = пусто;
    обʼєкт_типу.властивості_структури = пусто;
    обʼєкт_типу.параметри_дії = пусто;
    обʼєкт_типу.тип_результату_дії = пусто;
    обʼєкт_типу.llvm_type = пусто;
    обʼєкт_типу.додати = пусто;
    вернути обʼєкт_типу;
  }

  дія створити_нативний_тип(К: комірка<Компілятор>, назва: памʼять<п8>, llvm_type: комірка<LLVM::Type>): комірка<ОбʼєктТипу> {
    ціль обʼєкт_типу = виділити_обʼєкт_типу(ВидТипуНативний);
    обʼєкт_типу.назва = назва;
    обʼєкт_типу.llvm_type = llvm_type;
    вернути обʼєкт_типу;
  }

  дія створити_компілятор(L: комірка<LLVM::TL>): комірка<Компілятор> {
    ціль глобальне_середовище = створити_середовище(пусто);

    ціль К = виділити<Компілятор>();
    К.L = L;
    К.глобальне_середовище = глобальне_середовище;
    К.тип_ніщо = створити_нативний_тип(К, ю8"ніщо", LLVM::void(L));
    змінити_в_середовищі(глобальне_середовище, ю8"ніщо", Обʼєкт { ВидОбʼєктаТипу, дані = К.тип_ніщо });
    К.тип_ц8 = створити_нативний_тип(К, ю8"ц8", LLVM::і8(L));
    змінити_в_середовищі(глобальне_середовище, ю8"ц8", Обʼєкт { ВидОбʼєктаТипу, дані = К.тип_ц8 });
    К.тип_ц16 = створити_нативний_тип(К, ю8"ц16", LLVM::і16(L));
    змінити_в_середовищі(глобальне_середовище, ю8"ц16", Обʼєкт { ВидОбʼєктаТипу, дані = К.тип_ц16 });
    К.тип_ц32 = створити_нативний_тип(К, ю8"ц32", LLVM::і32(L));
    змінити_в_середовищі(глобальне_середовище, ю8"ц32", Обʼєкт { ВидОбʼєктаТипу, дані = К.тип_ц32 });
    К.тип_ц64 = створити_нативний_тип(К, ю8"ц64", LLVM::і64(L));
    змінити_в_середовищі(глобальне_середовище, ю8"ц64", Обʼєкт { ВидОбʼєктаТипу, дані = К.тип_ц64 });

    вернути К;
  }
}

зовнішня дія скомпілювати_ціль_в_ll(Л: комірка<LLVM::TL>, текст_коду: комірка<ТекстКоду>): комірка<ПомилкаКомпіляціїЦілі> {
  ціль результат_розбору_цілі = розібрати_ціль(текст_коду);
  якщо результат_розбору_цілі.успіх == ні {
    ціль помилка_компіляції_цілі = виділити<ПомилкаКомпіляціїЦілі>();
    помилка_компіляції_цілі.місцезнаходження = результат_розбору_цілі.помилка.місцезнаходження;
    помилка_компіляції_цілі.повідомлення = результат_розбору_цілі.помилка.повідомлення;
    вернути помилка_компіляції_цілі;
  }
  ціль К = х::створити_компілятор(Л);
  ціль початкове_середовище = х::створити_середовище(К.глобальне_середовище);
  ціль результат_компіляції_тіла_секції = х::скомпілювати_тіло_секції(К, початкове_середовище, результат_розбору_цілі.тіло);
  якщо результат_компіляції_тіла_секції.помилка != пусто {
    ціль помилка_компіляції_цілі = виділити<ПомилкаКомпіляціїЦілі>();
    помилка_компіляції_цілі.місцезнаходження = результат_компіляції_тіла_секції.помилка.місцезнаходження;
    помилка_компіляції_цілі.повідомлення = результат_компіляції_тіла_секції.помилка.повідомлення;
    помилка_компіляції_цілі.довжина_шляху = 0;
    помилка_компіляції_цілі.шлях = пусто;
//    помилка_компіляції_цілі.довжина_шляху = К.шлях.довжина;
//    помилка_компіляції_цілі.шлях = К.шлях.дані;
    вернути помилка_компіляції_цілі;
  }
  вернути пусто;
}