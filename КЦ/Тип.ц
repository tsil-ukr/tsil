взяти визначення Ц;

секція ц {
  місцева дія виділити_обʼєкт_типу(вид: позитивне): адреса<ОбʼєктТипу> {
    ціль обʼєкт_типу = виділити<ОбʼєктТипу>();
    обʼєкт_типу.вид = вид;
    обʼєкт_типу.назва = пусто;
    обʼєкт_типу.властивості_структури = зробити_накопичувач<ВластивістьСтруктури>();
    обʼєкт_типу.параметри_дії = зробити_накопичувач<ПараметрДії>();
    обʼєкт_типу.тип_результату_дії = пусто;
    обʼєкт_типу.тип_адреси = пусто;
    обʼєкт_типу.тип_масиву = пусто;
    обʼєкт_типу.тип_памʼяті = пусто;
    обʼєкт_типу.розмір_масиву = 0;
    обʼєкт_типу.типи_варіації = зробити_накопичувач<адреса<ОбʼєктТипу>>();
    обʼєкт_типу.найбільший_тип_варіації = пусто;
    обʼєкт_типу.елементи_переліку = зробити_накопичувач<адреса<ОбʼєктТипу>>();
    обʼєкт_типу.обʼєкт_типу_переліку_елемента_переліку = пусто;
    обʼєкт_типу.позиція_елемента_переліку = 0;
    обʼєкт_типу.обʼєкт_типу_структури_елемента_переліку = пусто;
    обʼєкт_типу.найбільший_тип_переліку = пусто;
    обʼєкт_типу.типи_шаблону = зробити_накопичувач<адреса<ОбʼєктТипу>>();
    обʼєкт_типу.llvm_type = пусто;
    вернути обʼєкт_типу;
  }

  місцева дія виділити_нативний_тип(К: адреса<Компілятор>, назва: адреса<Назва>, llvm_type: адреса<LLVM::Type>): адреса<ОбʼєктТипу> {
    ціль обʼєкт_типу = виділити_обʼєкт_типу(ВидТипуНативний);
    обʼєкт_типу.назва = назва;
    обʼєкт_типу.llvm_type = llvm_type;
    вернути обʼєкт_типу;
  }

  місцева дія виділити_тип_адреси(К: адреса<Компілятор>, тип_адреси: адреса<ОбʼєктТипу>): адреса<ОбʼєктТипу> {
    ціль обʼєкт_типу = виділити_обʼєкт_типу(ВидТипуАдреса);
    обʼєкт_типу.тип_адреси = тип_адреси;
    обʼєкт_типу.llvm_type = LLVM::pointer(К.L);
    покласти_в_накопичувач<адреса<ОбʼєктТипу>>(обʼєкт_типу.типи_шаблону::адреса, тип_адреси);
    вернути обʼєкт_типу;
  }

  місцева дія виділити_тип_памʼяті(К: адреса<Компілятор>, тип_памʼяті: адреса<ОбʼєктТипу>): адреса<ОбʼєктТипу> {
    ціль обʼєкт_типу = виділити_обʼєкт_типу(ВидТипуПамʼять);
    обʼєкт_типу.тип_памʼяті = тип_памʼяті;
    обʼєкт_типу.llvm_type = LLVM::pointer(К.L);
    покласти_в_накопичувач<адреса<ОбʼєктТипу>>(обʼєкт_типу.типи_шаблону::адреса, тип_памʼяті);
    вернути обʼєкт_типу;
  }

  місцева дія перевірити_тип(реальний_тип: адреса<ОбʼєктТипу>, очікуваний_тип: адреса<ОбʼєктТипу>): логічне {
    якщо реальний_тип == очікуваний_тип {
      вернути так;
    }
    якщо реальний_тип.вид == ВидТипуНативний {
      якщо очікуваний_тип.вид == ВидТипуНативний {
        якщо реальний_тип == очікуваний_тип {
          вернути так;
        }
      }
    }
    якщо реальний_тип.вид == ВидТипуСтруктура {
      якщо очікуваний_тип.вид == ВидТипуСтруктура {
        якщо реальний_тип == очікуваний_тип {
          вернути так;
        }
      }
    }
    якщо реальний_тип.вид == ВидТипуДія {
      якщо очікуваний_тип.вид == ВидТипуДія {
        якщо реальний_тип.параметри_дії.розмір != очікуваний_тип.параметри_дії.розмір {
          вернути ні;
        }
        змінна ціль пх: позитивне = 0;
        поки пх < реальний_тип.параметри_дії.розмір {
          ціль параметр_1 = реальний_тип.параметри_дії.дані[пх];
          ціль параметр_2 = очікуваний_тип.параметри_дії.дані[пх];
          якщо перевірити_тип(параметр_1.тип, параметр_2.тип) == ні {
            вернути ні;
          }
          пх = пх + 1;
        }
        якщо перевірити_тип(реальний_тип.тип_результату_дії, очікуваний_тип.тип_результату_дії) == ні {
          вернути ні;
        }
        вернути так;
      }
    }
    якщо реальний_тип.вид == ВидТипуАдреса {
      якщо очікуваний_тип.вид == ВидТипуАдреса {
        якщо перевірити_тип(реальний_тип.тип_адреси, очікуваний_тип.тип_адреси) == так {
          вернути так;
        }
      }
    }
    якщо реальний_тип.вид == ВидТипуПамʼять {
      якщо очікуваний_тип.вид == ВидТипуПамʼять {
        якщо перевірити_тип(реальний_тип.тип_памʼяті, очікуваний_тип.тип_памʼяті) == так {
          вернути так;
        }
      }
    }
    якщо реальний_тип.вид == ВидТипуМасив {
      якщо очікуваний_тип.вид == ВидТипуМасив {
        якщо перевірити_тип(реальний_тип.тип_масиву, очікуваний_тип.тип_масиву) == так {
          якщо реальний_тип.розмір_масиву == очікуваний_тип.розмір_масиву {
            вернути так;
          }
        }
      }
    }
    вернути ні;
  }

  місцева дія перевірити_тип_з_переліками(реальний_тип: адреса<ОбʼєктТипу>, очікуваний_тип: адреса<ОбʼєктТипу>): логічне {
    якщо перевірити_тип(реальний_тип, очікуваний_тип) == ні {
      вернути ні;
    }
    якщо очікуваний_тип.вид == ВидТипуПерелік {
      якщо реальний_тип.вид == ВидТипуЕлементПереліку {
        якщо реальний_тип.обʼєкт_типу_переліку_елемента_переліку == очікуваний_тип {
          вернути так;
        }
      }
    }
  }

  дія сплющити_тип(обʼєкт_типу: адреса<ОбʼєктТипу>, вихід: адреса<Накопичувач<адреса<ОбʼєктТипу>>>) {
    якщо обʼєкт_типу.вид == ВидТипуСтруктура {
      змінна ціль пх: позитивне = 0;
      поки пх < обʼєкт_типу.властивості_структури.розмір {
        сплющити_тип(обʼєкт_типу.властивості_структури.дані[пх].тип, вихід);
        пх = пх + 1;
      }
    } інакше якщо обʼєкт_типу.вид == ВидТипуВаріація {
      сплющити_тип(обʼєкт_типу.найбільший_тип_варіації, вихід);
    } інакше {
      покласти_в_накопичувач<адреса<ОбʼєктТипу>>(вихід, обʼєкт_типу);
    }
  }

  місцева дія дізнатись_розмір_типу(К: адреса<Компілятор>, обʼєкт_типу: адреса<ОбʼєктТипу>): позитивне {
    якщо обʼєкт_типу.вид == ВидТипуНативний {
      якщо обʼєкт_типу == К.тип_логічне {
        вернути 1;
      }
      якщо обʼєкт_типу == К.тип_ц8 {
        вернути 1;
      }
      якщо обʼєкт_типу == К.тип_ц16 {
        вернути 2;
      }
      якщо обʼєкт_типу == К.тип_ц32 {
        вернути 4;
      }
      якщо обʼєкт_типу == К.тип_ц64 {
        вернути 8;
      }
      якщо обʼєкт_типу == К.тип_ціле {
        вернути 8;
      }
      якщо обʼєкт_типу == К.тип_п8 {
        вернути 1;
      }
      якщо обʼєкт_типу == К.тип_п16 {
        вернути 2;
      }
      якщо обʼєкт_типу == К.тип_п32 {
        вернути 4;
      }
      якщо обʼєкт_типу == К.тип_п64 {
        вернути 8;
      }
      якщо обʼєкт_типу == К.тип_позитивне {
        вернути 8;
      }
      якщо обʼєкт_типу == К.тип_д32 {
        вернути 4;
      }
      якщо обʼєкт_типу == К.тип_д64 {
        вернути 8;
      }
      якщо обʼєкт_типу == К.тип_десяткове {
        вернути 8;
      }
    }
    якщо обʼєкт_типу.вид == ВидТипуСтруктура {
      // потім: перевірити чи це працює правильно
      ціль сплющений_тип = виділити_накопичувач<адреса<ОбʼєктТипу>>();
      сплющити_тип(обʼєкт_типу, сплющений_тип);
      змінна ціль result: позитивне = 0;
      змінна ціль maxalign: позитивне = 0;
      змінна ціль пх: позитивне = 0;
      поки пх < сплющений_тип.розмір {
        ціль align = дізнатись_розмір_типу(К, сплющений_тип.дані[пх]);
        ціль offset = result;
        якщо result == 0 {
          result = result + align;
        } інакше {
          ціль padding = (align - (offset % align)) % align;
          ціль aligned = align + padding;
          result = result + aligned;
        }
        якщо align > maxalign {
          maxalign = align;
        }
        пх = пх + 1;
      }
      поки result % maxalign != 0 {
        result = result + 1;
      }
      звільнити_накопичувач<адреса<ОбʼєктТипу>>(сплющений_тип);
      вернути result;
    }
    якщо обʼєкт_типу.вид == ВидТипуДія {
      вернути 8;
    }
    якщо обʼєкт_типу.вид == ВидТипуАдреса {
      вернути 8;
    }
    якщо обʼєкт_типу.вид == ВидТипуПамʼять {
      вернути 8;
    }
    якщо обʼєкт_типу.вид == ВидТипуВаріація {
      вернути дізнатись_розмір_типу(К, обʼєкт_типу.найбільший_тип_варіації);
    }
    якщо обʼєкт_типу.вид == ВидТипуПерелік {
      // потім: перевірити чи це працює правильно
      ціль сплющений_тип = виділити_накопичувач<адреса<ОбʼєктТипу>>();
      покласти_в_накопичувач<адреса<ОбʼєктТипу>>(сплющений_тип, К.тип_п8);
      якщо обʼєкт_типу.найбільший_тип_переліку == пусто {
        покласти_в_накопичувач<адреса<ОбʼєктТипу>>(сплющений_тип, К.тип_п8);
      } інакше {
        якщо обʼєкт_типу.найбільший_тип_переліку.обʼєкт_типу_структури_елемента_переліку == пусто {
          покласти_в_накопичувач<адреса<ОбʼєктТипу>>(сплющений_тип, К.тип_п8);
        } інакше {
          сплющити_тип(обʼєкт_типу.найбільший_тип_переліку.обʼєкт_типу_структури_елемента_переліку, сплющений_тип);
        }
      }
      змінна ціль result: позитивне = 0;
      змінна ціль maxalign: позитивне = 0;
      змінна ціль пх: позитивне = 0;
      поки пх < сплющений_тип.розмір {
        ціль align = дізнатись_розмір_типу(К, сплющений_тип.дані[пх]);
        ціль offset = result;
        якщо result == 0 {
          result = result + align;
        } інакше {
          ціль padding = (align - (offset % align)) % align;
          ціль aligned = align + padding;
          result = result + aligned;
        }
        якщо align > maxalign {
          maxalign = align;
        }
        пх = пх + 1;
      }
      поки result % maxalign != 0 {
        result = result + 1;
      }
      звільнити_накопичувач<адреса<ОбʼєктТипу>>(сплющений_тип);
      вернути result;
    }
    якщо обʼєкт_типу.вид == ВидТипуЕлементПереліку {
      вернути дізнатись_розмір_типу(К, обʼєкт_типу.обʼєкт_типу_переліку_елемента_переліку);
    }
    біб::друк_ю8(ю8сі"Не вдалося дізнатись розмір типу");
    вернути 0;
  }

  місцева дія перевірити_чи_тип_повний(К: адреса<Компілятор>, обʼєкт_типу: адреса<ОбʼєктТипу>): логічне {
    якщо обʼєкт_типу.вид == ВидТипуСтруктура {
      якщо обʼєкт_типу.властивості_структури.розмір == 0 {
        // потім: довжина може бути не 0 якщо перевіряється не перша властивість
        //        треба подумати кращий спосіб перевірки на повність
        вернути ні;
      }
    }
    вернути так;
  }

  місцева дія перевірити_тип_значення_і_перетворити_якщо_треба(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, очікуваний_тип: адреса<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення): РезультатПеревіркиТипуЗначення {
    якщо очікуваний_тип.вид == ВидТипуАдреса {
      якщо очікуваний_тип.тип_адреси == К.тип_ніщо {
        якщо обʼєкт_значення.тип.вид == ВидТипуАдреса {
          вернути РезультатПеревіркиТипуЗначення { позитивне(так), обʼєкт_значення };
        }
      }
      якщо обʼєкт_значення.llvm_value == LLVM::null(К.L) {
        вернути РезультатПеревіркиТипуЗначення { позитивне(так), обʼєкт_значення };
      }
    }
    якщо очікуваний_тип.вид == ВидТипуПамʼять {
      якщо очікуваний_тип.тип_памʼяті == К.тип_ніщо {
        якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
          вернути РезультатПеревіркиТипуЗначення { позитивне(так), обʼєкт_значення };
        }
      }
      якщо обʼєкт_значення.llvm_value == LLVM::null(К.L) {
        вернути РезультатПеревіркиТипуЗначення { позитивне(так), обʼєкт_значення };
      }
    }
    якщо очікуваний_тип.вид == ВидТипуДія {
      якщо обʼєкт_значення.llvm_value == LLVM::null(К.L) {
        вернути РезультатПеревіркиТипуЗначення { позитивне(так), обʼєкт_значення };
      }
    }
    якщо очікуваний_тип.вид == ВидТипуПерелік {
      якщо обʼєкт_значення.тип.вид == ВидТипуЕлементПереліку {
        якщо обʼєкт_значення.тип.обʼєкт_типу_переліку_елемента_переліку == очікуваний_тип {
          обʼєкт_значення.тип = очікуваний_тип;
          обʼєкт_значення.llvm_value = LLVM::bitcast(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, очікуваний_тип.llvm_type);
          вернути РезультатПеревіркиТипуЗначення { позитивне(так), обʼєкт_значення };
        }
      }
    }
    якщо перевірити_тип(обʼєкт_значення.тип, очікуваний_тип) == ні {
      вернути РезультатПеревіркиТипуЗначення { позитивне(ні), ... };
    }
    вернути РезультатПеревіркиТипуЗначення { позитивне(так), обʼєкт_значення };
  }
}