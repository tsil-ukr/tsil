взяти визначення КЦ;

секція КЦ {
  зовнішня дія розібрати_число(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, значення: т8, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєктаЗначення {
    змінна помилка_розбору_числа = т8 { 0, пусто };
    змінна позиція_помилки_розбору_числа: позитивне = 0;
    змінна результат_розбору_цілого_числа: ц64 = 0;
    змінна результат_розбору_позитивного_числа: п64 = 0;
    змінна результат_розбору_дійсного_числа: д64 = 0;
    якщо очікуваний_тип == компілятор.тип_ц8 {
      якщо спробувати_розібрати_ціле_число(компілятор, значення, результат_розбору_цілого_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа
      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_ц8,
          ПМ::створити_ц8(компілятор.пм_аркуш, ц8(результат_розбору_цілого_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_ц16 {
      якщо спробувати_розібрати_ціле_число(компілятор, значення, результат_розбору_цілого_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа
      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_ц16,
          ПМ::створити_ц16(компілятор.пм_аркуш, ц16(результат_розбору_цілого_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_ц32 {
      якщо спробувати_розібрати_ціле_число(компілятор, значення, результат_розбору_цілого_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа
      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_ц32,
          ПМ::створити_ц32(компілятор.пм_аркуш, ц32(результат_розбору_цілого_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_ц64 {
      якщо спробувати_розібрати_ціле_число(компілятор, значення, результат_розбору_цілого_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа
      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_ц64,
          ПМ::створити_ц64(компілятор.пм_аркуш, ц64(результат_розбору_цілого_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_п8 {
      якщо спробувати_розібрати_позитивне_число(компілятор, значення, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа
      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_п8,
          ПМ::створити_п8(компілятор.пм_аркуш, п8(результат_розбору_позитивного_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_п16 {
      якщо спробувати_розібрати_позитивне_число(компілятор, значення, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа
      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_п16,
          ПМ::створити_п16(компілятор.пм_аркуш, п16(результат_розбору_позитивного_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_п32 {
      якщо спробувати_розібрати_позитивне_число(компілятор, значення, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа
      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_п32,
          ПМ::створити_п32(компілятор.пм_аркуш, п32(результат_розбору_позитивного_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_п64 {
      якщо спробувати_розібрати_позитивне_число(компілятор, значення, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа
      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_п64,
          ПМ::створити_п64(компілятор.пм_аркуш, п64(результат_розбору_позитивного_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_д32 {
      якщо спробувати_розібрати_дійсне_число(компілятор, значення, результат_розбору_дійсного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа
      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_д32,
          ПМ::створити_д32(компілятор.пм_аркуш, д32(результат_розбору_дійсного_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_д64 {
      якщо спробувати_розібрати_дійсне_число(компілятор, значення, результат_розбору_дійсного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа
      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_д64,
          ПМ::створити_д64(компілятор.пм_аркуш, д64(результат_розбору_дійсного_числа))
        },
        помилка = пусто
      };
    } інакше {
      вернути РезультатОбʼєктаЗначення {
        помилка = створити_помилку(
          компілятор,
          "Не вдалось скомпілювати число.",
          створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
        ),
        ...
      };
    }
  }

  зовнішня дія скомпілювати_число(компілятор: адреса<Компілятор>, контекст: Контекст, дані_числа: розбирач::ДаніСполукиЧисло, місцезнаходження: розбирач::Місцезнаходження, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєкта {
    змінна значення_т8 = розбирач::отримати_значення_слова(
      т8 { контекст.розібраний_текст.текст_коду.значення.розмір, контекст.розібраний_текст.текст_коду.значення.дані },
      контекст.розібраний_текст.слова.дані[дані_числа.позиція_слова]
    );

    якщо очікуваний_тип == пусто {
      вернути РезультатОбʼєкта {
        Обʼєкт {
          ВидОбʼєктаСиреЗначення,
          ОбʼєктСирогоЗначення {
            ВидСирогоОбʼєктаЧисло,
            значення_т8
          }
        },
        помилка = пусто
      };
    } інакше {
      змінна результат_розбору_числа = розібрати_число(компілятор, контекст, місцезнаходження, значення_т8, очікуваний_тип);

      якщо результат_розбору_числа.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_розбору_числа.помилка };
      }

      вернути РезультатОбʼєкта {
        Обʼєкт {
          ВидОбʼєктаЗначення,
          результат_розбору_числа.обʼєкт_значення
        },
        помилка = пусто
      };
    }

    вернути РезультатОбʼєкта {
      помилка = створити_помилку(
        компілятор,
        "Не вдалось скомпілювати число.",
        створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
      ),
      ...
    };
  }
}