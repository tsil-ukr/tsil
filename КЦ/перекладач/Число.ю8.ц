взяти визначення КЦ;

секція КЦ {
  зовнішня дія скомпілювати_число(компілятор: адреса<Компілятор>, контекст: Контекст, дані_числа: розбирач::ДаніСполукиЧисло, місцезнаходження: розбирач::Місцезнаходження, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєкта {
    змінна значення_ю8 = розбирач::отримати_значення_слова(
      ю8 { контекст.розібраний_текст.текст_коду.значення.розмір, контекст.розібраний_текст.текст_коду.значення.дані },
      контекст.розібраний_текст.слова.дані[дані_числа.позиція_слова]
    );
    змінна значення_т8 = отримати_т8_з_ю8(компілятор, значення_ю8);

    якщо очікуваний_тип == пусто {
      вернути РезультатОбʼєкта {
        Обʼєкт {
          ВидОбʼєктаСиреЗначення,
          ОбʼєктСирогоЗначення {
            ВидСирогоОбʼєктаЧисло,
            значення_т8
          }
        },
        помилка = пусто
      };
    } інакше {
      змінна помилка_розбору_числа = т8 { 0, пусто };
      змінна позиція_помилки_розбору_числа: позитивне = 0;
      змінна результат_розбору_цілого_числа: ц64 = 0;
      змінна результат_розбору_позитивного_числа: п64 = 0;
      змінна результат_розбору_дійсного_числа: д64 = 0;
      якщо очікуваний_тип == компілятор.тип_ц8 {
        якщо спробувати_розібрати_ціле_число(компілятор, значення_т8, результат_розбору_цілого_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
          змінна помилка = створити_помилку(
            компілятор,
            помилка_розбору_числа,
            створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
          );
          звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
          вернути РезультатОбʼєкта {
            помилка = помилка,
            ...
          };
        }
        звільнити_памʼять(компілятор, значення_т8.дані);
        // потім: перевірити межі числа
        вернути РезультатОбʼєкта {
          Обʼєкт {
            ВидОбʼєктаЗначення,
            ОбʼєктЗначення {
              компілятор.тип_ц8,
              ПМ::створити_ц8(компілятор.пм_аркуш, ц8(результат_розбору_цілого_числа))
            }
          },
          помилка = пусто
        };
      } інакше якщо очікуваний_тип == компілятор.тип_ц16 {
        якщо спробувати_розібрати_ціле_число(компілятор, значення_т8, результат_розбору_цілого_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
          змінна помилка = створити_помилку(
            компілятор,
            помилка_розбору_числа,
            створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
          );
          звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
          вернути РезультатОбʼєкта {
            помилка = помилка,
            ...
          };
        }
        звільнити_памʼять(компілятор, значення_т8.дані);
        // потім: перевірити межі числа
        вернути РезультатОбʼєкта {
          Обʼєкт {
            ВидОбʼєктаЗначення,
            ОбʼєктЗначення {
              компілятор.тип_ц16,
              ПМ::створити_ц16(компілятор.пм_аркуш, ц16(результат_розбору_цілого_числа))
            }
          },
          помилка = пусто
        };
      } інакше якщо очікуваний_тип == компілятор.тип_ц32 {
        якщо спробувати_розібрати_ціле_число(компілятор, значення_т8, результат_розбору_цілого_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
          змінна помилка = створити_помилку(
            компілятор,
            помилка_розбору_числа,
            створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
          );
          звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
          вернути РезультатОбʼєкта {
            помилка = помилка,
            ...
          };
        }
        звільнити_памʼять(компілятор, значення_т8.дані);
        // потім: перевірити межі числа
        вернути РезультатОбʼєкта {
          Обʼєкт {
            ВидОбʼєктаЗначення,
            ОбʼєктЗначення {
              компілятор.тип_ц32,
              ПМ::створити_ц32(компілятор.пм_аркуш, ц32(результат_розбору_цілого_числа))
            }
          },
          помилка = пусто
        };
      } інакше якщо очікуваний_тип == компілятор.тип_ц64 {
        якщо спробувати_розібрати_ціле_число(компілятор, значення_т8, результат_розбору_цілого_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
          змінна помилка = створити_помилку(
            компілятор,
            помилка_розбору_числа,
            створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
          );
          звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
          вернути РезультатОбʼєкта {
            помилка = помилка,
            ...
          };
        }
        звільнити_памʼять(компілятор, значення_т8.дані);
        // потім: перевірити межі числа
        вернути РезультатОбʼєкта {
          Обʼєкт {
            ВидОбʼєктаЗначення,
            ОбʼєктЗначення {
              компілятор.тип_ц64,
              ПМ::створити_ц64(компілятор.пм_аркуш, ц64(результат_розбору_цілого_числа))
            }
          },
          помилка = пусто
        };
      } інакше якщо очікуваний_тип == компілятор.тип_п8 {
        якщо спробувати_розібрати_позитивне_число(компілятор, значення_т8, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
          змінна помилка = створити_помилку(
            компілятор,
            помилка_розбору_числа,
            створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
          );
          звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
          вернути РезультатОбʼєкта {
            помилка = помилка,
            ...
          };
        }
        звільнити_памʼять(компілятор, значення_т8.дані);
        // потім: перевірити межі числа
        вернути РезультатОбʼєкта {
          Обʼєкт {
            ВидОбʼєктаЗначення,
            ОбʼєктЗначення {
              компілятор.тип_п8,
              ПМ::створити_п8(компілятор.пм_аркуш, п8(результат_розбору_позитивного_числа))
            }
          },
          помилка = пусто
        };
      } інакше якщо очікуваний_тип == компілятор.тип_п16 {
        якщо спробувати_розібрати_позитивне_число(компілятор, значення_т8, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
          змінна помилка = створити_помилку(
            компілятор,
            помилка_розбору_числа,
            створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
          );
          звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
          вернути РезультатОбʼєкта {
            помилка = помилка,
            ...
          };
        }
        звільнити_памʼять(компілятор, значення_т8.дані);
        // потім: перевірити межі числа
        вернути РезультатОбʼєкта {
          Обʼєкт {
            ВидОбʼєктаЗначення,
            ОбʼєктЗначення {
              компілятор.тип_п16,
              ПМ::створити_п16(компілятор.пм_аркуш, п16(результат_розбору_позитивного_числа))
            }
          },
          помилка = пусто
        };
      } інакше якщо очікуваний_тип == компілятор.тип_п32 {
        якщо спробувати_розібрати_позитивне_число(компілятор, значення_т8, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
          змінна помилка = створити_помилку(
            компілятор,
            помилка_розбору_числа,
            створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
          );
          звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
          вернути РезультатОбʼєкта {
            помилка = помилка,
            ...
          };
        }
        звільнити_памʼять(компілятор, значення_т8.дані);
        // потім: перевірити межі числа
        вернути РезультатОбʼєкта {
          Обʼєкт {
            ВидОбʼєктаЗначення,
            ОбʼєктЗначення {
              компілятор.тип_п32,
              ПМ::створити_п32(компілятор.пм_аркуш, п32(результат_розбору_позитивного_числа))
            }
          },
          помилка = пусто
        };
      } інакше якщо очікуваний_тип == компілятор.тип_п64 {
        якщо спробувати_розібрати_позитивне_число(компілятор, значення_т8, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
          змінна помилка = створити_помилку(
            компілятор,
            помилка_розбору_числа,
            створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
          );
          звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
          вернути РезультатОбʼєкта {
            помилка = помилка,
            ...
          };
        }
        звільнити_памʼять(компілятор, значення_т8.дані);
        // потім: перевірити межі числа
        вернути РезультатОбʼєкта {
          Обʼєкт {
            ВидОбʼєктаЗначення,
            ОбʼєктЗначення {
              компілятор.тип_п64,
              ПМ::створити_п64(компілятор.пм_аркуш, п64(результат_розбору_позитивного_числа))
            }
          },
          помилка = пусто
        };
      } інакше якщо очікуваний_тип == компілятор.тип_д32 {
        якщо спробувати_розібрати_дійсне_число(компілятор, значення_т8, результат_розбору_дійсного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
          змінна помилка = створити_помилку(
            компілятор,
            помилка_розбору_числа,
            створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
          );
          звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
          вернути РезультатОбʼєкта {
            помилка = помилка,
            ...
          };
        }
        звільнити_памʼять(компілятор, значення_т8.дані);
        // потім: перевірити межі числа
        вернути РезультатОбʼєкта {
          Обʼєкт {
            ВидОбʼєктаЗначення,
            ОбʼєктЗначення {
              компілятор.тип_д32,
              ПМ::створити_д32(компілятор.пм_аркуш, д32(результат_розбору_дійсного_числа))
            }
          },
          помилка = пусто
        };
      } інакше якщо очікуваний_тип == компілятор.тип_д64 {
        якщо спробувати_розібрати_дійсне_число(компілятор, значення_т8, результат_розбору_дійсного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
          змінна помилка = створити_помилку(
            компілятор,
            помилка_розбору_числа,
            створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
          );
          звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
          вернути РезультатОбʼєкта {
            помилка = помилка,
            ...
          };
        }
        звільнити_памʼять(компілятор, значення_т8.дані);
        // потім: перевірити межі числа
        вернути РезультатОбʼєкта {
          Обʼєкт {
            ВидОбʼєктаЗначення,
            ОбʼєктЗначення {
              компілятор.тип_д64,
              ПМ::створити_д64(компілятор.пм_аркуш, д64(результат_розбору_дійсного_числа))
            }
          },
          помилка = пусто
        };
      }
    }

    звільнити_памʼять(компілятор, значення_т8.дані);

    вернути РезультатОбʼєкта {
      помилка = створити_помилку(
        компілятор,
        "Не вдалось скомпілювати число.",
        створити_місцезнаходження_помилки_з_місцезнаходження(компілятор, контекст.розібраний_текст, місцезнаходження)
      ),
      ...
    };
  }
}