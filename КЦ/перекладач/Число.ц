взяти визначення КЦ;

секція КЦ {
  місцева дія розібрати_число(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, значення: т8, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєктаЗначення {
    змінна помилка_розбору_числа = т8 { 0, пусто };
    змінна позиція_помилки_розбору_числа: позитивне = 0;
    змінна результат_розбору_цілого_числа: ц64 = 0;
    змінна результат_розбору_позитивного_числа: п64 = 0;
    змінна результат_розбору_дійсного_числа: д64 = 0;
    якщо очікуваний_тип == компілятор.тип_логічне {
      якщо спробувати_розібрати_позитивне_число(компілятор, значення, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      якщо результат_розбору_позитивного_числа > 1 {
        вернути РезультатОбʼєктаЗначення {
          помилка = створити_помилку(
            компілятор,
            "Значення числа завелике для типу логічне.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }

      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_логічне,
          ПМ::створити_логічне(компілятор.пм_модуль, логічне(результат_розбору_позитивного_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_ц8 {
      якщо спробувати_розібрати_ціле_число(компілятор, значення, результат_розбору_цілого_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      якщо результат_розбору_цілого_числа > 127 {
        вернути РезультатОбʼєктаЗначення {
          помилка = створити_помилку(
            компілятор,
            "Значення числа завелике для типу ц8.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }

      якщо результат_розбору_цілого_числа < -ц64(128) {
        вернути РезультатОбʼєктаЗначення {
          помилка = створити_помилку(
            компілятор,
            "Значення числа завелике для типу ц8.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }

      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_ц8,
          ПМ::створити_ц8(компілятор.пм_модуль, ц8(результат_розбору_цілого_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_ц16 {
      якщо спробувати_розібрати_ціле_число(компілятор, значення, результат_розбору_цілого_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      якщо результат_розбору_цілого_числа > 32767 {
        вернути РезультатОбʼєктаЗначення {
          помилка = створити_помилку(
            компілятор,
            "Значення числа завелике для типу ц16.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }

      якщо результат_розбору_цілого_числа < -ц64(32768) {
        вернути РезультатОбʼєктаЗначення {
          помилка = створити_помилку(
            компілятор,
            "Значення числа завелике для типу ц16.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }

      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_ц16,
          ПМ::створити_ц16(компілятор.пм_модуль, ц16(результат_розбору_цілого_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_ц32 {
      якщо спробувати_розібрати_ціле_число(компілятор, значення, результат_розбору_цілого_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      якщо результат_розбору_цілого_числа > 2147483647 {
        вернути РезультатОбʼєктаЗначення {
          помилка = створити_помилку(
            компілятор,
            "Значення числа завелике для типу ц32.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }

      якщо результат_розбору_цілого_числа < -ц64(2147483648) {
        вернути РезультатОбʼєктаЗначення {
          помилка = створити_помилку(
            компілятор,
            "Значення числа завелике для типу ц32.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }

      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_ц32,
          ПМ::створити_ц32(компілятор.пм_модуль, ц32(результат_розбору_цілого_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_ц64 {
      якщо спробувати_розібрати_ціле_число(компілятор, значення, результат_розбору_цілого_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа

      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_ц64,
          ПМ::створити_ц64(компілятор.пм_модуль, ц64(результат_розбору_цілого_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_п8 {
      якщо спробувати_розібрати_позитивне_число(компілятор, значення, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      якщо результат_розбору_позитивного_числа > 255 {
        вернути РезультатОбʼєктаЗначення {
          помилка = створити_помилку(
            компілятор,
            "Значення числа завелике для типу п8.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }

      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_п8,
          ПМ::створити_п8(компілятор.пм_модуль, п8(результат_розбору_позитивного_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_п16 {
      якщо спробувати_розібрати_позитивне_число(компілятор, значення, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      якщо результат_розбору_позитивного_числа > 65535 {
        вернути РезультатОбʼєктаЗначення {
          помилка = створити_помилку(
            компілятор,
            "Значення числа завелике для типу п16.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }

      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_п16,
          ПМ::створити_п16(компілятор.пм_модуль, п16(результат_розбору_позитивного_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_п32 {
      якщо спробувати_розібрати_позитивне_число(компілятор, значення, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      якщо результат_розбору_позитивного_числа > 4294967295 {
        вернути РезультатОбʼєктаЗначення {
          помилка = створити_помилку(
            компілятор,
            "Значення числа завелике для типу п32.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }

      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_п32,
          ПМ::створити_п32(компілятор.пм_модуль, п32(результат_розбору_позитивного_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_п64 {
      якщо спробувати_розібрати_позитивне_число(компілятор, значення, результат_розбору_позитивного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа

      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_п64,
          ПМ::створити_п64(компілятор.пм_модуль, п64(результат_розбору_позитивного_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_р32 {
      якщо спробувати_розібрати_дійсне_число(компілятор, значення, результат_розбору_дійсного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      змінна х: п32 = 2139095039;
      змінна д = х::адреса як адреса<р32>;

      якщо результат_розбору_дійсного_числа > д64(д::вміст) {
        вернути РезультатОбʼєктаЗначення {
          помилка = створити_помилку(
            компілятор,
            "Значення числа завелике для типу д32.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }

      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_р32,
          ПМ::створити_д32(компілятор.пм_модуль, д32(результат_розбору_дійсного_числа))
        },
        помилка = пусто
      };
    } інакше якщо очікуваний_тип == компілятор.тип_р64 {
      якщо спробувати_розібрати_дійсне_число(компілятор, значення, результат_розбору_дійсного_числа::адреса, помилка_розбору_числа::адреса, позиція_помилки_розбору_числа::адреса) == ні {
        змінна помилка = створити_помилку(
          компілятор,
          помилка_розбору_числа,
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        );
        звільнити_памʼять(компілятор, помилка_розбору_числа.дані);
        вернути РезультатОбʼєктаЗначення {
          помилка = помилка,
          ...
        };
      }

      // потім: перевірити межі числа

      вернути РезультатОбʼєктаЗначення {
        ОбʼєктЗначення {
          компілятор.тип_р64,
          ПМ::створити_д64(компілятор.пм_модуль, д64(результат_розбору_дійсного_числа))
        },
        помилка = пусто
      };
    } інакше {
      вернути РезультатОбʼєктаЗначення {
        помилка = створити_помилку(
          компілятор,
          "Не вдалось скомпілювати число.",
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        ),
        ...
      };
    }
  }

  місцева дія скомпілювати_число(компілятор: адреса<Компілятор>, контекст: Контекст, дані_числа: розбирач::ДаніСполукиЧисло, місцезнаходження: розбирач::Місцезнаходження, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєкта {
    змінна значення_т8 = т8 { 0, пусто };
    
    якщо не розбирач::отримати_значення_слова(
      ю8 { контекст.розібраний_текст.текст_коду.значення.розмір, контекст.розібраний_текст.текст_коду.значення.дані },
      контекст.розібраний_текст.слова.дані[дані_числа.позиція_слова],
      значення_т8::адреса
    ) {
      вернути РезультатОбʼєкта {
        помилка = створити_помилку(
          компілятор,
          "Не вдалось скомпілювати число.",
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        ),
        ...
      };
    }

    якщо очікуваний_тип == пусто {
      змінна обʼєкт_сирого_значення = виділити_обʼєкт_сирого_значення(компілятор);
      обʼєкт_сирого_значення.дані = значення_т8;

      вернути РезультатОбʼєкта {
        Обʼєкт {
          ВидОбʼєктаСиреЗначення,
          обʼєкт_сирого_значення
        },
        помилка = пусто
      };
    } інакше {
      змінна результат_розбору_числа = розібрати_число(компілятор, контекст, місцезнаходження, значення_т8, очікуваний_тип);

      звільнити_памʼять(компілятор, значення_т8.дані);

      якщо результат_розбору_числа.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_розбору_числа.помилка };
      }

      вернути РезультатОбʼєкта {
        Обʼєкт {
          ВидОбʼєктаЗначення,
          результат_розбору_числа.обʼєкт_значення
        },
        помилка = пусто
      };
    }

    вернути РезультатОбʼєкта {
      помилка = створити_помилку(
        компілятор,
        "Не вдалось скомпілювати число.",
        створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
      ),
      ...
    };
  }
}