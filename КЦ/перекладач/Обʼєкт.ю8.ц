взяти визначення КЦ;

секція КЦ {
  зовнішня дія скомпілювати_обʼєкт(компілятор: адреса<Компілятор>, контекст: Контекст, дані_обʼєкта: розбирач::ДаніСполукиОбʼєкт, місцезнаходження: розбирач::Місцезнаходження, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєкта {
    змінна обʼєкт_типу = очікуваний_тип;

    якщо дані_обʼєкта.ліво != пусто {
      змінна результат_компіляції_типу = скомпілювати_значення_як_тип(
        компілятор,
        контекст,
        дані_обʼєкта.ліво,
        так
      );

      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_компіляції_типу.помилка };
      }

      обʼєкт_типу = результат_компіляції_типу.обʼєкт_типу;
    }

    якщо обʼєкт_типу.вид != ВидОбʼєктаТипуСтруктура {
      вернути РезультатОбʼєкта {
        ...,
        помилка = створити_помилку(
          компілятор,
          "Неможливо скомпілювати обʼєкт.",
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        )
      };
    };

    змінна дані_структури = обʼєкт_типу.дані як ДаніОбʼєктаТипуСтруктура;

    змінна пм_значення = ПМ::вказівка_накопичити(
      контекст.кк_дії.крок_накопичень.пм_крок,
      обʼєкт_типу.пм_тип
    );

    змінна п: позитивне = 0;

    поки п < дані_обʼєкта.аргументи.розмір {
      змінна аргумент = дані_обʼєкта.аргументи.дані[п];

      змінна знайдено_параметр = ні;
      змінна параметр: Параметр;
      змінна позиція_параметра: позитивне = 0;

      якщо аргумент.ідентифікатор.заповнено == позитивне(так) {
        змінна назва_т8 = розбирач::отримати_значення_слова(
          т8 { контекст.розібраний_текст.текст_коду.значення.розмір, контекст.розібраний_текст.текст_коду.значення.дані },
          контекст.розібраний_текст.слова.дані[аргумент.ідентифікатор.значення.позиція_слова]
        );

        змінна пп: позитивне = 0;

        поки пп < дані_структури.параметри.розмір {
          якщо перевірити_назви(назва_зовнішня(назва_т8), дані_структури.параметри.дані[пп].назва, пусто) {
            знайдено_параметр = так;
            параметр = дані_структури.параметри.дані[пп];
            позиція_параметра = пп;
          }

          пп += 1;
        }
      } інакше якщо дані_структури.параметри.розмір > п {
        знайдено_параметр = так;
        параметр = дані_структури.параметри.дані[п];
        позиція_параметра = п;
      }

      якщо знайдено_параметр {
         змінна результат_аргумента = скомпілювати_значення_як_значення(
           компілятор,
           контекст,
           аргумент.значення,
           параметр.тип
         );

         якщо результат_аргумента.помилка != пусто {
           вернути РезультатОбʼєкта { ..., помилка = результат_аргумента.помилка };
         }

         змінна пм_позиції_аргумента = виділити_памʼять<адреса<ПМ::Значення>>(компілятор, 2);
         пм_позиції_аргумента[0] = ПМ::створити_п64(компілятор.пм_модуль, 0);
         пм_позиції_аргумента[1] = ПМ::створити_п64(компілятор.пм_модуль, позиція_параметра);
         змінна пм_значення_аргумента = ПМ::вказівка_отримати_адресу_елемента(
           контекст.кк_дії.поточний_крок.пм_крок,
           обʼєкт_типу.пм_тип,
           пм_значення,
           2,
           пм_позиції_аргумента
         );

         ПМ::вказівка_записати(
           контекст.кк_дії.поточний_крок.пм_крок,
           результат_аргумента.обʼєкт_значення.пм_значення,
           пм_значення_аргумента
         );
      } інакше {
        якщо аргумент.ідентифікатор.заповнено == позитивне(так) {
          вернути РезультатОбʼєкта {
            ...,
            помилка = створити_помилку(
              компілятор,
              "Неочікуваний аргумент.",
              створити_місцезнаходження_помилки_з_позиції_слова(компілятор, контекст.розібраний_текст, аргумент.ідентифікатор.значення.позиція_слова)
            )
          };
        } інакше {
          вернути РезультатОбʼєкта {
            ...,
            помилка = створити_помилку(
              компілятор,
              "Неочікуваний аргумент.",
              створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, аргумент.значення.місцезнаходження)
            )
          };
        }
      }

      п += 1;
    }

    вернути РезультатОбʼєкта {
      Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, ОбʼєктНезавантаженогоЗначення { обʼєкт_типу, пм_значення } },
      помилка = пусто
    };
  }
}