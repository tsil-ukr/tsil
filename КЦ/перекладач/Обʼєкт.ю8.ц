взяти визначення КЦ;

секція КЦ {
  зовнішня дія скомпілювати_обʼєкт(компілятор: адреса<Компілятор>, контекст: Контекст, дані_обʼєкта: розбирач::ДаніСполукиОбʼєкт, місцезнаходження: розбирач::Місцезнаходження, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєкта {
    змінна обʼєкт_типу = очікуваний_тип;

    якщо дані_обʼєкта.ліво != пусто {
      змінна результат_компіляції_типу = скомпілювати_значення_як_тип(
        компілятор,
        контекст,
        дані_обʼєкта.ліво,
        так
      );

      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_компіляції_типу.помилка };
      }

      обʼєкт_типу = результат_компіляції_типу.обʼєкт_типу;
    }

    якщо обʼєкт_типу.вид != ВидОбʼєктаТипуСтруктура {
      вернути РезультатОбʼєкта {
        помилка = створити_помилку(
          компілятор,
          "Неможливо скомпілювати обʼєкт.",
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        ),
        ...
      };
    };

    змінна дані_структури = обʼєкт_типу.дані як ДаніОбʼєктаТипуСтруктура;

    змінна пм_значення = ПМ::вказівка_накопичити(
      контекст.кк_дії.крок_накопичень.пм_крок,
      обʼєкт_типу.пм_тип
    );

    змінна п: позитивне = 0;

    змінна заповнені_параметри = виділити_памʼять<п8>(компілятор, дані_структури.параметри.розмір);

    поки п < дані_структури.параметри.розмір {
      заповнені_параметри[п] = 0;

      п += 1;
    }

    п = 0;

    поки п < дані_обʼєкта.аргументи.розмір {
      змінна аргумент = дані_обʼєкта.аргументи.дані[п];

      змінна знайдено_параметр = ні;
      змінна параметр: Параметр;
      змінна позиція_параметра: позитивне = 0;

      якщо аргумент.ідентифікатор.заповнено == позитивне(так) {
        змінна назва_т8 = розбирач::отримати_значення_слова(
          т8 { контекст.розібраний_текст.текст_коду.значення.розмір, контекст.розібраний_текст.текст_коду.значення.дані },
          контекст.розібраний_текст.слова.дані[аргумент.ідентифікатор.значення.позиція_слова]
        );

        змінна пп: позитивне = 0;

        поки пп < дані_структури.параметри.розмір {
          якщо перевірити_назви_з_реєстру(назва_зовнішня(назва_т8), дані_структури.параметри.дані[пп].назва, пусто) {
            знайдено_параметр = так;
            параметр = дані_структури.параметри.дані[пп];
            позиція_параметра = пп;
          }

          пп += 1;
        }
      } інакше якщо дані_структури.параметри.розмір > п {
        знайдено_параметр = так;
        параметр = дані_структури.параметри.дані[п];
        позиція_параметра = п;
      }

      якщо знайдено_параметр {
        заповнені_параметри[позиція_параметра] = 1;

        змінна результат_аргумента = скомпілювати_значення_як_значення(
          компілятор,
          контекст,
          аргумент.значення,
          параметр.тип
        );

        якщо результат_аргумента.помилка != пусто {
          звільнити_памʼять(компілятор, заповнені_параметри);

          вернути РезультатОбʼєкта { помилка = результат_аргумента.помилка, ... };
        }

        змінна пм_позиції_аргумента = виділити_памʼять<адреса<ПМ::Значення>>(компілятор, 2);
        пм_позиції_аргумента[0] = ПМ::створити_п32(компілятор.пм_модуль, 0);
        пм_позиції_аргумента[1] = ПМ::створити_п32(компілятор.пм_модуль, п32(позиція_параметра));
        змінна пм_значення_аргумента = ПМ::вказівка_отримати_адресу_елемента(
          контекст.кк_дії.поточний_крок.пм_крок,
          обʼєкт_типу.пм_тип,
          пм_значення,
          2,
          пм_позиції_аргумента
        );

        ПМ::вказівка_записати(
          контекст.кк_дії.поточний_крок.пм_крок,
          результат_аргумента.обʼєкт_значення.пм_значення,
          пм_значення_аргумента
        );
      } інакше {
        якщо аргумент.ідентифікатор.заповнено == позитивне(так) {
          звільнити_памʼять(компілятор, заповнені_параметри);

          вернути РезультатОбʼєкта {
            помилка = створити_помилку(
              компілятор,
              "Неочікуваний аргумент.",
              створити_місцезнаходження_помилки_з_позиції_слова(компілятор, контекст.розібраний_текст, аргумент.ідентифікатор.значення.позиція_слова)
            ),
            ...
          };
        } інакше {
          звільнити_памʼять(компілятор, заповнені_параметри);

          вернути РезультатОбʼєкта {
            помилка = створити_помилку(
              компілятор,
              "Неочікуваний аргумент.",
              створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, аргумент.значення.місцезнаходження)
            ),
            ...
          };
        }
      }

      п += 1;
    }

    п = 0;

    якщо дані_обʼєкта.аргументи.автозаповнити == позитивне(ні) {
      поки п < дані_структури.параметри.розмір {
        якщо заповнені_параметри[п] == 0 {
          звільнити_памʼять(компілятор, заповнені_параметри);

          вернути РезультатОбʼєкта {
            помилка = створити_помилку(
              компілятор,
              "Пропущено аргумент.",
              створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
            ),
            ...
          };
        }

        п += 1;
      }
    }

    звільнити_памʼять(компілятор, заповнені_параметри);

    вернути РезультатОбʼєкта {
      Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, ОбʼєктНезавантаженогоЗначення { обʼєкт_типу, пм_значення } },
      помилка = пусто
    };
  }
}