взяти визначення КЦ;

секція КЦ {
  зовнішня дія скомпілювати_значення(компілятор: адреса<Компілятор>, контекст: Контекст, контекст_виконання_шаблону: адреса<КонтекстКомпіляціїВиконанняШаблону>, сполука: адреса<розбирач::Сполука>, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєкта {
    якщо сполука.вид == розбирач::ВидСполукиПрочитати {
      змінна дані = сполука.дані як розбирач::ДаніСполукиПрочитати;
      вернути скомпілювати_отримати_з_середовища(компілятор, контекст, дані, сполука.місцезнаходження, очікуваний_тип);
    } інакше якщо сполука.вид == розбирач::ВидСполукиЧисло {
      змінна дані = сполука.дані як розбирач::ДаніСполукиЧисло;
      вернути скомпілювати_число(компілятор, контекст, дані, сполука.місцезнаходження, очікуваний_тип);
    } інакше якщо сполука.вид == розбирач::ВидСполукиТекст {
      змінна дані = сполука.дані як розбирач::ДаніСполукиТекст;
      вернути скомпілювати_текст(компілятор, контекст, дані, сполука.місцезнаходження);
    } інакше якщо сполука.вид == розбирач::ВидСполукиВиконатиШаблон {
      змінна дані = сполука.дані як розбирач::ДаніСполукиВиконатиШаблон;
      вернути скомпілювати_виконати_шаблон(компілятор, контекст, дані, сполука.місцезнаходження, очікуваний_тип);
    } інакше якщо сполука.вид == розбирач::ВидСполукиОперація {
      змінна дані = сполука.дані як розбирач::ДаніСполукиОперація;
      вернути скомпілювати_операцію(компілятор, контекст, дані, сполука.місцезнаходження);
    } інакше якщо сполука.вид == розбирач::ВидСполукиОднооперація {
      змінна дані = сполука.дані як розбирач::ДаніСполукиОднооперація;
      вернути скомпілювати_однооперацію(компілятор, контекст, дані, сполука.місцезнаходження);
    } інакше якщо сполука.вид == розбирач::ВидСполукиОтриматиВластивість {
      змінна дані = сполука.дані як розбирач::ДаніСполукиОтриматиВластивість;
      вернути скомпілювати_отримати_властивість(компілятор, контекст, дані, сполука.місцезнаходження, очікуваний_тип);
    } інакше якщо сполука.вид == розбирач::ВидСполукиОтриматиЕлемент {
      змінна дані = сполука.дані як розбирач::ДаніСполукиОтриматиЕлемент;
      вернути скомпілювати_отримати_елемент(компілятор, контекст, дані, сполука.місцезнаходження, очікуваний_тип);
    } інакше якщо сполука.вид == розбирач::ВидСполукиОтриматиСекційнуВластивість {
      змінна дані = сполука.дані як розбирач::ДаніСполукиОтриматиСекційнуВластивість;
      вернути скомпілювати_отримати_секційну_властивість(компілятор, контекст, дані, сполука.місцезнаходження, очікуваний_тип);
    } інакше якщо сполука.вид == розбирач::ВидСполукиОбʼєкт {
      змінна дані = сполука.дані як розбирач::ДаніСполукиОбʼєкт;
      вернути скомпілювати_обʼєкт(компілятор, контекст, дані, сполука.місцезнаходження, очікуваний_тип);
    } інакше якщо сполука.вид == розбирач::ВидСполукиВиконатиДію {
      змінна дані = сполука.дані як розбирач::ДаніСполукиВиконатиДію;
      вернути скомпілювати_виконати_дію(компілятор, контекст, дані, сполука.місцезнаходження, очікуваний_тип);
    } інакше якщо сполука.вид == розбирач::ВидСполукиДія {
      змінна дані = сполука.дані як розбирач::ДаніСполукиДія;
      змінна результат = скомпілювати_дію(компілятор, контекст, контекст_виконання_шаблону, пусто, дані, сполука.місцезнаходження);
      якщо результат.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат.помилка, ... };
      }
      вернути РезультатОбʼєкта { Обʼєкт { ВидОбʼєктаДія, результат.обʼєкт_дії }, помилка = пусто };
    } інакше якщо сполука.вид == розбирач::ВидСполукиСтруктура {
      змінна дані = сполука.дані як розбирач::ДаніСполукиСтруктура;
      змінна результат = скомпілювати_структуру(компілятор, контекст, контекст_виконання_шаблону, пусто, дані, сполука.місцезнаходження);
      якщо результат.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат.помилка, ... };
      }
      вернути РезультатОбʼєкта { Обʼєкт { ВидОбʼєктаТип, результат.обʼєкт_типу }, помилка = пусто };
    } інакше якщо сполука.вид == розбирач::ВидСполукиТипДії {
      змінна дані = сполука.дані як розбирач::ДаніСполукиТипДії;
      змінна результат = скомпілювати_тип_дії(компілятор, контекст, дані, сполука.місцезнаходження);
      якщо результат.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат.помилка, ... };
      }
      вернути РезультатОбʼєкта { Обʼєкт { ВидОбʼєктаТип, результат.обʼєкт_типу }, помилка = пусто };
    } інакше якщо сполука.вид == розбирач::ВидСполукиВаріативнийТип {
      змінна дані = сполука.дані як розбирач::ДаніСполукиВаріативнийТип;
      змінна результат = скомпілювати_варіативний_тип(компілятор, контекст, дані, сполука.місцезнаходження);
      якщо результат.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат.помилка, ... };
      }
      вернути РезультатОбʼєкта { Обʼєкт { ВидОбʼєктаТип, результат.обʼєкт_типу }, помилка = пусто };
    } інакше якщо сполука.вид == розбирач::ВидСполукиШаблон {
      змінна дані = сполука.дані як розбирач::ДаніСполукиШаблон;
      змінна результат = скомпілювати_шаблон(компілятор, контекст, дані, сполука.місцезнаходження);
      якщо результат.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат.помилка, ... };
      }
      вернути РезультатОбʼєкта { Обʼєкт { ВидОбʼєктаШаблон, результат.обʼєкт_шаблону }, помилка = пусто };
    }

    вернути РезультатОбʼєкта {
      помилка = створити_помилку(
        компілятор,
        "Не вдалось скомпілювати значення.",
        створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, сполука.місцезнаходження)
      ),
      ...
    };
  }

  зовнішня дія скомпілювати_значення_як_значення(компілятор: адреса<Компілятор>, контекст: Контекст, сполука: адреса<розбирач::Сполука>, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєктаЗначення {
    змінна результат_значення = скомпілювати_значення(компілятор, контекст, пусто, сполука, очікуваний_тип);

    якщо результат_значення.помилка != пусто {
      вернути РезультатОбʼєктаЗначення {
        помилка = результат_значення.помилка,
        ...
      };
    }

    вернути отримати_як_значення(компілятор, контекст, сполука.місцезнаходження, результат_значення.обʼєкт, очікуваний_тип);
  }

  зовнішня дія отримати_як_тип(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт: Обʼєкт, перевірка_на_повність: логічне): РезультатОбʼєктаТипу {
    якщо обʼєкт.вид != ВидОбʼєктаТип {
      вернути РезультатОбʼєктаТипу {
        помилка = створити_помилку(
          компілятор,
          "Значення повинно бути типом.",
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        ),
        ...
      };
    }

    змінна обʼєкт_типу = обʼєкт.дані як адреса<ОбʼєктТипу>;

    якщо перевірка_на_повність {
      якщо перевірити_чи_тип_повний(компілятор, обʼєкт_типу) == ні {
        вернути РезультатОбʼєктаТипу {
          помилка = створити_помилку(
            компілятор,
            "Неповний тип.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }
    }

    вернути РезультатОбʼєктаТипу { обʼєкт_типу, помилка = пусто };
  }

  зовнішня дія отримати_як_значення(компілятор: адреса<Компілятор>, контекст: Контекст, місцезнаходження: розбирач::Місцезнаходження, обʼєкт: Обʼєкт, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєктаЗначення {
    якщо обʼєкт.вид == ВидОбʼєктаЗначення {
      змінна обʼєкт_значення = обʼєкт.дані як ОбʼєктЗначення;
      вернути РезультатОбʼєктаЗначення { обʼєкт_значення, помилка = пусто };
    }

    якщо обʼєкт.вид == ВидОбʼєктаНезавантаженеЗначення {
      змінна обʼєкт_незавантаженого_значення = обʼєкт.дані як ОбʼєктНезавантаженогоЗначення;

      якщо контекст.кк_дії == пусто {
        вернути РезультатОбʼєктаЗначення {
          помилка = створити_помилку(
            компілятор,
            "Неможливо прочитати значення поза тілом дії.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          ),
          ...
        };
      }

      змінна пм_завантажене_значення = ПМ::вказівка_прочитати(
        контекст.кк_дії.поточний_крок.пм_крок,
        обʼєкт_незавантаженого_значення.тип.пм_тип,
        обʼєкт_незавантаженого_значення.пм_значення
      );

      змінна обʼєкт_значення = ОбʼєктЗначення {
        обʼєкт_незавантаженого_значення.тип,
        пм_завантажене_значення
      };

      вернути РезультатОбʼєктаЗначення { обʼєкт_значення, помилка = пусто };
    }

    якщо обʼєкт.вид == ВидОбʼєктаДія {
      змінна обʼєкт_дії = обʼєкт.дані як адреса<ОбʼєктДії>;

      вернути РезультатОбʼєктаЗначення { ОбʼєктЗначення { обʼєкт_дії.тип, обʼєкт_дії.пм_інструкція як адреса<ПМ::Значення> }, помилка = пусто };
    }

    якщо обʼєкт.вид == ВидОбʼєктаСиреЗначення {
      змінна обʼєкт_сирого_значення = обʼєкт.дані як адреса<ОбʼєктСирогоЗначення>;

      якщо обʼєкт_сирого_значення.вид == ВидСирогоОбʼєктаЧисло {
        вернути розібрати_число(компілятор, контекст, місцезнаходження, обʼєкт_сирого_значення.дані, очікуваний_тип);
      }
    }

    вернути РезультатОбʼєктаЗначення {
      помилка = створити_помилку(
        компілятор,
        "Значення повинно бути значенням.",
        створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
      ),
      ...
    };
  }

  зовнішня дія скомпілювати_значення_як_тип(компілятор: адреса<Компілятор>, контекст: Контекст, сполука: адреса<розбирач::Сполука>, перевірка_на_повність: логічне): РезультатОбʼєктаТипу {
    змінна результат_значення = скомпілювати_значення(компілятор, контекст, пусто, сполука, пусто);

    якщо результат_значення.помилка != пусто {
      вернути РезультатОбʼєктаТипу {
        помилка = результат_значення.помилка,
        ...
      };
    }

    вернути отримати_як_тип(компілятор, контекст, сполука.місцезнаходження, результат_значення.обʼєкт, перевірка_на_повність);
  }
}