взяти визначення КЦ;

секція КЦ {
  зовнішня дія скомпілювати_текст(компілятор: адреса<Компілятор>, контекст: Контекст, дані_тексту: розбирач::ДаніСполукиТекст, місцезнаходження: розбирач::Місцезнаходження): РезультатОбʼєкта {
    змінна значення_т8 = розбирач::отримати_значення_слова(
      т8 { контекст.розібраний_текст.текст_коду.значення.розмір, контекст.розібраний_текст.текст_коду.значення.дані },
      контекст.розібраний_текст.слова.дані[дані_тексту.позиція_слова]
    );
    значення_т8.розмір -= 2;
    значення_т8.дані = значення_т8.дані[1]::адреса як памʼять<п8>;

    змінна тип_значення = компілятор.тип_т8;
    змінна розмір_значення: позитивне = 0;
    змінна дані_значення: памʼять<п8> = пусто;
    змінна значення_треба_звільнити = ні;

    якщо дані_тексту.префікс.заповнено == позитивне(так) {
      змінна префікс_т8 = розбирач::отримати_значення_слова(
        т8 { контекст.розібраний_текст.текст_коду.значення.розмір, контекст.розібраний_текст.текст_коду.значення.дані },
        контекст.розібраний_текст.слова.дані[дані_тексту.префікс.значення.позиція_слова]
      );

      якщо біб::перевірити_чи_т8_рівні(префікс_т8, "т8") {
        розмір_значення = значення_т8.розмір;
        дані_значення = значення_т8.дані;
      } інакше якщо біб::перевірити_чи_т8_рівні(префікс_т8, "ю8") {
        змінна значення_ю8 = отримати_ю8_з_т8(компілятор, значення_т8);
        тип_значення = компілятор.тип_ю8;
        розмір_значення = значення_ю8.розмір;
        дані_значення = значення_ю8.дані;
        значення_треба_звільнити = так;
      } інакше {
        вернути РезультатОбʼєкта {
          ...,
          помилка = створити_помилку(
            компілятор,
            "Неможливо створити текст.",
            створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
          )
        };
      }
    } інакше {
      розмір_значення = значення_т8.розмір;
      дані_значення = значення_т8.дані;
    }

    змінна пм_значення_розміру = ПМ::створити_п64(компілятор.пм_модуль, розмір_значення);
    змінна пм_значення_даних: адреса<ПМ::Значення> = пусто;
    якщо розмір_значення == 0 {
      пм_значення_даних = ПМ::отримати_значення_пусто(компілятор.пм_модуль);
    } інакше {
      пм_значення_даних = ПМ::створити_байти(компілятор.пм_модуль, розмір_значення, дані_значення);
    }

    змінна пм_значення = ПМ::вказівка_накопичити(
      контекст.кк_дії.крок_накопичень.пм_крок,
      тип_значення.пм_тип
    );

    змінна пм_позиції_адреси_розміру = виділити_памʼять<адреса<ПМ::Значення>>(компілятор, 2);
    пм_позиції_адреси_розміру[0] = ПМ::створити_п32(компілятор.пм_модуль, 0);
    пм_позиції_адреси_розміру[1] = ПМ::створити_п32(компілятор.пм_модуль, 0);
    змінна пм_значення_адреси_розміру = ПМ::вказівка_отримати_адресу_елемента(
      контекст.кк_дії.поточний_крок.пм_крок,
      тип_значення.пм_тип,
      пм_значення,
      2,
      пм_позиції_адреси_розміру
    );
    ПМ::вказівка_записати(
      контекст.кк_дії.поточний_крок.пм_крок,
      пм_значення_розміру,
      пм_значення_адреси_розміру
    );

    змінна пм_позиції_адреси_даних = виділити_памʼять<адреса<ПМ::Значення>>(компілятор, 2);
    пм_позиції_адреси_даних[0] = ПМ::створити_п32(компілятор.пм_модуль, 0);
    пм_позиції_адреси_даних[1] = ПМ::створити_п32(компілятор.пм_модуль, 1);
    змінна пм_значення_адреси_даних = ПМ::вказівка_отримати_адресу_елемента(
      контекст.кк_дії.поточний_крок.пм_крок,
      тип_значення.пм_тип,
      пм_значення,
      2,
      пм_позиції_адреси_даних
    );
    ПМ::вказівка_записати(
      контекст.кк_дії.поточний_крок.пм_крок,
      пм_значення_даних,
      пм_значення_адреси_даних
    );

    вернути РезультатОбʼєкта { Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, ОбʼєктНезавантаженогоЗначення { тип_значення, пм_значення } }, помилка = пусто };
  }
}