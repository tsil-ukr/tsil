взяти визначення КЦ;

секція КЦ {
  місцева дія скомпілювати_обʼєкт(компілятор: адреса<Компілятор>, контекст: Контекст, дані_обʼєкта: розбирач::ДаніСполукиОбʼєкт, місцезнаходження: розбирач::Місцезнаходження, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатОбʼєкта {
    змінна обʼєкт_типу = очікуваний_тип;

    якщо дані_обʼєкта.ліво != пусто {
      змінна результат_компіляції_типу = скомпілювати_значення_як_тип(
        компілятор,
        контекст,
        дані_обʼєкта.ліво,
        так
      );

      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_компіляції_типу.помилка };
      }

      обʼєкт_типу = результат_компіляції_типу.обʼєкт_типу;
    }

    якщо обʼєкт_типу.вид != ВидОбʼєктаТипуСтруктура {
      вернути РезультатОбʼєкта {
        помилка = створити_помилку(
          компілятор,
          "Неможливо скомпілювати обʼєкт.",
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
        ),
        ...
      };
    };

    змінна дані_структури = обʼєкт_типу.дані як ДаніОбʼєктаТипуСтруктура;

    якщо контекст.кк_дії == пусто {
      змінна кількість_аргументів = дані_структури.параметри.розмір;
      змінна аргументи = виділити_памʼять<адреса<ПМ::Значення>>(компілятор, дані_структури.параметри.розмір);
      змінна п: природне = 0;

      змінна заповнені_параметри = виділити_памʼять<п8>(компілятор, дані_структури.параметри.розмір);
      поки п < дані_структури.параметри.розмір {
        заповнені_параметри[п] = 0;
        п += 1;
      }

      п = 0;

      поки п < дані_обʼєкта.аргументи.розмір {
        змінна аргумент = дані_обʼєкта.аргументи.дані[п];

        змінна знайдено_параметр = ні;
        змінна параметр: Параметр;
        змінна позиція_параметра: природне = 0;

        якщо аргумент.ідентифікатор.заповнено {
          змінна назва_т8 = т8 { 0, пусто };

          якщо не розбирач::отримати_значення_слова(
            контекст.розібраний_текст.текст_коду.значення,
            контекст.розібраний_текст.слова.дані[аргумент.ідентифікатор.значення.позиція_слова],
            назва_т8::адреса
          ) {
            звільнити_памʼять(компілятор, аргументи);
            звільнити_памʼять(компілятор, заповнені_параметри);

            вернути РезультатОбʼєкта {
              помилка = створити_помилку(
                компілятор,
                "Не вдалось отримати назву параметра.",
                створити_місцезнаходження_помилки_з_позиції_слова(компілятор, контекст.розібраний_текст, аргумент.ідентифікатор.значення.позиція_слова)
              ),
              ...
            };
          }

          змінна назва = назва_без_копіювання(компілятор, назва_т8);

          змінна пп: природне = 0;

          поки пп < дані_структури.параметри.розмір {
            якщо назва == дані_структури.параметри.дані[пп].назва {
              знайдено_параметр = так;
              параметр = дані_структури.параметри.дані[пп];
              позиція_параметра = пп;
            }

            пп += 1;
          }
        } інакше якщо дані_структури.параметри.розмір > п {
          знайдено_параметр = так;
          параметр = дані_структури.параметри.дані[п];
          позиція_параметра = п;
        }

        якщо знайдено_параметр {
          заповнені_параметри[позиція_параметра] = 1;

          змінна результат_аргумента = скомпілювати_значення_як_значення(
            компілятор,
            контекст,
            аргумент.значення,
            параметр.тип
          );

          якщо результат_аргумента.помилка != пусто {
            звільнити_памʼять(компілятор, аргументи);
            звільнити_памʼять(компілятор, заповнені_параметри);

            вернути РезультатОбʼєкта { помилка = результат_аргумента.помилка, ... };
          }

          якщо перевірити_тип_на_запис_і_конвертувати_якщо_треба(компілятор, параметр.тип, результат_аргумента.обʼєкт_значення::адреса) == ні {
            звільнити_памʼять(компілятор, аргументи);
            звільнити_памʼять(компілятор, заповнені_параметри);

            вернути РезультатОбʼєкта {
              помилка = створити_помилку_невірний_тип_значення(
                компілятор,
                Місцезнаходження { контекст.розібраний_текст, аргумент.значення.місцезнаходження.позиція_початкового_слова },
                параметр.тип,
                результат_аргумента.обʼєкт_значення.тип
              ),
              ...
            };
          }

          аргументи[позиція_параметра] = результат_аргумента.обʼєкт_значення.пм_значення;
        } інакше {
          якщо аргумент.ідентифікатор.заповнено {
            звільнити_памʼять(компілятор, аргументи);
            звільнити_памʼять(компілятор, заповнені_параметри);

            вернути РезультатОбʼєкта {
              помилка = створити_помилку(
                компілятор,
                "Неочікуваний аргумент.",
                створити_місцезнаходження_помилки_з_позиції_слова(компілятор, контекст.розібраний_текст, аргумент.ідентифікатор.значення.позиція_слова)
              ),
              ...
            };
          } інакше {
            звільнити_памʼять(компілятор, аргументи);
            звільнити_памʼять(компілятор, заповнені_параметри);

            вернути РезультатОбʼєкта {
              помилка = створити_помилку(
                компілятор,
                "Неочікуваний аргумент.",
                створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, аргумент.значення.місцезнаходження)
              ),
              ...
            };
          }
        }

        п += 1;
      }

      п = 0;

      звільнити_памʼять(компілятор, заповнені_параметри);

      змінна пм_значення = ПМ::створити_обʼєкт(
        компілятор.пм_модуль,
        обʼєкт_типу.пм_тип,
        кількість_аргументів,
        аргументи
      );

      вернути РезультатОбʼєкта {
        Обʼєкт { ВидОбʼєктаЗначення, ОбʼєктЗначення { обʼєкт_типу, пм_значення } },
        помилка = пусто
      };
    } інакше {
      змінна пм_значення = ПМ::вказівка_накопичити(
        контекст.кк_дії.крок_накопичень.пм_крок,
        обʼєкт_типу.пм_тип
      );

      змінна п: природне = 0;

      змінна заповнені_параметри = виділити_памʼять<п8>(компілятор, дані_структури.параметри.розмір);
      поки п < дані_структури.параметри.розмір {
        заповнені_параметри[п] = 0;
        п += 1;
      }

      п = 0;

      поки п < дані_обʼєкта.аргументи.розмір {
        змінна аргумент = дані_обʼєкта.аргументи.дані[п];

        змінна знайдено_параметр = ні;
        змінна параметр: Параметр;
        змінна позиція_параметра: природне = 0;

        якщо аргумент.ідентифікатор.заповнено {
          змінна назва_т8 = т8 { 0, пусто };
          
          якщо не розбирач::отримати_значення_слова(
            ю8 { контекст.розібраний_текст.текст_коду.значення.розмір, контекст.розібраний_текст.текст_коду.значення.дані },
            контекст.розібраний_текст.слова.дані[аргумент.ідентифікатор.значення.позиція_слова],
            назва_т8::адреса
          ) {
            звільнити_памʼять(компілятор, заповнені_параметри);

            вернути РезультатОбʼєкта {
              помилка = створити_помилку(
                компілятор,
                "Не вдалось отримати назву параметра.",
                створити_місцезнаходження_помилки_з_позиції_слова(компілятор, контекст.розібраний_текст, аргумент.ідентифікатор.значення.позиція_слова)
              ),
              ...
            };
          }

          змінна назва = назва_без_копіювання(компілятор, назва_т8);

          змінна пп: природне = 0;

          поки пп < дані_структури.параметри.розмір {
            якщо назва == дані_структури.параметри.дані[пп].назва {
              знайдено_параметр = так;
              параметр = дані_структури.параметри.дані[пп];
              позиція_параметра = пп;
            }

            пп += 1;
          }
        } інакше якщо дані_структури.параметри.розмір > п {
          знайдено_параметр = так;
          параметр = дані_структури.параметри.дані[п];
          позиція_параметра = п;
        }

        якщо знайдено_параметр {
          заповнені_параметри[позиція_параметра] = 1;

          змінна результат_аргумента = скомпілювати_значення_як_значення(
            компілятор,
            контекст,
            аргумент.значення,
            параметр.тип
          );

          якщо результат_аргумента.помилка != пусто {
            звільнити_памʼять(компілятор, заповнені_параметри);

            вернути РезультатОбʼєкта { помилка = результат_аргумента.помилка, ... };
          }

          якщо перевірити_тип_на_запис_і_конвертувати_якщо_треба(компілятор, параметр.тип, результат_аргумента.обʼєкт_значення::адреса) == ні {
            звільнити_памʼять(компілятор, заповнені_параметри);

            вернути РезультатОбʼєкта {
              помилка = створити_помилку_невірний_тип_значення(
                компілятор,
                Місцезнаходження { контекст.розібраний_текст, аргумент.значення.місцезнаходження.позиція_початкового_слова },
                параметр.тип,
                результат_аргумента.обʼєкт_значення.тип
              ),
              ...
            };
          }

          змінна пм_позиції_аргумента = виділити_памʼять<адреса<ПМ::Значення>>(компілятор, 2);
          пм_позиції_аргумента[0] = ПМ::створити_п32(компілятор.пм_модуль, 0);
          пм_позиції_аргумента[1] = ПМ::створити_п32(компілятор.пм_модуль, п32(позиція_параметра));
          змінна пм_значення_аргумента = ПМ::вказівка_отримати_адресу_елемента(
            контекст.кк_дії.поточний_крок.пм_крок,
            обʼєкт_типу.пм_тип,
            пм_значення,
            2,
            пм_позиції_аргумента
          );

          звільнити_памʼять(компілятор, пм_позиції_аргумента);

          ПМ::вказівка_записати(
            контекст.кк_дії.поточний_крок.пм_крок,
            результат_аргумента.обʼєкт_значення.пм_значення,
            пм_значення_аргумента
          );
        } інакше {
          якщо аргумент.ідентифікатор.заповнено {
            звільнити_памʼять(компілятор, заповнені_параметри);

            вернути РезультатОбʼєкта {
              помилка = створити_помилку(
                компілятор,
                "Неочікуваний аргумент.",
                створити_місцезнаходження_помилки_з_позиції_слова(компілятор, контекст.розібраний_текст, аргумент.ідентифікатор.значення.позиція_слова)
              ),
              ...
            };
          } інакше {
            звільнити_памʼять(компілятор, заповнені_параметри);

            вернути РезультатОбʼєкта {
              помилка = створити_помилку(
                компілятор,
                "Неочікуваний аргумент.",
                створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, аргумент.значення.місцезнаходження)
              ),
              ...
            };
          }
        }

        п += 1;
      }

      п = 0;

      якщо не дані_обʼєкта.аргументи.автозаповнити {
        поки п < дані_структури.параметри.розмір {
          якщо заповнені_параметри[п] == 0 {
            звільнити_памʼять(компілятор, заповнені_параметри);

            вернути РезультатОбʼєкта {
              помилка = створити_помилку(
                компілятор,
                "Пропущено аргумент.",
                створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
              ),
              ...
            };
          }

          п += 1;
        }
      }

      звільнити_памʼять(компілятор, заповнені_параметри);

      вернути РезультатОбʼєкта {
        Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, ОбʼєктНезавантаженогоЗначення { обʼєкт_типу, пм_значення } },
        помилка = пусто
      };
    }
  }
}