взяти визначення КЦ;

секція КЦ {
  місцева дія скомпілювати_операцію(компілятор: адреса<Компілятор>, контекст: Контекст, дані_операції: розбирач::ДаніСполукиОперація, місцезнаходження: розбирач::Місцезнаходження): РезультатОбʼєкта {
    змінна результат_ліво = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.ліво, пусто);
    якщо результат_ліво.помилка != пусто {
      вернути РезультатОбʼєкта { ..., помилка = результат_ліво.помилка };
    }

    змінна очікуваний_тип_право: адреса<ОбʼєктТипу> = пусто;

    якщо результат_ліво.обʼєкт.вид == ВидОбʼєктаЗначення {
      змінна дані_обʼєкта = результат_ліво.обʼєкт.дані як ОбʼєктЗначення;
      очікуваний_тип_право = дані_обʼєкта.тип;
    } інакше якщо результат_ліво.обʼєкт.вид == ВидОбʼєктаНезавантаженеЗначення {
      змінна дані_обʼєкта = результат_ліво.обʼєкт.дані як ОбʼєктНезавантаженогоЗначення;
      очікуваний_тип_право = дані_обʼєкта.тип;
    }

    змінна ліво = результат_ліво.обʼєкт;

    якщо дані_операції.вид == розбирач::ВидОпераціїДодавання {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_додати(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїВіднімання {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_відняти(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїМноження {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_помножити(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїДілення {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_поділити(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїМодуль {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_поділити_за_модулем(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїЗсувВліво {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_зсунути_вліво(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїЗсувВправо {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_зсунути_вправо(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїБільше {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_більше(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїМенше {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_менше(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїБільшеРівне {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_більше_рівно(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїМеншеРівне {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_менше_рівно(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїРівне {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_рівно(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїНерівне {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_не_рівно(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїДІ {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_ді(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїДАБО {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_дабо(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїВАБО {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_вабо(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїІ {
      змінна результат_обʼєкт_значення_ліво = отримати_як_значення(
        компілятор,
        контекст,
        місцезнаходження,
        ліво,
        компілятор.тип_логічне
      );
      якщо результат_обʼєкт_значення_ліво.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат_обʼєкт_значення_ліво.помилка, ... };
      }

      змінна обʼєкт_значення = результат_обʼєкт_значення_ліво.обʼєкт_значення;

      змінна пм_значення_результату = ПМ::вказівка_накопичити(
        контекст.кк_дії.крок_накопичень.пм_крок,
        компілятор.тип_логічне.пм_тип
      );

      змінна крок_інакше = ПМ::створити_крок(контекст.кк_дії.обʼєкт_дії.пм_інструкція, отримати_назву(компілятор, "або_інакше"));
      змінна крок_успіху = ПМ::створити_крок(контекст.кк_дії.обʼєкт_дії.пм_інструкція, отримати_назву(компілятор, "або_успіх"));
      змінна крок_невдачі = ПМ::створити_крок(контекст.кк_дії.обʼєкт_дії.пм_інструкція, отримати_назву(компілятор, "або_невдача"));
      змінна крок_виходу = ПМ::створити_крок(контекст.кк_дії.обʼєкт_дії.пм_інструкція, отримати_назву(компілятор, "або_вихід"));

      ПМ::вказівка_записати(
        крок_успіху,
        компілятор.обʼєкт_значення_так.пм_значення,
        пм_значення_результату
      );
      ПМ::вказівка_стрибнути(
        крок_успіху,
        крок_виходу
      );

      ПМ::вказівка_записати(
        крок_невдачі,
        компілятор.обʼєкт_значення_ні.пм_значення,
        пм_значення_результату
      );
      ПМ::вказівка_стрибнути(
        крок_невдачі,
        крок_виходу
      );

      змінна аргумент1_нуль: Аргумент;
      якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц8, ПМ::створити_ц8(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц16, ПМ::створити_ц16(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц32, ПМ::створити_ц32(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц64, ПМ::створити_ц64(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_логічне, ПМ::створити_логічне(компілятор.пм_модуль, ні) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п8, ПМ::створити_п8(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п16, ПМ::створити_п16(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п32, ПМ::створити_п32(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п64, ПМ::створити_п64(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_д32, ПМ::створити_д32(компілятор.пм_модуль, 0.0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_д64, ПМ::створити_д64(компілятор.пм_модуль, 0.0) } }, місцезнаходження };
      } інакше {
        вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
      }
      змінна результат_рівно_ліво = обʼєкт_значення_рівно(компілятор, контекст, місцезнаходження, обʼєкт_значення, аргумент1_нуль);
      якщо результат_рівно_ліво.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат_рівно_ліво.помилка, ... };
      }
      змінна результат_обʼєкт_значення_рівно_ліво = отримати_як_значення(
        компілятор,
        контекст,
        місцезнаходження,
        результат_рівно_ліво.обʼєкт,
        компілятор.тип_логічне
      );
      якщо результат_обʼєкт_значення_рівно_ліво.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат_обʼєкт_значення_рівно_ліво.помилка, ... };
      }
      якщо результат_обʼєкт_значення_рівно_ліво.обʼєкт_значення.тип != компілятор.тип_логічне {
        вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
      }
      ПМ::вказівка_стрибнути_якщо(
        контекст.кк_дії.поточний_крок.пм_крок,
        результат_обʼєкт_значення_рівно_ліво.обʼєкт_значення.пм_значення,
        крок_невдачі,
        крок_інакше
      );


      контекст.кк_дії.поточний_крок = Крок {
        отримати_назву(компілятор, "або_інакше"),
        контекст.кк_дії.обʼєкт_дії,
        крок_інакше
      };

      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      змінна результат_обʼєкт_значення_право = отримати_як_значення(
        компілятор,
        контекст,
        дані_операції.право.місцезнаходження,
        результат_право.обʼєкт,
        пусто
      );
      якщо результат_обʼєкт_значення_право.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат_обʼєкт_значення_право.помилка, ... };
      }
      змінна аргумент2_нуль: Аргумент;
      якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_ц8 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц8, ПМ::створити_ц8(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_ц16 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц16, ПМ::створити_ц16(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_ц32 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц32, ПМ::створити_ц32(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_ц64 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц64, ПМ::створити_ц64(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_логічне {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_логічне, ПМ::створити_логічне(компілятор.пм_модуль, ні) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_п8 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п8, ПМ::створити_п8(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_п16 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п16, ПМ::створити_п16(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_п32 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п32, ПМ::створити_п32(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_п64 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п64, ПМ::створити_п64(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_д32 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_д32, ПМ::створити_д32(компілятор.пм_модуль, 0.0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_д64 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_д64, ПМ::створити_д64(компілятор.пм_модуль, 0.0) } }, місцезнаходження };
      } інакше {
        вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
      }
      змінна результат_рівно_право = обʼєкт_значення_рівно(компілятор, контекст, місцезнаходження, результат_обʼєкт_значення_право.обʼєкт_значення, аргумент2_нуль);
      якщо результат_рівно_право.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат_рівно_право.помилка, ... };
      }
      змінна результат_обʼєкт_значення_рівно_право = отримати_як_значення(
        компілятор,
        контекст,
        місцезнаходження,
        результат_рівно_право.обʼєкт,
        компілятор.тип_логічне
      );
      якщо результат_обʼєкт_значення_рівно_право.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат_обʼєкт_значення_рівно_право.помилка, ... };
      }
      якщо результат_обʼєкт_значення_рівно_право.обʼєкт_значення.тип != компілятор.тип_логічне {
        вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
      }
      ПМ::вказівка_стрибнути_якщо(
        контекст.кк_дії.поточний_крок.пм_крок,
        результат_обʼєкт_значення_рівно_право.обʼєкт_значення.пм_значення,
        крок_невдачі,
        крок_успіху
      );

      контекст.кк_дії.поточний_крок = Крок {
        отримати_назву(компілятор, "або_вихід"),
        контекст.кк_дії.обʼєкт_дії,
        крок_виходу
      };

      вернути РезультатОбʼєкта {
        Обʼєкт {
          ВидОбʼєктаНезавантаженеЗначення,
          ОбʼєктНезавантаженогоЗначення { компілятор.тип_логічне, пм_значення_результату }
        },
        помилка = пусто
      };
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїАБО {
      змінна результат_обʼєкт_значення_ліво = отримати_як_значення(
        компілятор,
        контекст,
        місцезнаходження,
        ліво,
        компілятор.тип_логічне
      );
      якщо результат_обʼєкт_значення_ліво.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат_обʼєкт_значення_ліво.помилка, ... };
      }

      змінна обʼєкт_значення = результат_обʼєкт_значення_ліво.обʼєкт_значення;

      змінна пм_значення_результату = ПМ::вказівка_накопичити(
        контекст.кк_дії.крок_накопичень.пм_крок,
        компілятор.тип_логічне.пм_тип
      );

      змінна крок_інакше = ПМ::створити_крок(контекст.кк_дії.обʼєкт_дії.пм_інструкція, отримати_назву(компілятор, "або_інакше"));
      змінна крок_успіху = ПМ::створити_крок(контекст.кк_дії.обʼєкт_дії.пм_інструкція, отримати_назву(компілятор, "або_успіх"));
      змінна крок_невдачі = ПМ::створити_крок(контекст.кк_дії.обʼєкт_дії.пм_інструкція, отримати_назву(компілятор, "або_невдача"));
      змінна крок_виходу = ПМ::створити_крок(контекст.кк_дії.обʼєкт_дії.пм_інструкція, отримати_назву(компілятор, "або_вихід"));

      ПМ::вказівка_записати(
        крок_успіху,
        компілятор.обʼєкт_значення_так.пм_значення,
        пм_значення_результату
      );
      ПМ::вказівка_стрибнути(
        крок_успіху,
        крок_виходу
      );

      ПМ::вказівка_записати(
        крок_невдачі,
        компілятор.обʼєкт_значення_ні.пм_значення,
        пм_значення_результату
      );
      ПМ::вказівка_стрибнути(
        крок_невдачі,
        крок_виходу
      );

      змінна аргумент1_нуль: Аргумент;
      якщо обʼєкт_значення.тип == компілятор.тип_ц8 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц8, ПМ::створити_ц8(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц16 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц16, ПМ::створити_ц16(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц32 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц32, ПМ::створити_ц32(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_ц64 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц64, ПМ::створити_ц64(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_логічне {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_логічне, ПМ::створити_логічне(компілятор.пм_модуль, ні) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_п8 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п8, ПМ::створити_п8(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_п16 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п16, ПМ::створити_п16(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_п32 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п32, ПМ::створити_п32(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_п64 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п64, ПМ::створити_п64(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_д32 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_д32, ПМ::створити_д32(компілятор.пм_модуль, 0.0) } }, місцезнаходження };
      } інакше якщо обʼєкт_значення.тип == компілятор.тип_д64 {
        аргумент1_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_д64, ПМ::створити_д64(компілятор.пм_модуль, 0.0) } }, місцезнаходження };
      } інакше {
        вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
      }
      змінна результат_не_рівно_ліво = обʼєкт_значення_не_рівно(компілятор, контекст, місцезнаходження, обʼєкт_значення, аргумент1_нуль);
      якщо результат_не_рівно_ліво.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат_не_рівно_ліво.помилка, ... };
      }
      змінна результат_обʼєкт_значення_не_рівно_ліво = отримати_як_значення(
        компілятор,
        контекст,
        місцезнаходження,
        результат_не_рівно_ліво.обʼєкт,
        компілятор.тип_логічне
      );
      якщо результат_обʼєкт_значення_не_рівно_ліво.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат_обʼєкт_значення_не_рівно_ліво.помилка, ... };
      }
      якщо результат_обʼєкт_значення_не_рівно_ліво.обʼєкт_значення.тип != компілятор.тип_логічне {
        вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
      }
      ПМ::вказівка_стрибнути_якщо(
        контекст.кк_дії.поточний_крок.пм_крок,
        результат_обʼєкт_значення_не_рівно_ліво.обʼєкт_значення.пм_значення,
        крок_успіху,
        крок_інакше
      );


      контекст.кк_дії.поточний_крок = Крок {
        отримати_назву(компілятор, "або_інакше"),
        контекст.кк_дії.обʼєкт_дії,
        крок_інакше
      };
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }
      змінна результат_обʼєкт_значення_право = отримати_як_значення(
        компілятор,
        контекст,
        дані_операції.право.місцезнаходження,
        результат_право.обʼєкт,
        пусто
      );
      якщо результат_обʼєкт_значення_право.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат_обʼєкт_значення_право.помилка, ... };
      }
      змінна аргумент2_нуль: Аргумент;
      якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_ц8 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц8, ПМ::створити_ц8(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_ц16 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц16, ПМ::створити_ц16(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_ц32 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц32, ПМ::створити_ц32(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_ц64 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц64, ПМ::створити_ц64(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_логічне {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_логічне, ПМ::створити_логічне(компілятор.пм_модуль, ні) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_п8 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п8, ПМ::створити_п8(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_п16 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п16, ПМ::створити_п16(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_п32 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п32, ПМ::створити_п32(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_п64 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_п64, ПМ::створити_п64(компілятор.пм_модуль, 0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_д32 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_д32, ПМ::створити_д32(компілятор.пм_модуль, 0.0) } }, місцезнаходження };
      } інакше якщо результат_обʼєкт_значення_право.обʼєкт_значення.тип == компілятор.тип_д64 {
        аргумент2_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_д64, ПМ::створити_д64(компілятор.пм_модуль, 0.0) } }, місцезнаходження };
      } інакше {
        вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
      }
      змінна результат_не_рівно_право = обʼєкт_значення_не_рівно(компілятор, контекст, місцезнаходження, результат_обʼєкт_значення_право.обʼєкт_значення, аргумент2_нуль);
      якщо результат_не_рівно_право.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат_не_рівно_право.помилка, ... };
      }
      змінна результат_обʼєкт_значення_не_рівно_право = отримати_як_значення(
        компілятор,
        контекст,
        місцезнаходження,
        результат_не_рівно_право.обʼєкт,
        компілятор.тип_логічне
      );
      якщо результат_обʼєкт_значення_не_рівно_право.помилка != пусто {
        вернути РезультатОбʼєкта { помилка = результат_обʼєкт_значення_не_рівно_право.помилка, ... };
      }
      якщо результат_обʼєкт_значення_не_рівно_право.обʼєкт_значення.тип != компілятор.тип_логічне {
        вернути результат_обʼєкта_помилка(компілятор, контекст.розібраний_текст, місцезнаходження, "Не вдалось скомпілювати");
      }
      ПМ::вказівка_стрибнути_якщо(
        контекст.кк_дії.поточний_крок.пм_крок,
        результат_обʼєкт_значення_не_рівно_право.обʼєкт_значення.пм_значення,
        крок_успіху,
        крок_невдачі
      );

      контекст.кк_дії.поточний_крок = Крок {
        отримати_назву(компілятор, "або_вихід"),
        контекст.кк_дії.обʼєкт_дії,
        крок_виходу
      };

      вернути РезультатОбʼєкта {
        Обʼєкт {
          ВидОбʼєктаНезавантаженеЗначення,
          ОбʼєктНезавантаженогоЗначення { компілятор.тип_логічне, пм_значення_результату }
        },
        помилка = пусто
      };
    } інакше якщо дані_операції.вид == розбирач::ВидОпераціїЯк {
      змінна результат_право = скомпілювати_значення(компілятор, контекст, пусто, дані_операції.право, очікуваний_тип_право);
      якщо результат_право.помилка != пусто {
        вернути РезультатОбʼєкта { ..., помилка = результат_право.помилка };
      }

      вернути обʼєкт_як(компілятор, контекст, місцезнаходження, ліво, Аргумент { результат_право.обʼєкт, дані_операції.право.місцезнаходження });
    }

    вернути РезультатОбʼєкта {
      помилка = створити_помилку(
        компілятор,
        "Операція не підтримується.",
        створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, місцезнаходження)
      ),
      ...
    };
  }
}