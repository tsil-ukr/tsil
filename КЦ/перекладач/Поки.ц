взяти визначення КЦ;

секція КЦ {
  місцева дія скомпілювати_поки(компілятор: адреса<Компілятор>, контекст: Контекст, дані_поки: розбирач::ДаніСполукиПоки, місцезнаходження: розбирач::Місцезнаходження): Результат {
    змінна пм_крок_умови = ПМ::створити_крок(контекст.кк_дії.обʼєкт_дії.пм_інструкція, отримати_назву(компілятор, "умова_поки"));

    ПМ::вказівка_стрибнути(контекст.кк_дії.поточний_крок.пм_крок, пм_крок_умови);

    контекст.кк_дії.поточний_крок = Крок {
      отримати_назву(компілятор, "умова_поки"),
      контекст.кк_дії.обʼєкт_дії,
      пм_крок_умови
    };

    змінна результат_компіляції_умови = скомпілювати_значення_як_значення(
      компілятор,
      контекст,
      дані_поки.умова,
      компілятор.тип_логічне
    );

    якщо результат_компіляції_умови.помилка != пусто {
      вернути Результат { помилка = результат_компіляції_умови.помилка };
    }

    змінна обʼєкт_значення_умови = результат_компіляції_умови.обʼєкт_значення;

    змінна аргумент_нуль: Аргумент;

    якщо обʼєкт_значення_умови.тип == компілятор.тип_логічне {
      аргумент_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_логічне, ПМ::створити_логічне(компілятор.пм_модуль, ні) } }, місцезнаходження };
    } інакше якщо обʼєкт_значення_умови.тип == компілятор.тип_ц8 {
      аргумент_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц8, ПМ::створити_ц8(компілятор.пм_модуль, 0) } }, місцезнаходження };
    } інакше якщо обʼєкт_значення_умови.тип == компілятор.тип_ц16 {
      аргумент_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц16, ПМ::створити_ц16(компілятор.пм_модуль, 0) } }, місцезнаходження };
    } інакше якщо обʼєкт_значення_умови.тип == компілятор.тип_ц32 {
      аргумент_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц32, ПМ::створити_ц32(компілятор.пм_модуль, 0) } }, місцезнаходження };
    } інакше якщо обʼєкт_значення_умови.тип == компілятор.тип_ц64 {
      аргумент_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_ц64, ПМ::створити_ц64(компілятор.пм_модуль, 0) } }, місцезнаходження };
    } інакше якщо обʼєкт_значення_умови.тип == компілятор.тип_н8 {
      аргумент_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_н8, ПМ::створити_п8(компілятор.пм_модуль, 0) } }, місцезнаходження };
    } інакше якщо обʼєкт_значення_умови.тип == компілятор.тип_н16 {
      аргумент_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_н16, ПМ::створити_п16(компілятор.пм_модуль, 0) } }, місцезнаходження };
    } інакше якщо обʼєкт_значення_умови.тип == компілятор.тип_н32 {
      аргумент_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_н32, ПМ::створити_п32(компілятор.пм_модуль, 0) } }, місцезнаходження };
    } інакше якщо обʼєкт_значення_умови.тип == компілятор.тип_н64 {
      аргумент_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_н64, ПМ::створити_п64(компілятор.пм_модуль, 0) } }, місцезнаходження };
    } інакше якщо обʼєкт_значення_умови.тип == компілятор.тип_р32 {
      аргумент_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_р32, ПМ::створити_д32(компілятор.пм_модуль, 0.0) } }, місцезнаходження };
    } інакше якщо обʼєкт_значення_умови.тип == компілятор.тип_р64 {
      аргумент_нуль = Аргумент { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { компілятор.тип_р64, ПМ::створити_д64(компілятор.пм_модуль, 0.0) } }, місцезнаходження };
    } інакше {
      вернути Результат {
        помилка = створити_помилку(
          компілятор,
          "Умова має бути логічним.",
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, дані_поки.умова.місцезнаходження)
        )
      };
    }

    змінна результат_рівно = обʼєкт_значення_не_рівно(компілятор, контекст, місцезнаходження, обʼєкт_значення_умови, аргумент_нуль);
    якщо результат_рівно.помилка != пусто {
      вернути Результат { помилка = результат_рівно.помилка };
    }
    змінна результат_обʼєкт_значення_рівно = отримати_як_значення(
      компілятор,
      контекст,
      місцезнаходження,
      результат_рівно.обʼєкт,
      компілятор.тип_логічне
    );
    якщо результат_обʼєкт_значення_рівно.помилка != пусто {
      вернути Результат { помилка = результат_обʼєкт_значення_рівно.помилка };
    }
    якщо результат_обʼєкт_значення_рівно.обʼєкт_значення.тип != компілятор.тип_логічне {
      вернути Результат {
        помилка = створити_помилку(
          компілятор,
          "Умова має бути логічним.",
          створити_місцезнаходження_помилки_з_місцезнаходження_розбирача(компілятор, контекст.розібраний_текст, дані_поки.умова.місцезнаходження)
        )
      };
    }
    обʼєкт_значення_умови = результат_обʼєкт_значення_рівно.обʼєкт_значення;

    змінна пм_крок_тіла_поки = ПМ::створити_крок(контекст.кк_дії.обʼєкт_дії.пм_інструкція, отримати_назву(компілятор, "тіло_поки"));
    змінна пм_крок_виходу_з_тіла_поки = ПМ::створити_крок(контекст.кк_дії.обʼєкт_дії.пм_інструкція, отримати_назву(компілятор, "тіло_поки_вихід"));

    ПМ::вказівка_стрибнути_якщо(пм_крок_умови, обʼєкт_значення_умови.пм_значення, пм_крок_тіла_поки, пм_крок_виходу_з_тіла_поки);

    змінна середовище_поки = створити_середовище(компілятор, контекст.середовище);

    контекст.кк_дії.поточний_крок = Крок {
      отримати_назву(компілятор, "тіло_поки"),
      контекст.кк_дії.обʼєкт_дії,
      пм_крок_тіла_поки
    };

    змінна результат_тіла = скомпілювати_тіло(
      компілятор,
      Контекст {
        розібраний_текст = контекст.розібраний_текст,
        середовище = середовище_поки,
        кк_дії = контекст.кк_дії
      },
      дані_поки.тіло,
      місцезнаходження
    );

    якщо результат_тіла.помилка != пусто {
      вернути Результат { помилка = результат_тіла.помилка };
    }

    якщо ПМ::перевірити_чи_крок_закінчується_стрибком(контекст.кк_дії.поточний_крок.пм_крок) == ні {
      ПМ::вказівка_стрибнути(контекст.кк_дії.поточний_крок.пм_крок, пм_крок_умови);
    }

    контекст.кк_дії.поточний_крок = Крок {
      отримати_назву(компілятор, "тіло_поки_вихід"),
      контекст.кк_дії.обʼєкт_дії,
      пм_крок_виходу_з_тіла_поки
    };

    вернути Результат { помилка = пусто };
  }
}