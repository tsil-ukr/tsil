взяти визначення біб;

зовнішня дія putchar(значення: ц8): ц32;
зовнішня дія позитивне_в_ю8(значення: позитивне, вихід_значення: адреса<памʼять<п8>>, вихід_розмір_значення: адреса<позитивне>);

дія позитивне_в_ю8_2(значення: позитивне): ю8 {
  змінна ціль результат: ю8;
  позитивне_в_ю8(значення, результат.дані::адреса, результат.розмір::адреса);
  вернути результат;
}

секція різне {
  секція числа {
    синонім ТипЧислаЦ8 = 1;
    синонім ТипЧислаЦ16 = 2;
    синонім ТипЧислаЦ32 = 3;
    синонім ТипЧислаЦ64 = 4;
    синонім ТипЧислаП8 = 5;
    синонім ТипЧислаП16 = 6;
    синонім ТипЧислаП32 = 7;
    синонім ТипЧислаП64 = 8;
    синонім ТипЧислаД32 = 9;
    синонім ТипЧислаД64 = 10;

    структура РезультатРозборуЧисла {
      успіх: позитивне;
      значення: ц8 | ц16 | ц32 | ц64 | п8 | п16 | п32 | п64 | д32 | д64;
      помилка: ю8;
    }

    структура РезультатРозборуЦілогоЧисла<Т> {
      успіх: позитивне;
      значення: Т;
      помилка: ю8;
    }

    структура РезультатРозборуПозитивногоЧисла<Т> {
      успіх: позитивне;
      значення: Т;
      помилка: ю8;
    }

    структура РезультатРозборуДійсногоЧисла<Т> {
      успіх: позитивне;
      значення: Т;
      помилка: ю8;
    }

    дія розібрати_ціле_з_ю8сі<Т>(значення: ю8): РезультатРозборуЦілогоЧисла<Т> {
      змінна ціль число: Т = 0;
      змінна ціль відʼємне: логічне = ні;
      змінна ціль пх: позитивне = 0;
      змінна ціль символ_: п8 = значення.дані[0];
      якщо символ_ == 45 { // -
        пх = 1;
        символ_ = значення.дані[1];
        відʼємне = так;
      }
      поки пх < значення.розмір {
        якщо символ_ == 48 { // 0
          число = число * 10;
        } інакше якщо символ_ == 49 { // 1
          число = число * 10 + 1;
        } інакше якщо символ_ == 50 { // 2
          число = число * 10 + 2;
        } інакше якщо символ_ == 51 { // 3
          число = число * 10 + 3;
        } інакше якщо символ_ == 52 { // 4
          число = число * 10 + 4;
        } інакше якщо символ_ == 53 { // 5
          число = число * 10 + 5;
        } інакше якщо символ_ == 54 { // 6
          число = число * 10 + 6;
        } інакше якщо символ_ == 55 { // 7
          число = число * 10 + 7;
        } інакше якщо символ_ == 56 { // 8
          число = число * 10 + 8;
        } інакше якщо символ_ == 57 { // 9
          число = число * 10 + 9;
        } інакше якщо символ_ == 95 { // _
          // ігноруємо
        } інакше {
//          біб::друк_ю8(значення.значення);
          вернути РезультатРозборуЦілогоЧисла<Т> { позитивне(ні), помилка = ю8"Не вдалось розібрати ціле", ... };
        }
        пх = пх + 1;
        символ_ = значення.дані[пх];
      }
      якщо відʼємне == так {
        ціль нуль: Т = 0;
        число = нуль - число;
      }
      вернути РезультатРозборуЦілогоЧисла<Т> { позитивне(так), значення = число, ... };
    }

    дія розібрати_позитивне_з_ю8сі<Т>(значення: ю8): РезультатРозборуПозитивногоЧисла<Т> {
      змінна ціль число: Т = 0;
      змінна ціль пх: позитивне = 0;
      змінна ціль символ_: п8 = значення.дані[0];
      поки пх < значення.розмір {
        якщо символ_ == 48 { // 0
          число = число * 10;
        } інакше якщо символ_ == 49 { // 1
          число = число * 10 + 1;
        } інакше якщо символ_ == 50 { // 2
          число = число * 10 + 2;
        } інакше якщо символ_ == 51 { // 3
          число = число * 10 + 3;
        } інакше якщо символ_ == 52 { // 4
          число = число * 10 + 4;
        } інакше якщо символ_ == 53 { // 5
          число = число * 10 + 5;
        } інакше якщо символ_ == 54 { // 6
          число = число * 10 + 6;
        } інакше якщо символ_ == 55 { // 7
          число = число * 10 + 7;
        } інакше якщо символ_ == 56 { // 8
          число = число * 10 + 8;
        } інакше якщо символ_ == 57 { // 9
          число = число * 10 + 9;
        } інакше якщо символ_ == 95 { // _
          // ігноруємо
        } інакше {
//          біб::друк_ю8(значення);
          вернути РезультатРозборуПозитивногоЧисла<Т> { позитивне(ні), помилка = ю8"Не вдалось розібрати позитивне", ... };
        }
        пх = пх + 1;
        символ_ = значення.дані[пх];
      }
      вернути РезультатРозборуПозитивногоЧисла<Т> { позитивне(так), значення = число, ... };
    }

    дія розібрати_десяткове_з_ю8сі<Т>(значення: ю8): РезультатРозборуДійсногоЧисла<Т> {
      змінна ціль число: Т = 0;
      змінна ціль пх: позитивне = 0;
      змінна ціль символ_: п8 = значення.дані[0];
      поки пх < значення.розмір {
        якщо символ_ == 48 { // 0
          число = число * 10;
        } інакше якщо символ_ == 49 { // 1
          число = число * 10 + 1;
        } інакше якщо символ_ == 50 { // 2
          число = число * 10 + 2;
        } інакше якщо символ_ == 51 { // 3
          число = число * 10 + 3;
        } інакше якщо символ_ == 52 { // 4
          число = число * 10 + 4;
        } інакше якщо символ_ == 53 { // 5
          число = число * 10 + 5;
        } інакше якщо символ_ == 54 { // 6
          число = число * 10 + 6;
        } інакше якщо символ_ == 55 { // 7
          число = число * 10 + 7;
        } інакше якщо символ_ == 56 { // 8
          число = число * 10 + 8;
        } інакше якщо символ_ == 57 { // 9
          число = число * 10 + 9;
        } інакше якщо символ_ == 95 { // _
          // ігноруємо
        } інакше якщо символ_ == 46 { // .
          пх = пх + 1;
          символ_ = значення.дані[пх];
          змінна ціль дробна_частина: Т = 0;
          змінна ціль дільник: Т = 1;
          поки пх < значення.розмір {
            якщо символ_ == 48 { // 0
              дробна_частина = дробна_частина * 10;
            } інакше якщо символ_ == 49 { // 1
              дробна_частина = дробна_частина * 10 + 1;
            } інакше якщо символ_ == 50 { // 2
              дробна_частина = дробна_частина * 10 + 2;
            } інакше якщо символ_ == 51 { // 3
              дробна_частина = дробна_частина * 10 + 3;
            } інакше якщо символ_ == 52 { // 4
              дробна_частина = дробна_частина * 10 + 4;
            } інакше якщо символ_ == 53 { // 5
              дробна_частина = дробна_частина * 10 + 5;
            } інакше якщо символ_ == 54 { // 6
              дробна_частина = дробна_частина * 10 + 6;
            } інакше якщо символ_ == 55 { // 7
              дробна_частина = дробна_частина * 10 + 7;
            } інакше якщо символ_ == 56 { // 8
              дробна_частина = дробна_частина * 10 + 8;
            } інакше якщо символ_ == 57 { // 9
              дробна_частина = дробна_частина * 10 + 9;
            } інакше якщо символ_ == 95 { // _
              // ігноруємо
            } інакше {
//              біб::друк_ю8(значення);
              вернути РезультатРозборуДійсногоЧисла<Т> { позитивне(ні), помилка = ю8"Не вдалось розібрати десяткове 1", ... };
            }
            пх = пх + 1;
            символ_ = значення.дані[пх];
            дільник = дільник * 10;
          }
          число = число + дробна_частина / дільник;
          вернути РезультатРозборуДійсногоЧисла<Т> { позитивне(так), значення = число, ... };
        } інакше {
//          біб::друк_ю8(значення);
          putchar(ц8(символ_));
          біб::вивести_ю8(ю8сі"\n");
          вернути РезультатРозборуДійсногоЧисла<Т> { позитивне(ні), помилка = ю8"Не вдалось розібрати десяткове 2", ... };
        }
        пх = пх + 1;
        символ_ = значення.дані[пх];
      }
      вернути РезультатРозборуДійсногоЧисла<Т> { позитивне(так), значення = число, ... };
    }

    дія розібрати_число_з_ю8сі(значення: ю8, очікуваний_тип: позитивне): РезультатРозборуЧисла {
      якщо очікуваний_тип == ТипЧислаЦ8 {
        ціль результат = розібрати_ціле_з_ю8сі<ц64>(значення);
        вернути РезультатРозборуЧисла { результат.успіх, значення = ц8(результат.значення), помилка = результат.помилка };
      } інакше якщо очікуваний_тип == ТипЧислаЦ16 {
        ціль результат = розібрати_ціле_з_ю8сі<ц64>(значення);
        вернути РезультатРозборуЧисла { результат.успіх, значення = ц16(результат.значення), помилка = результат.помилка };
      } інакше якщо очікуваний_тип == ТипЧислаЦ32 {
        ціль результат = розібрати_ціле_з_ю8сі<ц64>(значення);
        вернути РезультатРозборуЧисла { результат.успіх, значення = ц32(результат.значення), помилка = результат.помилка };
      } інакше якщо очікуваний_тип == ТипЧислаЦ64 {
        ціль результат = розібрати_ціле_з_ю8сі<ц64>(значення);
        вернути РезультатРозборуЧисла { результат.успіх, значення = результат.значення, помилка = результат.помилка };
      } інакше якщо очікуваний_тип == ТипЧислаП8 {
        ціль результат = розібрати_позитивне_з_ю8сі<п64>(значення);
        вернути РезультатРозборуЧисла { результат.успіх, значення = п8(результат.значення), помилка = результат.помилка };
      } інакше якщо очікуваний_тип == ТипЧислаП16 {
        ціль результат = розібрати_позитивне_з_ю8сі<п64>(значення);
        вернути РезультатРозборуЧисла { результат.успіх, значення = п16(результат.значення), помилка = результат.помилка };
      } інакше якщо очікуваний_тип == ТипЧислаП32 {
        ціль результат = розібрати_позитивне_з_ю8сі<п64>(значення);
        вернути РезультатРозборуЧисла { результат.успіх, значення = п32(результат.значення), помилка = результат.помилка };
      } інакше якщо очікуваний_тип == ТипЧислаП64 {
        ціль результат = розібрати_позитивне_з_ю8сі<п64>(значення);
        вернути РезультатРозборуЧисла { результат.успіх, значення = результат.значення, помилка = результат.помилка };
      } інакше якщо очікуваний_тип == ТипЧислаД32 {
        ціль результат = розібрати_десяткове_з_ю8сі<д64>(значення);
        вернути РезультатРозборуЧисла { результат.успіх, значення = д32(результат.значення), помилка = результат.помилка };
      } інакше якщо очікуваний_тип == ТипЧислаД64 {
        ціль результат = розібрати_десяткове_з_ю8сі<д64>(значення);
        вернути РезультатРозборуЧисла { результат.успіх, значення = результат.значення, помилка = результат.помилка };
      }
      вернути РезультатРозборуЧисла { позитивне(ні), помилка = ю8"Невідомий тип", ... };
    }

    дія перетворити_позитивне_на_ю8(значення: позитивне): ю8 {
      змінна ціль результат = ю8"";
      позитивне_в_ю8(значення, результат.дані::адреса, результат.розмір::адреса);
      вернути результат;
    }
  }
}