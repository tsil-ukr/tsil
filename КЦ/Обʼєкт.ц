взяти визначення Ц;

секція ц {
  дія обʼєкт_значення_arithmetic_operation(тип: комірка<ОбʼєктТипу>, llvm_diia: (L: комірка<LLVM::TL>, блок: комірка<LLVM::BasicBlock>, ліво: комірка<LLVM::Value>, право: комірка<LLVM::Value>) -> комірка<LLVM::Value>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо аргумент.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення_аргумента = аргумент.дані як ОбʼєктЗначення;
      якщо обʼєкт_значення_аргумента.тип == тип {
        ціль обʼєкт_значення_для_результату = ОбʼєктЗначення {};
        обʼєкт_значення_для_результату.тип = тип;
        обʼєкт_значення_для_результату.llvm_value = llvm_diia(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, обʼєкт_значення_аргумента.llvm_value);
        ціль обʼєкт_для_результату = Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_результату };
        вернути Результат { обʼєкт_для_результату, помилка = пусто };
      }
    } інакше якщо аргумент.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення_для_аргумента = аргумент.дані як ОбʼєктНезавантаженогоЗначення;
      ціль обʼєкт_значення_для_аргумента = ОбʼєктЗначення {};
      обʼєкт_значення_для_аргумента.тип = обʼєкт_незавантаженого_значення_для_аргумента.тип;
      обʼєкт_значення_для_аргумента.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення_для_аргумента.тип.llvm_type, обʼєкт_незавантаженого_значення_для_аргумента.llvm_value);
      ціль обʼєкт_для_аргумента = Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_аргумента };
      вернути обʼєкт_додати(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, К, інформація_середовища, місцезнаходження, обʼєкт_для_аргумента);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось виконати операцію");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_значення_add(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::add, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fadd(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::fadd, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_sub(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::sub, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fsub(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::fsub, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_mul(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::mul, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fmul(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::fmul, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_sdiv(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::sdiv, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_udiv(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::udiv, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fdiv(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::fdiv, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_srem(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::srem, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_urem(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::urem, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_frem(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::frem, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_shl(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::shl, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_lshr(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::lshr, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_ashr(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::ashr, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_and(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::and, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_or(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::or, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_xor(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_arithmetic_operation(тип, LLVM::xor, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }
}

секція ц {
  дія обʼєкт_типу_додати(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось додати");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_додати(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось додати");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_додати(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_додати(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_додати(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_add(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_add(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_add(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_add(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_add(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_add(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_add(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_add(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fadd(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fadd(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось додати");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_додати(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_додати(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_додати(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_додати(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_додати(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось додати");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_відняти(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось відняти");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_відняти(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось відняти");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_відняти(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_відняти(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_відняти(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_sub(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_sub(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_sub(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_sub(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_sub(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_sub(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_sub(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_sub(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fsub(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fsub(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось відняти");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_відняти(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_відняти(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_відняти(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_відняти(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_відняти(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось відняти");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_помножити(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось помножити");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_помножити(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось помножити");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_помножити(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_помножити(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_помножити(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_mul(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_mul(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_mul(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_mul(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_mul(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_mul(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_mul(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_mul(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fmul(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fmul(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось помножити");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_помножити(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_помножити(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_помножити(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_помножити(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_помножити(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось помножити");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_поділити(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось поділити");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_поділити(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось поділити");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_поділити(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_поділити(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_поділити(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_sdiv(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_sdiv(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_sdiv(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_sdiv(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_udiv(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_udiv(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_udiv(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_udiv(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fdiv(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fdiv(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось поділити");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_поділити(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_поділити(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_поділити(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_поділити(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_поділити(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось поділити");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_поділити_за_модулем(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось поділити_за_модулем");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_поділити_за_модулем(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось поділити_за_модулем");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_поділити_за_модулем(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_поділити_за_модулем(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_поділити_за_модулем(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_srem(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_srem(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_srem(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_srem(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_urem(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_urem(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_urem(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_urem(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_frem(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_frem(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось поділити_за_модулем");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_поділити_за_модулем(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_поділити_за_модулем(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_поділити_за_модулем(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_поділити_за_модулем(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_поділити_за_модулем(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось поділити_за_модулем");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_значення_logical_operation(тип: комірка<ОбʼєктТипу>, llvm_diia: (L: комірка<LLVM::TL>, блок: комірка<LLVM::BasicBlock>, ліво: комірка<LLVM::Value>, право: комірка<LLVM::Value>) -> комірка<LLVM::Value>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо аргумент.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення_аргумента = аргумент.дані як ОбʼєктЗначення;
      якщо обʼєкт_значення_аргумента.тип == тип {
        ціль обʼєкт_значення_для_результату = ОбʼєктЗначення {};
        обʼєкт_значення_для_результату.тип = К.тип_логічне;
        обʼєкт_значення_для_результату.llvm_value = llvm_diia(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, обʼєкт_значення_аргумента.llvm_value);
        ціль обʼєкт_для_результату = Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_результату };
        вернути Результат { обʼєкт_для_результату, помилка = пусто };
      }
    } інакше якщо аргумент.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення_для_аргумента = аргумент.дані як ОбʼєктНезавантаженогоЗначення;
      ціль обʼєкт_значення_для_аргумента = ОбʼєктЗначення {};
      обʼєкт_значення_для_аргумента.тип = обʼєкт_незавантаженого_значення_для_аргумента.тип;
      обʼєкт_значення_для_аргумента.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення_для_аргумента.тип.llvm_type, обʼєкт_незавантаженого_значення_для_аргумента.llvm_value);
      ціль обʼєкт_для_аргумента = Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_аргумента };
      вернути обʼєкт_додати(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, К, інформація_середовища, місцезнаходження, обʼєкт_для_аргумента);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось виконати операцію");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_значення_icmp_sgt(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_sgt, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_ugt(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_ugt, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_ogt(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_ogt, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_ugt(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_ugt, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_sge(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_sge, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_uge(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_uge, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_oge(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_oge, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_uge(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_uge, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_slt(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_slt, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_ult(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_ult, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_olt(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_olt, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_ult(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_ult, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_sle(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_sle, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_ule(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_ule, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_ole(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_ole, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_ule(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_ule, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_eq(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_eq, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_icmp_ne(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::icmp_ne, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_oeq(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_oeq, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_one(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_one, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_ueq(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_ueq, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_fcmp_une(тип: комірка<ОбʼєктТипу>, обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    вернути обʼєкт_значення_logical_operation(тип, LLVM::fcmp_une, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
  }
}

секція ц {
  дія обʼєкт_типу_більше(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось більше");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_більше(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось більше");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_більше(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_більше(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_більше(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_icmp_sgt(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_icmp_sgt(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_icmp_sgt(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_icmp_sgt(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_icmp_ugt(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_icmp_ugt(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_icmp_ugt(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_icmp_ugt(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fcmp_ugt(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fcmp_ugt(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось більше");
    вернути Результат { помилка = помилка_компіляції };
  }
  
  місцева дія обʼєкт_більше(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_більше(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_більше(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_більше(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_більше(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось більше");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_менше(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось менше");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_менше(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось менше");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_менше(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_менше(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_менше(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_icmp_slt(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_icmp_slt(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_icmp_slt(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_icmp_slt(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_icmp_ult(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_icmp_ult(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_icmp_ult(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_icmp_ult(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fcmp_ult(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fcmp_ult(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось менше");
    вернути Результат { помилка = помилка_компіляції };
  }
  
  місцева дія обʼєкт_менше(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_менше(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_менше(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_менше(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_менше(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось менше");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_більше_рівно(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось більше_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_більше_рівно(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось більше_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_більше_рівно(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_більше_рівно(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_більше_рівно(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_icmp_sge(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_icmp_sge(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_icmp_sge(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_icmp_sge(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_icmp_uge(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_icmp_uge(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_icmp_uge(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_icmp_uge(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fcmp_uge(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fcmp_uge(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось більше_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }
  
  місцева дія обʼєкт_більше_рівно(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_більше_рівно(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_більше_рівно(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_більше_рівно(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_більше_рівно(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось більше_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_менше_рівно(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось менше_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_менше_рівно(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось менше_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_менше_рівно(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_менше_рівно(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_менше_рівно(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_icmp_sle(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_icmp_sle(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_icmp_sle(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_icmp_sle(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_icmp_ule(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_icmp_ule(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_icmp_ule(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_icmp_ule(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fcmp_ule(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fcmp_ule(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось менше_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }
  
  місцева дія обʼєкт_менше_рівно(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_менше_рівно(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_менше_рівно(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_менше_рівно(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_менше_рівно(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось менше_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_рівно(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось рівно");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_рівно(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось рівно");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_рівно(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_рівно(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_рівно(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_icmp_eq(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_icmp_eq(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_icmp_eq(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_icmp_eq(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_icmp_eq(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_icmp_eq(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_icmp_eq(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_icmp_eq(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fcmp_ueq(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fcmp_ueq(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось рівно");
    вернути Результат { помилка = помилка_компіляції };
  }
  
  місцева дія обʼєкт_рівно(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_рівно(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_рівно(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_рівно(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_рівно(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось рівно");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_не_рівно(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось не_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_не_рівно(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось не_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_не_рівно(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_не_рівно(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_не_рівно(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_icmp_ne(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_icmp_ne(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_icmp_ne(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_icmp_ne(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_icmp_ne(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_icmp_ne(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_icmp_ne(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_icmp_ne(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д32 {
      вернути обʼєкт_значення_fcmp_une(К.тип_д32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_д64 {
      вернути обʼєкт_значення_fcmp_une(К.тип_д64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось не_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }
  
  місцева дія обʼєкт_не_рівно(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_не_рівно(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_не_рівно(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_не_рівно(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_не_рівно(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось не_рівно");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_зсунути_вліво(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вліво");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_зсунути_вліво(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вліво");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_зсунути_вліво(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_зсунути_вліво(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_зсунути_вліво(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_shl(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_shl(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_shl(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_shl(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_shl(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_shl(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_shl(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_shl(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вліво");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_зсунути_вліво(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_зсунути_вліво(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_зсунути_вліво(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_зсунути_вліво(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_зсунути_вліво(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вліво");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_зсунути_вправо(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вправо");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_зсунути_вправо(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вправо");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_зсунути_вправо(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_зсунути_вправо(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_зсунути_вправо(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_lshr(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_lshr(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_lshr(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_lshr(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_lshr(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_lshr(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_lshr(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_lshr(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вправо");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_зсунути_вправо(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_зсунути_вправо(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_зсунути_вправо(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_зсунути_вправо(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_зсунути_вправо(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вправо");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_зсунути_вправо_знаковий(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вправо_знаковий");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_зсунути_вправо_знаковий(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вправо_знаковий");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_зсунути_вправо_знаковий(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_зсунути_вправо_знаковий(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_зсунути_вправо_знаковий(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_ashr(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_ashr(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_ashr(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_ashr(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_ashr(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_ashr(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_ashr(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_ashr(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вправо_знаковий");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_зсунути_вправо_знаковий(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_зсунути_вправо_знаковий(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_зсунути_вправо_знаковий(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_зсунути_вправо_знаковий(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_зсунути_вправо_знаковий(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось зсунути_вправо_знаковий");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_ді(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось ді");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_ді(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось ді");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_ді(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_ді(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_ді(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_and(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_and(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_and(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_and(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_and(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_and(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_and(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_and(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось ді");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_ді(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_ді(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_ді(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_ді(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_ді(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось ді");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_дабо(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось дабо");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_дабо(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось дабо");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_дабо(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_дабо(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_дабо(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_or(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_or(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_or(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_or(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_or(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_or(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_or(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_or(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось дабо");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_дабо(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_дабо(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_дабо(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_дабо(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_дабо(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось дабо");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_вабо(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось вабо");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_вабо(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось вабо");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_вабо(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_вабо(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_вабо(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо обʼєкт_значення.тип == К.тип_ц8 {
      вернути обʼєкт_значення_xor(К.тип_ц8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц16 {
      вернути обʼєкт_значення_xor(К.тип_ц16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц32 {
      вернути обʼєкт_значення_xor(К.тип_ц32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_ц64 {
      вернути обʼєкт_значення_xor(К.тип_ц64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п8 {
      вернути обʼєкт_значення_xor(К.тип_п8, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п16 {
      вернути обʼєкт_значення_xor(К.тип_п16, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п32 {
      вернути обʼєкт_значення_xor(К.тип_п32, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    } інакше якщо обʼєкт_значення.тип == К.тип_п64 {
      вернути обʼєкт_значення_xor(К.тип_п64, обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось вабо");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_вабо(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_вабо(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_вабо(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_вабо(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_вабо(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось вабо");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_як(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_як(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_як(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо аргумент.вид != ВидОбʼєктаТипу {
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
      вернути Результат { помилка = помилка_компіляції };
    }
    ціль новий_тип = аргумент.дані як комірка<ОбʼєктТипу>;
    якщо новий_тип == обʼєкт_незавантаженого_значення.тип {
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_незавантаженого_значення }, помилка = пусто };
    }
    якщо обʼєкт_незавантаженого_значення.тип.вид == ВидТипуВаріація {
      змінна знайдений_тип_варіації: комірка<ОбʼєктТипу> = пусто;
      змінна пх: позитивне = 0;
      поки пх < обʼєкт_незавантаженого_значення.тип.типи_варіації.довжина {
        якщо перевірити_тип(обʼєкт_незавантаженого_значення.тип.типи_варіації.дані[пх], новий_тип) {
          знайдений_тип_варіації = обʼєкт_незавантаженого_значення.тип.типи_варіації.дані[пх];
        }
        пх = пх + 1;
      }
      якщо знайдений_тип_варіації == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
        вернути Результат { помилка = помилка_компіляції };
      }
      обʼєкт_незавантаженого_значення.тип = знайдений_тип_варіації;
      вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженогоЗначення, дані = обʼєкт_незавантаженого_значення }, помилка = пусто };
    }
    // потім: ехх... треба як знизу робити без load
    ціль обʼєкт_значення_для_цілі = ОбʼєктЗначення {};
    обʼєкт_значення_для_цілі.тип = обʼєкт_незавантаженого_значення.тип;
    обʼєкт_значення_для_цілі.llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, обʼєкт_незавантаженого_значення.тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
    вернути обʼєкт_як(Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_для_цілі }, К, інформація_середовища, місцезнаходження, аргумент);
  }

  дія обʼєкт_значення_як(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо аргумент.вид != ВидОбʼєктаТипу {
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
      вернути Результат { помилка = помилка_компіляції };
    }
    ціль новий_тип = аргумент.дані як комірка<ОбʼєктТипу>;
    якщо новий_тип == обʼєкт_значення.тип {
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
    }
    якщо обʼєкт_значення.тип.вид == ВидТипуКомірка {
      якщо новий_тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо новий_тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
      якщо новий_тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо новий_тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо обʼєкт_значення.тип.вид == ВидТипуВаріація {
      змінна знайдений_тип_варіації: комірка<ОбʼєктТипу> = пусто;
      змінна пх: позитивне = 0;
      поки пх < обʼєкт_значення.тип.типи_варіації.довжина {
        якщо перевірити_тип(обʼєкт_значення.тип.типи_варіації.дані[пх], новий_тип) {
          знайдений_тип_варіації = обʼєкт_значення.тип.типи_варіації.дані[пх];
        }
        пх = пх + 1;
      }
      якщо знайдений_тип_варіації == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
        вернути Результат { помилка = помилка_компіляції };
      }
      обʼєкт_значення.тип = знайдений_тип_варіації;
      обʼєкт_значення.llvm_value = LLVM::bitcast(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, знайдений_тип_варіації.llvm_type);
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
    }
    якщо новий_тип == К.тип_логічне {
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_ц8 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_ц16 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_ц32 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_ц64 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptosi(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_п8 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_п16 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_п32 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::trunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_п64 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::zext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptoui(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_д32 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fptrunc(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    якщо новий_тип == К.тип_д64 {
      якщо обʼєкт_значення.тип == К.тип_логічне {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_ц64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::sitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п8 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п16 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_п64 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип == К.тип_д32 {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::fpext(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуКомірка {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
      якщо обʼєкт_значення.тип.вид == ВидТипуПамʼять {
        обʼєкт_значення.тип = новий_тип;
        обʼєкт_значення.llvm_value = LLVM::ptrtoint(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        обʼєкт_значення.llvm_value = LLVM::uitofp(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, новий_тип.llvm_type);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
      }
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_як(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, аргумент: Обʼєкт): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_як(обʼєкт_типу, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_як(обʼєкт_дії, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_як(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_як(обʼєкт_значення, К, інформація_середовища, місцезнаходження, аргумент);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось як");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_типу_отримати_властивість(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    якщо перевірити_чи_тип_повний(К, обʼєкт_типу) == ні {
      ціль помилка_компіляції = виділити_помилку_компіляції_виявлено_неповний_тип(місцезнаходження, Обʼєкт { ВидОбʼєктаТипу, дані = обʼєкт_типу });
      вернути Результат { помилка = помилка_компіляції };
    }
    якщо strcmp(назва, ю8"розмір") == 0 {
      ціль обʼєкт_значення = ОбʼєктЗначення {};
      якщо очікуваний_тип == К.тип_логічне {
        обʼєкт_значення.тип = К.тип_логічне;
        обʼєкт_значення.llvm_value = LLVM::const_uint1(К.L, дізнатись_розмір_типу(К, обʼєкт_типу));
      } інакше якщо очікуваний_тип == К.тип_ц8 {
        обʼєкт_значення.тип = К.тип_ц8;
        обʼєкт_значення.llvm_value = LLVM::const_int8(К.L, дізнатись_розмір_типу(К, обʼєкт_типу));
      } інакше якщо очікуваний_тип == К.тип_ц16 {
        обʼєкт_значення.тип = К.тип_ц16;
        обʼєкт_значення.llvm_value = LLVM::const_int16(К.L, дізнатись_розмір_типу(К, обʼєкт_типу));
      } інакше якщо очікуваний_тип == К.тип_ц32 {
        обʼєкт_значення.тип = К.тип_ц32;
        обʼєкт_значення.llvm_value = LLVM::const_int32(К.L, дізнатись_розмір_типу(К, обʼєкт_типу));
      } інакше якщо очікуваний_тип == К.тип_ц64 {
        обʼєкт_значення.тип = К.тип_ц64;
        обʼєкт_значення.llvm_value = LLVM::const_int64(К.L, дізнатись_розмір_типу(К, обʼєкт_типу));
      } інакше якщо очікуваний_тип == К.тип_п8 {
        обʼєкт_значення.тип = К.тип_п8;
        обʼєкт_значення.llvm_value = LLVM::const_uint8(К.L, дізнатись_розмір_типу(К, обʼєкт_типу));
      } інакше якщо очікуваний_тип == К.тип_п16 {
        обʼєкт_значення.тип = К.тип_п16;
        обʼєкт_значення.llvm_value = LLVM::const_uint16(К.L, дізнатись_розмір_типу(К, обʼєкт_типу));
      } інакше якщо очікуваний_тип == К.тип_п32 {
        обʼєкт_значення.тип = К.тип_п32;
        обʼєкт_значення.llvm_value = LLVM::const_uint32(К.L, дізнатись_розмір_типу(К, обʼєкт_типу));
      } інакше якщо очікуваний_тип == К.тип_п64 {
        обʼєкт_значення.тип = К.тип_п64;
        обʼєкт_значення.llvm_value = LLVM::const_uint64(К.L, дізнатись_розмір_типу(К, обʼєкт_типу));
      } інакше {
        обʼєкт_значення.тип = К.тип_позитивне;
        обʼєкт_значення.llvm_value = LLVM::const_uint64(К.L, дізнатись_розмір_типу(К, обʼєкт_типу));
      }
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_отримати_властивість(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_отримати_властивість(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    змінна тип: комірка<ОбʼєктТипу>;
    змінна llvm_value: комірка<LLVM::Value>;
    тип = обʼєкт_незавантаженого_значення.тип;
    llvm_value = обʼєкт_незавантаженого_значення.llvm_value;
    якщо тип.вид == ВидТипуКомірка {
      llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, тип.llvm_type, llvm_value);
      тип = тип.тип_комірки;
    }
    якщо тип.вид != ВидТипуСтруктура {
      ціль помилка_компіляції = виділити_помилку_компіляції_неможливо_отримати_властивість(місцезнаходження, назва, Обʼєкт { ВидОбʼєктаНезавантаженогоЗначення, дані = обʼєкт_незавантаженого_значення });
      вернути Результат { помилка = помилка_компіляції };
    }
    змінна позиція_знайденої_властивості: позитивне = 0;
    змінна властивість_структури: ВластивістьСтруктури;
    змінна властивість_структури_знайдено: логічне = ні;
    змінна пх: позитивне = 0;
    поки пх < тип.властивості_структури.довжина {
      якщо strcmp(тип.властивості_структури.дані[пх].назва, назва) == 0 {
        позиція_знайденої_властивості = пх;
        властивість_структури = тип.властивості_структури.дані[пх];
        властивість_структури_знайдено = так;
      }
      пх = пх + 1;
    }
    якщо властивість_структури_знайдено == ні {
      ціль помилка_компіляції = виділити_помилку_компіляції_властивість_не_знайдено(місцезнаходження, назва, Обʼєкт { ВидОбʼєктаНезавантаженогоЗначення, дані = обʼєкт_незавантаженого_значення });
      вернути Результат { помилка = помилка_компіляції };
    }
    ціль gep_positions_llvm_values = виділити<комірка<LLVM::Value>>(2);
    gep_positions_llvm_values[0] = LLVM::const_int32(К.L, 0);
    gep_positions_llvm_values[1] = LLVM::const_int32(К.L, позиція_знайденої_властивості);
    ціль llvm_value_gep = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, тип.llvm_type, llvm_value, 2, gep_positions_llvm_values);
    ціль обʼєкт_значення = ОбʼєктНезавантаженогоЗначення {};
    обʼєкт_значення.тип = властивість_структури.тип;
    обʼєкт_значення.llvm_value = llvm_value_gep;
    вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженогоЗначення, дані = обʼєкт_значення }, помилка = пусто };
  }

  дія обʼєкт_значення_отримати_властивість(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_отримати_властивість(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_отримати_властивість(обʼєкт_типу, К, інформація_середовища, місцезнаходження, назва, очікуваний_тип);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_отримати_властивість(обʼєкт_дії, К, інформація_середовища, місцезнаходження, назва, очікуваний_тип);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_отримати_властивість(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, назва, очікуваний_тип);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_отримати_властивість(обʼєкт_значення, К, інформація_середовища, місцезнаходження, назва, очікуваний_тип);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_секції_отримати_властивість_секції(обʼєкт_секції: комірка<ОбʼєктСекції>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль обʼєкт: Обʼєкт;
    ціль успіх_отримання_зі_середовища = отримати_з_локального_середовища(обʼєкт_секції.середовище, назва, комірка(обʼєкт));
    якщо успіх_отримання_зі_середовища == так {
      вернути Результат { обʼєкт, помилка = пусто };
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість_секції");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_типу_отримати_властивість_секції(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість_секції");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_отримати_властивість_секції(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість_секції");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_отримати_властивість_секції(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість_секції");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_значення_отримати_властивість_секції(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість_секції");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_отримати_властивість_секції(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, назва: памʼять<п8>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_отримати_властивість_секції(обʼєкт_типу, К, інформація_середовища, місцезнаходження, назва, очікуваний_тип);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_отримати_властивість_секції(обʼєкт_дії, К, інформація_середовища, місцезнаходження, назва, очікуваний_тип);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_отримати_властивість_секції(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, назва, очікуваний_тип);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_отримати_властивість_секції(обʼєкт_значення, К, інформація_середовища, місцезнаходження, назва, очікуваний_тип);
    }
    якщо я.вид == ВидОбʼєктаСекції {
      ціль обʼєкт_секції = я.дані як комірка<ОбʼєктСекції>;
      вернути обʼєкт_секції_отримати_властивість_секції(обʼєкт_секції, К, інформація_середовища, місцезнаходження, назва, очікуваний_тип);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_властивість_секції");
    вернути Результат { помилка = помилка_компіляції };
  }
}

секція ц {
  дія обʼєкт_секції_отримати_за_позицією(обʼєкт_секції: комірка<ОбʼєктСекції>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, позиція: Обʼєкт, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_за_позицією");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_типу_отримати_за_позицією(обʼєкт_типу: комірка<ОбʼєктТипу>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, позиція: Обʼєкт, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_за_позицією");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_дії_отримати_за_позицією(обʼєкт_дії: комірка<ОбʼєктДії>, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, позиція: Обʼєкт, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_за_позицією");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_незавантаженого_значення_отримати_за_позицією(обʼєкт_незавантаженого_значення: ОбʼєктНезавантаженогоЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, позиція: Обʼєкт, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_за_позицією");
    вернути Результат { помилка = помилка_компіляції };
  }

  дія обʼєкт_значення_отримати_за_позицією(обʼєкт_значення: ОбʼєктЗначення, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, позиція: Обʼєкт, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_за_позицією");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія обʼєкт_отримати_за_позицією(я: Обʼєкт, К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, позиція: Обʼєкт, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    якщо я.вид == ВидОбʼєктаТипу {
      ціль обʼєкт_типу = я.дані як комірка<ОбʼєктТипу>;
      вернути обʼєкт_типу_отримати_за_позицією(обʼєкт_типу, К, інформація_середовища, місцезнаходження, позиція, очікуваний_тип);
    }
    якщо я.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = я.дані як комірка<ОбʼєктДії>;
      вернути обʼєкт_дії_отримати_за_позицією(обʼєкт_дії, К, інформація_середовища, місцезнаходження, позиція, очікуваний_тип);
    }
    якщо я.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = я.дані як ОбʼєктНезавантаженогоЗначення;
      вернути обʼєкт_незавантаженого_значення_отримати_за_позицією(обʼєкт_незавантаженого_значення, К, інформація_середовища, місцезнаходження, позиція, очікуваний_тип);
    }
    якщо я.вид == ВидОбʼєктаЗначення {
      ціль обʼєкт_значення = я.дані як ОбʼєктЗначення;
      вернути обʼєкт_значення_отримати_за_позицією(обʼєкт_значення, К, інформація_середовища, місцезнаходження, позиція, очікуваний_тип);
    }
    якщо я.вид == ВидОбʼєктаСекції {
      ціль обʼєкт_секції = я.дані як комірка<ОбʼєктСекції>;
      вернути обʼєкт_секції_отримати_за_позицією(обʼєкт_секції, К, інформація_середовища, місцезнаходження, позиція, очікуваний_тип);
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось отримати_за_позицією");
    вернути Результат { помилка = помилка_компіляції };
  }
}
