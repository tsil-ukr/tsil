взяти визначення К;

секція цк {
  місцева дія скомпілювати_визначити_ціль(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніЦіль>): комірка<ПомилкаКомпіляції> {
    ціль назва = дані.ідентифікатор.значення;

    ціль результат_отримання_з_середовища = отримати_з_локального_середовища(середовище, назва);
    якщо результат_отримання_з_середовища.знайдено == так {
      ціль помилка_компіляції = створити_помилку_компіляції_субʼєкт_вже_визначено(місцезнаходження, назва);
      вернути помилка_компіляції;
    } інакше {
      ціль ціль_ = виділити<Ціль>();

      якщо дані.тип == пусто {
        якщо дані.значення == пусто {
          ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Не вказано тип цілі");
          вернути помилка_компіляції;
        } інакше {
          ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.значення, так);
          якщо результат_компіляції_значення.помилка != пусто {
            вернути результат_компіляції_значення.помилка;
          }
          ціль тип = результат_компіляції_значення.в.тип;
          якщо тип.вид == ВидТипуНативний {
            якщо перевірити_тип(К, тип, К.тип_ніщо) == так {
              ціль помилка_компіляції = створити_помилку_компіляції(дані.значення.місцезнаходження, ю8"Тип не визначено");
              вернути помилка_компіляції;
            }
          }
          ціль_.тип = тип;
          ціль_.llvm_alloca_value = LLVM::alloca(К.Л, блок.llvm_alloca_block, назва, отримати_llvm_type(К, тип));

          LLVM::store(К.Л, блок.llvm_block, результат_компіляції_значення.в.llvm_value, ціль_.llvm_alloca_value);
        }
      } інакше {
        ціль результат_компіляції_як_типу = скомпілювати_значення_як_тип(К, блок, середовище, дані.тип);
        якщо результат_компіляції_як_типу.помилка != пусто {
          вернути результат_компіляції_як_типу.помилка;
        }
        ціль тип = результат_компіляції_як_типу.тип;
        ціль_.тип = тип;
        ціль_.llvm_alloca_value = LLVM::alloca(К.Л, блок.llvm_alloca_block, назва, отримати_llvm_type(К, тип));

        якщо дані.значення != пусто {
          змінна ов: ОбʼєктВиконання;
          якщо дані.значення.вид == АСДВидЗначенняЧисло {
            ціль дані_значення_числа = дані.значення.дані як комірка<АСДДаніЗначенняЧисло>;
            змінна очікуваний_тип_числа: позитивне = ОчікуванийТипЧислаАВТО;
            якщо перевірити_тип(К, тип, К.тип_ц8) == так {
              очікуваний_тип_числа = ОчікуванийТипЧислаЦ8;
            } інакше якщо перевірити_тип(К, тип, К.тип_ц16) == так {
              очікуваний_тип_числа = ОчікуванийТипЧислаЦ16;
            } інакше якщо перевірити_тип(К, тип, К.тип_ц32) == так {
              очікуваний_тип_числа = ОчікуванийТипЧислаЦ32;
            } інакше якщо перевірити_тип(К, тип, К.тип_ц64) == так {
              очікуваний_тип_числа = ОчікуванийТипЧислаЦ64;
            } інакше якщо перевірити_тип(К, тип, К.тип_п8) == так {
              очікуваний_тип_числа = ОчікуванийТипЧислаП8;
            } інакше якщо перевірити_тип(К, тип, К.тип_п16) == так {
              очікуваний_тип_числа = ОчікуванийТипЧислаП16;
            } інакше якщо перевірити_тип(К, тип, К.тип_п32) == так {
              очікуваний_тип_числа = ОчікуванийТипЧислаП32;
            } інакше якщо перевірити_тип(К, тип, К.тип_п64) == так {
              очікуваний_тип_числа = ОчікуванийТипЧислаП64;
            } інакше якщо перевірити_тип(К, тип, К.тип_д32) == так {
              очікуваний_тип_числа = ОчікуванийТипЧислаД32;
            } інакше якщо перевірити_тип(К, тип, К.тип_д64) == так {
              очікуваний_тип_числа = ОчікуванийТипЧислаД64;
            } інакше {
              ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Невідповідні типи");
              вернути помилка_компіляції;
            }
            ціль результат_компіляції_числа = скомпілювати_значення_число(К, блок, пусто, середовище, дані.значення.місцезнаходження, дані_значення_числа, очікуваний_тип_числа);
            якщо результат_компіляції_числа.помилка != пусто {
              вернути результат_компіляції_числа.помилка;
            }
            ов = результат_компіляції_числа.значення.в;
          } інакше {
            ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.значення, так);
            якщо результат_компіляції_значення.помилка != пусто {
              вернути результат_компіляції_значення.помилка;
            }
            ов = результат_компіляції_значення.в;
          }
          якщо перевірити_тип(К, ов.тип, тип) == ні {
            ціль помилка_компіляції = створити_помилку_компіляції(дані.значення.місцезнаходження, ю8"Невідповідні типи");
            вернути помилка_компіляції;
          }
          LLVM::store(К.Л, блок.llvm_block, ов.llvm_value, ціль_.llvm_alloca_value);
        }
      }

      ціль обʼєкт_компіляції = ОбʼєктКомпіляції { ВидОКЦіль, ціль_ };

      змінити_в_середовищі(середовище, назва, обʼєкт_компіляції);

      вернути пусто;
    }
  }
}

секція ц {
  місцева дія скомпілювати_визначити_ціль(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніЦіль>): комірка<ПомилкаКомпіляції> {
    ціль назва = дані.ідентифікатор.значення;
    ціль результат_компіляції_значення_типу = скомпілювати_значення_як_тип(К, пусто, пусто, середовище, дані.тип);
    якщо результат_компіляції_значення_типу.помилка != пусто {
      вернути результат_компіляції_значення_типу.помилка;
    }
    ціль обʼєкт_типу_цілі = результат_компіляції_значення_типу.обʼєкт_типу;
    ціль обʼєкт_цілі = виділити<ОбʼєктЦілі>();
    обʼєкт_цілі.тип = обʼєкт_типу_цілі;
    обʼєкт_цілі.llvm_value = LLVM::alloca(К.L, блок.llvm_alloca_block, назва, обʼєкт_типу_цілі.llvm_type);
    обʼєкт_цілі.додати = пусто;
    якщо дані.значення != пусто {
      ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, пусто, середовище, дані.значення);
      якщо результат_компіляції_значення.помилка != пусто {
        вернути результат_компіляції_значення.помилка;
      }
      ціль обʼєкт_значення = результат_компіляції_значення.обʼєкт_значення;
      якщо перевірити_тип(К, обʼєкт_значення.тип, обʼєкт_типу_цілі) == ні {
        ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Тип значення не відповідає типу цілі");
        вернути помилка_компіляції;
      }
      LLVM::store(К.L, блок.llvm_block, обʼєкт_значення.llvm_value, обʼєкт_цілі.llvm_value);
    }
    ціль обʼєкт = Обʼєкт { ВидОбʼєктаЦілі, дані = обʼєкт_цілі };
    змінити_в_середовищі(середовище, назва, обʼєкт);
    вернути пусто;
  }
}