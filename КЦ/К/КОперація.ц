взяти визначення К;

секція ц {
  дія перевірити_чи_тип_підтримує_add(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_тип(К, тип, К.тип_ц8) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_ц16) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_ц32) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_ц64) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_п8) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_п16) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_п32) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_п64) {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_fadd(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_тип(К, тип, К.тип_д32) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_д64) {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_sub(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_тип(К, тип, К.тип_ц8) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_ц16) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_ц32) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_ц64) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_п8) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_п16) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_п32) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_п64) {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_fsub(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_тип(К, тип, К.тип_д32) {
      вернути так;
    }
    якщо перевірити_тип(К, тип, К.тип_д64) {
      вернути так;
    }
    вернути ні;
  }

  місцева дія скомпілювати_операцію(К: комірка<Компілятор>, л_блок: комірка<ЛБлок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніОперація>): РезультатКомпіляціїОперації {
    ціль результат_компіляції_ліво_як_значення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.ліво, так);
    якщо результат_компіляції_ліво_як_значення.помилка != пусто {
      вернути РезультатКомпіляціїОперації { Тип {}, пусто, результат_компіляції_ліво_як_значення.помилка };
    }
    ціль результат_компіляції_право_як_значення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.право, так);
    якщо результат_компіляції_право_як_значення.помилка != пусто {
      вернути РезультатКомпіляціїОперації { Тип {}, пусто, результат_компіляції_право_як_значення.помилка };
    }
    ціль тип_ліво = результат_компіляції_ліво_як_значення.тип;
    ціль тип_право = результат_компіляції_право_як_значення.тип;

    якщо дані.операція == АСДОпераціяДодавання {
      якщо перевірити_тип(К, тип_право, тип_ліво) == ні {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Типи операндів не сумісні");
        вернути РезультатКомпіляціїОперації { Тип {}, пусто, помилка_компіляції };
      }
      якщо перевірити_чи_тип_підтримує_add(К, тип_ліво) == так {
        ціль л_значення = LLVM::add(К.Л, л_блок, результат_компіляції_ліво_як_значення.л_значення, результат_компіляції_право_як_значення.л_значення);
        вернути РезультатКомпіляціїОперації { К.тип_ц32, л_значення, пусто };
      }
      якщо перевірити_чи_тип_підтримує_fadd(К, тип_ліво) == так {
        ціль л_значення = LLVM::fadd(К.Л, л_блок, результат_компіляції_ліво_як_значення.л_значення, результат_компіляції_право_як_значення.л_значення);
        вернути РезультатКомпіляціїОперації { К.тип_ц32, л_значення, пусто };
      }
    } інакше якщо дані.операція == АСДОпераціяВіднімання {
      якщо перевірити_тип(К, тип_право, тип_ліво) == ні {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Типи операндів не сумісні");
        вернути РезультатКомпіляціїОперації { Тип {}, пусто, помилка_компіляції };
      }
      якщо перевірити_чи_тип_підтримує_sub(К, тип_ліво) == так {
        ціль л_значення = LLVM::sub(К.Л, л_блок, результат_компіляції_ліво_як_значення.л_значення, результат_компіляції_право_як_значення.л_значення);
        вернути РезультатКомпіляціїОперації { К.тип_ц32, л_значення, пусто };
      }
      якщо перевірити_чи_тип_підтримує_fsub(К, тип_ліво) == так {
        ціль л_значення = LLVM::fsub(К.Л, л_блок, результат_компіляції_ліво_як_значення.л_значення, результат_компіляції_право_як_значення.л_значення);
        вернути РезультатКомпіляціїОперації { К.тип_ц32, л_значення, пусто };
      }
    }

    ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Операція не підтримується");
    вернути РезультатКомпіляціїОперації { Тип {}, пусто, помилка_компіляції };
  }
}