взяти визначення К;

секція цк {
  дія перевірити_чи_типи_рівні(К: комірка<Компілятор>, тип1: Тип, тип2: Тип): логічне {
    якщо тип1.вид != тип2.вид {
      вернути ні;
    }
    ціль дані = тип1.дані як комірка<ДаніТипуНативний>;
    ціль дані2 = тип2.дані як комірка<ДаніТипуНативний>;
    якщо дані == дані2 {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_add(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц64) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_fadd(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_sub(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц64) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_fsub(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_mul(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц64) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_fmul(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_udiv(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_sdiv(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_fdiv(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_urem(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_srem(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_frem(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д64) == так {
      вернути так;
    }
    вернути ні;
  }

  місцева дія скомпілювати_значення_операція(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніОперація>): РезультатЗначення {
    ціль результат_компіляції_значення_ліво = скомпілювати_значення_як_значення(К, блок, середовище, дані.ліво, так);
    якщо результат_компіляції_значення_ліво.помилка != пусто {
      вернути РезультатЗначення { помилка = результат_компіляції_значення_ліво.помилка };
    }
    ціль результат_компіляції_значення_право = скомпілювати_значення_як_значення(К, блок, середовище, дані.право, так);
    якщо результат_компіляції_значення_право.помилка != пусто {
      вернути РезультатЗначення { помилка = результат_компіляції_значення_право.помилка };
    }
    ціль тип_ліво = результат_компіляції_значення_ліво.в.тип;
    ціль тип_право = результат_компіляції_значення_право.в.тип;
    ціль ліво_llvm_value = результат_компіляції_значення_ліво.в.llvm_value;
    ціль право_llvm_value = результат_компіляції_значення_право.в.llvm_value;

    якщо дані.операція == АСДОпераціяДодавання {
      якщо перевірити_чи_тип_підтримує_add(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль llvm_value = LLVM::add(К.Л, блок.llvm_block, ліво_llvm_value, право_llvm_value);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, llvm_value, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      } інакше якщо перевірити_чи_тип_підтримує_fadd(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль llvm_value = LLVM::fadd(К.Л, блок.llvm_block, ліво_llvm_value, право_llvm_value);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, llvm_value, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      }
    } інакше якщо дані.операція == АСДОпераціяВіднімання {
      якщо перевірити_чи_тип_підтримує_sub(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль llvm_value = LLVM::sub(К.Л, блок.llvm_block, ліво_llvm_value, право_llvm_value);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, llvm_value, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      } інакше якщо перевірити_чи_тип_підтримує_fsub(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль llvm_value = LLVM::fsub(К.Л, блок.llvm_block, ліво_llvm_value, право_llvm_value);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, llvm_value, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      }
    } інакше якщо дані.операція == АСДОпераціяМноження {
      якщо перевірити_чи_тип_підтримує_mul(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль llvm_value = LLVM::mul(К.Л, блок.llvm_block, ліво_llvm_value, право_llvm_value);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, llvm_value, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      } інакше якщо перевірити_чи_тип_підтримує_fmul(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль llvm_value = LLVM::fmul(К.Л, блок.llvm_block, ліво_llvm_value, право_llvm_value);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, llvm_value, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      }
    } інакше якщо дані.операція == АСДОпераціяДілення {
      якщо перевірити_чи_тип_підтримує_udiv(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль llvm_value = LLVM::udiv(К.Л, блок.llvm_block, ліво_llvm_value, право_llvm_value);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, llvm_value, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      } інакше якщо перевірити_чи_тип_підтримує_sdiv(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль llvm_value = LLVM::sdiv(К.Л, блок.llvm_block, ліво_llvm_value, право_llvm_value);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, llvm_value, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      } інакше якщо перевірити_чи_тип_підтримує_fdiv(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль llvm_value = LLVM::fdiv(К.Л, блок.llvm_block, ліво_llvm_value, право_llvm_value);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, llvm_value, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      }
    } інакше якщо дані.операція == АСДОпераціяМодуль {
      якщо перевірити_чи_тип_підтримує_urem(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль llvm_value = LLVM::urem(К.Л, блок.llvm_block, ліво_llvm_value, право_llvm_value);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, llvm_value, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      } інакше якщо перевірити_чи_тип_підтримує_srem(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль llvm_value = LLVM::srem(К.Л, блок.llvm_block, ліво_llvm_value, право_llvm_value);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, llvm_value, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      } інакше якщо перевірити_чи_тип_підтримує_frem(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль llvm_value = LLVM::frem(К.Л, блок.llvm_block, ліво_llvm_value, право_llvm_value);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, llvm_value, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      }
    }

    ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Операція не підтримується");
    вернути РезультатЗначення { помилка = помилка_компіляції };
  }
}