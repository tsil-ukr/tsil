взяти визначення К;

секція цк {
  дія перевірити_чи_типи_рівні(К: комірка<Компілятор>, тип1: Тип, тип2: Тип): логічне {
    якщо тип1.вид != тип2.вид {
      вернути ні;
    }
    ціль дані = тип1.дані як комірка<ДаніТипуНативний>;
    ціль дані2 = тип2.дані як комірка<ДаніТипуНативний>;
    якщо дані == дані2 {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_add(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц64) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_fadd(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_sub(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц64) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_fsub(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_mul(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц64) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_fmul(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_udiv(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_п64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_sdiv(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц8) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц16) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_ц64) == так {
      вернути так;
    }
    вернути ні;
  }

  дія перевірити_чи_тип_підтримує_fdiv(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д32) == так {
      вернути так;
    }
    якщо перевірити_чи_типи_рівні(К, тип, К.тип_д64) == так {
      вернути так;
    }
    вернути ні;
  }

  місцева дія скомпілювати_значення_операція(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніОперація>): РезультатЗначення {
    ціль результат_компіляції_значення_ліво = скомпілювати_значення_як_значення(К, блок, середовище, дані.ліво, так);
    якщо результат_компіляції_значення_ліво.помилка != пусто {
      вернути РезультатЗначення { помилка = результат_компіляції_значення_ліво.помилка };
    }
    ціль результат_компіляції_значення_право = скомпілювати_значення_як_значення(К, блок, середовище, дані.право, так);
    якщо результат_компіляції_значення_право.помилка != пусто {
      вернути РезультатЗначення { помилка = результат_компіляції_значення_право.помилка };
    }
    ціль тип_ліво = результат_компіляції_значення_ліво.в.тип;
    ціль тип_право = результат_компіляції_значення_право.в.тип;
    ціль л_ліво = результат_компіляції_значення_ліво.в.л_значення;
    ціль л_право = результат_компіляції_значення_право.в.л_значення;

    якщо дані.операція == АСДОпераціяДодавання {
      якщо перевірити_чи_тип_підтримує_add(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль л_значення = LLVM::add(К.Л, блок.block, л_ліво, л_право);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, л_значення, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      } інакше якщо перевірити_чи_тип_підтримує_fadd(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль л_значення = LLVM::fadd(К.Л, блок.block, л_ліво, л_право);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, л_значення, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      }
    } інакше якщо дані.операція == АСДОпераціяВіднімання {
      якщо перевірити_чи_тип_підтримує_sub(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль л_значення = LLVM::sub(К.Л, блок.block, л_ліво, л_право);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, л_значення, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      } інакше якщо перевірити_чи_тип_підтримує_fsub(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль л_значення = LLVM::fsub(К.Л, блок.block, л_ліво, л_право);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, л_значення, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      }
    } інакше якщо дані.операція == АСДОпераціяМноження {
      якщо перевірити_чи_тип_підтримує_mul(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль л_значення = LLVM::mul(К.Л, блок.block, л_ліво, л_право);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, л_значення, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      } інакше якщо перевірити_чи_тип_підтримує_fmul(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль л_значення = LLVM::fmul(К.Л, блок.block, л_ліво, л_право);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, л_значення, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      }
    } інакше якщо дані.операція == АСДОпераціяДілення {
      якщо перевірити_чи_тип_підтримує_udiv(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль л_значення = LLVM::udiv(К.Л, блок.block, л_ліво, л_право);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, л_значення, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      } інакше якщо перевірити_чи_тип_підтримує_sdiv(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль л_значення = LLVM::sdiv(К.Л, блок.block, л_ліво, л_право);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, л_значення, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      } інакше якщо перевірити_чи_тип_підтримує_fdiv(К, тип_ліво) == так {
        якщо перевірити_чи_типи_рівні(К, тип_ліво, тип_право) == так {
          ціль л_значення = LLVM::fdiv(К.Л, блок.block, л_ліво, л_право);
          ціль обʼєкт_виконання = ОбʼєктВиконання { тип_ліво, л_значення, unloaded = ні };
          вернути РезультатЗначення { значення = Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, помилка = пусто };
        }
      }
    }

    ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Операція не підтримується");
    вернути РезультатЗначення { помилка = помилка_компіляції };
  }
}

секція ц {
//  місцева дія скомпілювати_операцію(К: комірка<Компілятор>, л_блок: комірка<ЛБлок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніОперація>): РезультатКомпіляціїОперації {
//    ціль результат_компіляції_ліво_як_значення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.ліво, так);
//    якщо результат_компіляції_ліво_як_значення.помилка != пусто {
//      вернути РезультатКомпіляціїОперації { Тип {}, пусто, результат_компіляції_ліво_як_значення.помилка };
//    }
//    ціль результат_компіляції_право_як_значення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.право, так);
//    якщо результат_компіляції_право_як_значення.помилка != пусто {
//      вернути РезультатКомпіляціїОперації { Тип {}, пусто, результат_компіляції_право_як_значення.помилка };
//    }
//    ціль тип_ліво = результат_компіляції_ліво_як_значення.тип;
//    ціль тип_право = результат_компіляції_право_як_значення.тип;
//
//    якщо дані.операція == АСДОпераціяДодавання {
//      якщо перевірити_тип(К, тип_право, тип_ліво) == ні {
//        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Типи операндів не сумісні");
//        вернути РезультатКомпіляціїОперації { Тип {}, пусто, помилка_компіляції };
//      }
//      якщо перевірити_чи_тип_підтримує_add(К, тип_ліво) == так {
//        ціль л_значення = LLVM::add(К.Л, л_блок, результат_компіляції_ліво_як_значення.л_значення, результат_компіляції_право_як_значення.л_значення);
//        вернути РезультатКомпіляціїОперації { К.тип_ц32, л_значення, пусто };
//      }
//      якщо перевірити_чи_тип_підтримує_fadd(К, тип_ліво) == так {
//        ціль л_значення = LLVM::fadd(К.Л, л_блок, результат_компіляції_ліво_як_значення.л_значення, результат_компіляції_право_як_значення.л_значення);
//        вернути РезультатКомпіляціїОперації { К.тип_ц32, л_значення, пусто };
//      }
//    } інакше якщо дані.операція == АСДОпераціяВіднімання {
//      якщо перевірити_тип(К, тип_право, тип_ліво) == ні {
//        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Типи операндів не сумісні");
//        вернути РезультатКомпіляціїОперації { Тип {}, пусто, помилка_компіляції };
//      }
//      якщо перевірити_чи_тип_підтримує_sub(К, тип_ліво) == так {
//        ціль л_значення = LLVM::sub(К.Л, л_блок, результат_компіляції_ліво_як_значення.л_значення, результат_компіляції_право_як_значення.л_значення);
//        вернути РезультатКомпіляціїОперації { К.тип_ц32, л_значення, пусто };
//      }
//      якщо перевірити_чи_тип_підтримує_fsub(К, тип_ліво) == так {
//        ціль л_значення = LLVM::fsub(К.Л, л_блок, результат_компіляції_ліво_як_значення.л_значення, результат_компіляції_право_як_значення.л_значення);
//        вернути РезультатКомпіляціїОперації { К.тип_ц32, л_значення, пусто };
//      }
//    }
//
//    ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Операція не підтримується");
//    вернути РезультатКомпіляціїОперації { Тип {}, пусто, помилка_компіляції };
//  }
}