взяти визначення К;

секція ц {
  місцева дія скомпілювати_є(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: адреса<Місцезнаходження>, дані: адреса<АСДДаніОперація>, очікуваний_тип: адреса<ОбʼєктТипу>): Результат {
    ціль результат_компіляції_ліво = скомпілювати_значення(К, інформація_середовища, дані.ліво, пусто);
    якщо результат_компіляції_ліво.помилка != пусто {
      вернути результат_помилка(результат_компіляції_ліво.помилка);
    }
    ціль результат_компіляції_право = скомпілювати_значення_як_тип(К, інформація_середовища, дані.право, так);
    якщо результат_компіляції_право.помилка != пусто {
      вернути результат_помилка(результат_компіляції_право.помилка);
    }
    якщо результат_компіляції_ліво.обʼєкт.вид != ВидОбʼєктаНезавантаженеЗначення {
      вернути результат_помилка(виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось є"));
    }
    ціль значення = результат_компіляції_ліво.обʼєкт.дані як ОбʼєктНезавантаженогоЗначення;
    ціль тип = результат_компіляції_право.обʼєкт_типу;
    якщо значення.тип.вид == ВидТипуПерелік {
      якщо тип.вид == ВидТипуПростийЕлементПереліку {
        ціль позиція_елемента_переліку = тип.позиція_елемента_переліку;
        ціль gep_positions_for_type = виділити<адреса<LLVM::Value>>(2);
        gep_positions_for_type[0] = LLVM::const_int32(К.L, 0);
        gep_positions_for_type[1] = LLVM::const_int32(К.L, 0);
        ціль llvm_value_gep_type = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, значення.тип.llvm_type, значення.llvm_value, 2, gep_positions_for_type);
        ціль llvm_real_value = LLVM::load(К.L, інформація_середовища.llvm_block, LLVM::i8(К.L), llvm_value_gep_type);
        ціль llvm_expected_value = LLVM::const_int8(К.L, ц8(позиція_елемента_переліку));
        ціль result = LLVM::icmp_eq(К.L, інформація_середовища.llvm_block, llvm_real_value, llvm_expected_value);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { К.тип_логічне, result } }, помилка = пусто };
      }
      якщо тип.вид == ВидТипуЕлементПерелікуСтруктура {
        ціль позиція_елемента_переліку = тип.позиція_елемента_переліку;
        ціль gep_positions_for_type = виділити<адреса<LLVM::Value>>(2);
        gep_positions_for_type[0] = LLVM::const_int32(К.L, 0);
        gep_positions_for_type[1] = LLVM::const_int32(К.L, 0);
        ціль llvm_value_gep_type = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, значення.тип.llvm_type, значення.llvm_value, 2, gep_positions_for_type);
        ціль llvm_real_value = LLVM::load(К.L, інформація_середовища.llvm_block, LLVM::i8(К.L), llvm_value_gep_type);
        ціль llvm_expected_value = LLVM::const_int8(К.L, ц8(позиція_елемента_переліку));
        ціль result = LLVM::icmp_eq(К.L, інформація_середовища.llvm_block, llvm_real_value, llvm_expected_value);
        вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = ОбʼєктЗначення { К.тип_логічне, result } }, помилка = пусто };
      }
    }
    якщо значення.тип.вид == ВидТипуПростийЕлементПереліку {
      якщо тип.вид == ВидТипуПростийЕлементПереліку {
        якщо значення.тип == тип {
          вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = К.обʼєкт_значення_так }, помилка = пусто };
        } інакше {
          вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = К.обʼєкт_значення_ні }, помилка = пусто };
        }
      }
      якщо тип.вид == ВидТипуЕлементПерелікуСтруктура {
        якщо значення.тип == тип {
          вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = К.обʼєкт_значення_так }, помилка = пусто };
        } інакше {
          вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = К.обʼєкт_значення_ні }, помилка = пусто };
        }
      }
    }
    якщо значення.тип.вид == ВидТипуЕлементПерелікуСтруктура {
      якщо тип.вид == ВидТипуПростийЕлементПереліку {
        якщо значення.тип == тип {
          вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = К.обʼєкт_значення_так }, помилка = пусто };
        } інакше {
          вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = К.обʼєкт_значення_ні }, помилка = пусто };
        }
      }
      якщо тип.вид == ВидТипуЕлементПерелікуСтруктура {
        якщо значення.тип == тип {
          вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = К.обʼєкт_значення_так }, помилка = пусто };
        } інакше {
          вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = К.обʼєкт_значення_ні }, помилка = пусто };
        }
      }
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вдалось є");
    вернути результат_помилка(помилка_компіляції);
  }
}