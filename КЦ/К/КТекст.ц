взяти визначення К;
взяти визначення КД;

зовнішня дія tsil_replace_backslashes(значення: памʼять<п8>): памʼять<п8>;
зовнішня дія strlen(значення: памʼять<п8>): size_t;

секція ц {
  місцева дія скомпілювати_текст(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: адреса<Місцезнаходження>, дані: адреса<АСДДаніЗначенняТекст>, очікуваний_тип: адреса<ОбʼєктТипу>): Результат {
    якщо дані.ідентифікатор == пусто {
      змінна ціль val: памʼять<п8> = пусто;
      змінна ціль розмір_значення: позитивне = 0;
      якщо strlen(дані.значення) == 0 {
      } інакше {
       val = виділити<п8>(strlen(дані.значення));
       розмір_значення = КД::перекодувати_з_Ю8(дані.значення, strlen(дані.значення), val);
        якщо розмір_значення == 0 {
          ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Невідомий символ КД");
          вернути результат_помилка(помилка_компіляції);
        }
      }
      змінна ціль llvm_value_value: адреса<LLVM::Value> = пусто;
      якщо val == пусто {
        llvm_value_value = LLVM::null(К.L);
      } інакше {
        llvm_value_value = LLVM::const_string(К.L, val);
      }
      якщо llvm_value_value == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Помилка LLVM створення тексту");
        вернути результат_помилка(помилка_компіляції);
      }

      ціль llvm_value_struct = LLVM::alloca(К.L, інформація_середовища.обʼєкт_дії.llvm_alloca_block, ю8сі"construct", К.тип_текст.llvm_type);

      ціль gep_positions_for_value = виділити<адреса<LLVM::Value>>(2);
      gep_positions_for_value[0] = LLVM::const_int32(К.L, 0);
      gep_positions_for_value[1] = LLVM::const_int32(К.L, 0);
      ціль llvm_value_struct_gep_value = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, К.тип_текст.llvm_type, llvm_value_struct, 2, gep_positions_for_value);
      LLVM::store(К.L, інформація_середовища.llvm_block, llvm_value_value, llvm_value_struct_gep_value);

      ціль gep_positions_for_size = виділити<адреса<LLVM::Value>>(2);
      gep_positions_for_size[0] = LLVM::const_int32(К.L, 0);
      gep_positions_for_size[1] = LLVM::const_int32(К.L, 1);
      ціль llvm_value_struct_gep_size = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, К.тип_текст.llvm_type, llvm_value_struct, 2, gep_positions_for_size);
      LLVM::store(К.L, інформація_середовища.llvm_block, LLVM::const_uint64(К.L, п64(розмір_значення)), llvm_value_struct_gep_size);

      ціль обʼєкт_значення: ОбʼєктНезавантаженогоЗначення;
      обʼєкт_значення.тип = К.тип_текст;
      обʼєкт_значення.llvm_value = llvm_value_struct;
      вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, дані = обʼєкт_значення }, помилка = пусто };
    } інакше якщо strcmp(дані.ідентифікатор.значення, ю8сі"сі") == 0 {
      змінна ціль значення = виділити<п8>(strlen(дані.значення) + 1);
      якщо strlen(дані.значення) == 0 {
      } інакше {
        змінна ціль розмір_значення = КД::перекодувати_з_Ю8(дані.значення, strlen(дані.значення), значення);
        якщо розмір_значення == 0 {
          ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Невідомий символ КД");
          вернути результат_помилка(помилка_компіляції);
        }
      }
      значення[strlen(дані.значення)] = 0;
      ціль llvm_value = LLVM::const_string(К.L, значення);
      якщо llvm_value == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Помилка LLVM створення тексту");
        вернути результат_помилка(помилка_компіляції);
      }
      ціль обʼєкт_типу_комірки = виділити_обʼєкт_типу(ВидТипуПамʼять);
      обʼєкт_типу_комірки.тип_памʼяті = К.тип_п8;
      обʼєкт_типу_комірки.llvm_type = LLVM::pointer(К.L);
      ціль обʼєкт_значення: ОбʼєктЗначення;
      обʼєкт_значення.тип = обʼєкт_типу_комірки;
      обʼєкт_значення.llvm_value = llvm_value;
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
    } інакше якщо strcmp(дані.ідентифікатор.значення, ю8сі"ю8") == 0 {
      ціль val = tsil_replace_backslashes(дані.значення);
      ціль llvm_value_value = LLVM::const_string(К.L, val);
      якщо llvm_value_value == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Помилка LLVM створення юнікоду");
        вернути результат_помилка(помилка_компіляції);
      }

      ціль llvm_value_struct = LLVM::alloca(К.L, інформація_середовища.обʼєкт_дії.llvm_alloca_block, ю8сі"construct", К.тип_ю8.llvm_type);

      ціль gep_positions_for_value = виділити<адреса<LLVM::Value>>(2);
      gep_positions_for_value[0] = LLVM::const_int32(К.L, 0);
      gep_positions_for_value[1] = LLVM::const_int32(К.L, 0);
      ціль llvm_value_struct_gep_value = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, К.тип_ю8.llvm_type, llvm_value_struct, 2, gep_positions_for_value);
      LLVM::store(К.L, інформація_середовища.llvm_block, llvm_value_value, llvm_value_struct_gep_value);

      ціль gep_positions_for_size = виділити<адреса<LLVM::Value>>(2);
      gep_positions_for_size[0] = LLVM::const_int32(К.L, 0);
      gep_positions_for_size[1] = LLVM::const_int32(К.L, 1);
      ціль llvm_value_struct_gep_size = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, К.тип_ю8.llvm_type, llvm_value_struct, 2, gep_positions_for_size);
      LLVM::store(К.L, інформація_середовища.llvm_block, LLVM::const_uint64(К.L, п64(strlen(val))), llvm_value_struct_gep_size);

      ціль обʼєкт_значення: ОбʼєктНезавантаженогоЗначення;
      обʼєкт_значення.тип = К.тип_ю8;
      обʼєкт_значення.llvm_value = llvm_value_struct;
      вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, дані = обʼєкт_значення }, помилка = пусто };
    } інакше якщо strcmp(дані.ідентифікатор.значення, ю8сі"ю8сі") == 0 {
      ціль llvm_value = LLVM::const_string(К.L, tsil_replace_backslashes(дані.значення));
      якщо llvm_value == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Помилка LLVM створення юнікоду");
        вернути результат_помилка(помилка_компіляції);
      }
      ціль обʼєкт_типу_комірки = виділити_обʼєкт_типу(ВидТипуПамʼять);
      обʼєкт_типу_комірки.тип_памʼяті = К.тип_п8;
      обʼєкт_типу_комірки.llvm_type = LLVM::pointer(К.L);
      ціль обʼєкт_значення: ОбʼєктЗначення;
      обʼєкт_значення.тип = обʼєкт_типу_комірки;
      обʼєкт_значення.llvm_value = llvm_value;
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Таке кодування наразі не підтримується");
    вернути результат_помилка(помилка_компіляції);
  }
}