взяти визначення К;

секція цк {
  місцева дія скомпілювати_значення_обʼєкт(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніЗначенняОбʼєкт>): РезультатЗначення {
    ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Не реалізовано");
    вернути РезультатЗначення { помилка = помилка_компіляції };
  }
}

секція ц {
  дія скомпілювати_обʼєкт_вручну(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, тип: комірка<ОбʼєктТипу>, кількість_аргументів: позитивне, аргументи: памʼять<комірка<АСДАргументОбʼєкта>>, завантажити: логічне): Результат {
    якщо тип == пусто {
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не вказано тип");
      вернути Результат { помилка = помилка_компіляції };
    }
    якщо тип.вид == ВидТипуСтруктура {
      ціль llvm_value = LLVM::alloca(К.L, блок.llvm_alloca_block, ю8"construct", тип.llvm_type);
      змінна ах: позитивне = 0;
      поки ах < кількість_аргументів {
        якщо ах >= тип.властивості_структури.довжина {
          ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Забагато аргументів");
          вернути Результат { помилка = помилка_компіляції };
        }
        змінна властивість_структури: ВластивістьСтруктури;
        змінна позиція_властивості_структури: позитивне = 0;
        ціль аргумент = аргументи[ах];
        якщо аргумент.ідентифікатор == пусто {
          властивість_структури = тип.властивості_структури.дані[ах];
          позиція_властивості_структури = ах;
        } інакше {
          ціль помилка_компіляції = виділити_помилку_компіляції(аргумент.місцезнаходження, ю8"Не реалізовано");
          вернути Результат { помилка = помилка_компіляції };
        }

        ціль gep_positions_llvm_values = виділити<комірка<LLVM::Value>>(2);
        gep_positions_llvm_values[0] = LLVM::const_int32(К.L, 0);
        gep_positions_llvm_values[1] = LLVM::const_int32(К.L, позиція_властивості_структури);
        ціль llvm_value_gep = LLVM::getelementptr(К.L, блок.llvm_block, тип.llvm_type, llvm_value, 2, gep_positions_llvm_values);
        ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, пусто, середовище, аргумент.значення, властивість_структури.тип);
        якщо результат_компіляції_значення.помилка != пусто {
          вернути Результат { помилка = результат_компіляції_значення.помилка };
        }
        ціль обʼєкт_значення = результат_компіляції_значення.обʼєкт_значення;
        якщо перевірити_тип(К, обʼєкт_значення.тип, властивість_структури.тип) == ні {
          ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Невідповідні типи");
          вернути Результат { помилка = помилка_компіляції };
        }
        LLVM::store(К.L, блок.llvm_block, обʼєкт_значення.llvm_value, llvm_value_gep);

        ах = ах + 1;
      }
      ціль обʼєкт_значення = ОбʼєктЗначення {};
      обʼєкт_значення.тип = тип;
      якщо завантажити == так {
        обʼєкт_значення.llvm_value = LLVM::load(К.L, блок.llvm_block, тип.llvm_type, llvm_value);
      } інакше {
        обʼєкт_значення.llvm_value = llvm_value;
      }
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не реалізовано");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія скомпілювати_обʼєкт(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніЗначенняОбʼєкт>, завантажити: логічне): Результат {
    ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, пусто, пусто, середовище, дані.тип);
    якщо результат_компіляції_типу.помилка != пусто {
      вернути Результат { помилка = результат_компіляції_типу.помилка };
    }
    ціль тип = результат_компіляції_типу.обʼєкт_типу;
    вернути скомпілювати_обʼєкт_вручну(К, блок, інформація_виконання_шаблону, середовище, місцезнаходження, тип, дані.кількість_аргументів, дані.аргументи, завантажити);
  }

  місцева дія скомпілювати_безтиповий_обʼєкт(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніЗначенняБезтиповийОбʼєкт>, очікуваний_тип: комірка<ОбʼєктТипу>, завантажити: логічне): Результат {
    вернути скомпілювати_обʼєкт_вручну(К, блок, інформація_виконання_шаблону, середовище, місцезнаходження, очікуваний_тип, дані.кількість_аргументів, дані.аргументи, завантажити);
  }
}