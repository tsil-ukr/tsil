взяти визначення К;

зовнішня дія tsil_hex_to_dec(value: памʼять<п8>, value_size: size_t, out: адреса<памʼять<п8>>, out_size: адреса<size_t>);

секція ц {
  дія отримати_обʼєкт_типу_з_асд_типу_числа(К: адреса<Компілятор>, тип: позитивне): адреса<ОбʼєктТипу> {
    якщо тип == АСДТипЧислаЦ8 {
      вернути К.тип_ц8;
    } інакше якщо тип == АСДТипЧислаЦ16 {
      вернути К.тип_ц16;
    } інакше якщо тип == АСДТипЧислаЦ32 {
      вернути К.тип_ц32;
    } інакше якщо тип == АСДТипЧислаЦ64 {
      вернути К.тип_ц64;
    } інакше якщо тип == АСДТипЧислаП8 {
      вернути К.тип_п8;
    } інакше якщо тип == АСДТипЧислаП16 {
      вернути К.тип_п16;
    } інакше якщо тип == АСДТипЧислаП32 {
      вернути К.тип_п32;
    } інакше якщо тип == АСДТипЧислаП64 {
      вернути К.тип_п64;
    } інакше якщо тип == АСДТипЧислаД32 {
      вернути К.тип_д32;
    } інакше якщо тип == АСДТипЧислаД64 {
      вернути К.тип_д64;
    } інакше {
      вернути К.тип_ніщо;
    }
  }

  місцева дія розібрати_число(К: адреса<Компілятор>, значення: ю8, місцезнаходження: адреса<Місцезнаходження>, очікуваний_тип: адреса<ОбʼєктТипу>): Результат {
    змінна ціль тип: адреса<ОбʼєктТипу>;
    змінна ціль llvm_value: адреса<LLVM::Value>;
    якщо очікуваний_тип == К.тип_ц8 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8(значення, різне::числа::ТипЧислаЦ8);
      якщо результат_розбору_числа.успіх == позитивне(ні) {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути результат_помилка(помилка_компіляції);
      }
      тип = К.тип_ц8;
      llvm_value = LLVM::const_int8(К.L, результат_розбору_числа.значення як ц8);
    } інакше якщо очікуваний_тип == К.тип_ц16 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8(значення, різне::числа::ТипЧислаЦ16);
      якщо результат_розбору_числа.успіх == позитивне(ні) {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути результат_помилка(помилка_компіляції);
      }
      тип = К.тип_ц16;
      llvm_value = LLVM::const_int16(К.L, результат_розбору_числа.значення як ц16);
    } інакше якщо очікуваний_тип == К.тип_ц32 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8(значення, різне::числа::ТипЧислаЦ32);
      якщо результат_розбору_числа.успіх == позитивне(ні) {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути результат_помилка(помилка_компіляції);
      }
      тип = К.тип_ц32;
      llvm_value = LLVM::const_int32(К.L, результат_розбору_числа.значення як ц32);
    } інакше якщо очікуваний_тип == К.тип_ц64 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8(значення, різне::числа::ТипЧислаЦ64);
      якщо результат_розбору_числа.успіх == позитивне(ні) {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути результат_помилка(помилка_компіляції);
      }
      тип = К.тип_ц64;
      llvm_value = LLVM::const_int64(К.L, результат_розбору_числа.значення як ц64);
    } інакше якщо очікуваний_тип == К.тип_логічне {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8(значення, різне::числа::ТипЧислаП8);
      якщо результат_розбору_числа.успіх == позитивне(ні) {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути результат_помилка(помилка_компіляції);
      }
      тип = К.тип_логічне;
      llvm_value = LLVM::const_uint1(К.L, результат_розбору_числа.значення як п8);
    } інакше якщо очікуваний_тип == К.тип_п8 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8(значення, різне::числа::ТипЧислаП8);
      якщо результат_розбору_числа.успіх == позитивне(ні) {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути результат_помилка(помилка_компіляції);
      }
      тип = К.тип_п8;
      llvm_value = LLVM::const_uint8(К.L, результат_розбору_числа.значення як п8);
    } інакше якщо очікуваний_тип == К.тип_п16 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8(значення, різне::числа::ТипЧислаП16);
      якщо результат_розбору_числа.успіх == позитивне(ні) {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути результат_помилка(помилка_компіляції);
      }
      тип = К.тип_п16;
      llvm_value = LLVM::const_uint16(К.L, результат_розбору_числа.значення як п16);
    } інакше якщо очікуваний_тип == К.тип_п32 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8(значення, різне::числа::ТипЧислаП32);
      якщо результат_розбору_числа.успіх == позитивне(ні) {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути результат_помилка(помилка_компіляції);
      }
      тип = К.тип_п32;
      llvm_value = LLVM::const_uint32(К.L, результат_розбору_числа.значення як п32);
    } інакше якщо очікуваний_тип == К.тип_п64 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8(значення, різне::числа::ТипЧислаП64);
      якщо результат_розбору_числа.успіх == позитивне(ні) {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути результат_помилка(помилка_компіляції);
      }
      тип = К.тип_п64;
      llvm_value = LLVM::const_uint64(К.L, результат_розбору_числа.значення як п64);
    } інакше якщо очікуваний_тип == К.тип_д32 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8(значення, різне::числа::ТипЧислаД32);
      якщо результат_розбору_числа.успіх == позитивне(ні) {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути результат_помилка(помилка_компіляції);
      }
      тип = К.тип_д32;
      llvm_value = LLVM::const_float(К.L, результат_розбору_числа.значення як д32);
    } інакше якщо очікуваний_тип == К.тип_д64 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8(значення, різне::числа::ТипЧислаД64);
      якщо результат_розбору_числа.успіх == позитивне(ні) {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути результат_помилка(помилка_компіляції);
      }
      тип = К.тип_д64;
      llvm_value = LLVM::const_double(К.L, результат_розбору_числа.значення як д64);
    } інакше {
      якщо очікуваний_тип != пусто {
        біб::друк_ю8(ю8_в_ю8сі(обʼєкт_типу_як_ю8(очікуваний_тип)));
      }
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Невідомий тип числа");
      вернути результат_помилка(помилка_компіляції);
    }
    ціль обʼєкт_значення: ОбʼєктЗначення;
    обʼєкт_значення.тип = тип;
    обʼєкт_значення.llvm_value = llvm_value;
    вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
  }

  місцева дія скомпілювати_число(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: адреса<Місцезнаходження>, дані: адреса<АСДДаніЗначенняЧисло>, очікуваний_тип: адреса<ОбʼєктТипу>): Результат {
    змінна ціль значення = ю8 { дані.значення, дані.розмір_значення };
    якщо дані.база == 16 {
      tsil_hex_to_dec(значення.дані, значення.розмір, значення.дані::адреса, значення.розмір::адреса);
    }
    якщо дані.тип == АСДТипЧислаАВТО {
      якщо очікуваний_тип == пусто {
        ціль обʼєкт_сирого_значення = ОбʼєктСирогоЗначення::ЧислоЮ8 { значення };
        вернути Результат { Обʼєкт { ВидОбʼєктаСиреЗначення, дані = обʼєкт_сирого_значення як ОбʼєктСирогоЗначення }, помилка = пусто };
      } інакше {
        вернути розібрати_число(К, значення, місцезнаходження, очікуваний_тип);
      }
    }
    вернути розібрати_число(К, значення, місцезнаходження, отримати_обʼєкт_типу_з_асд_типу_числа(К, дані.тип));
  }
}