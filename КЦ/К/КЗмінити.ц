взяти визначення К;

секція ц {
  місцева дія скомпілювати_змінити(К: комірка<Компілятор>, л_блок: комірка<ЛБлок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніЗмінити>): РезультатКомпіляціїЗмінити {
    ціль результат_компіляції_обʼєкта_як_значення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.обʼєкт, ні);
    якщо результат_компіляції_обʼєкта_як_значення.помилка != пусто {
      вернути РезультатКомпіляціїЗмінити { результат_компіляції_обʼєкта_як_значення.помилка };
    }
    ціль тип = результат_компіляції_обʼєкта_як_значення.тип;
    якщо тип.вид != ВидТипуСтруктура {
      ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Обʼєкт не є структурою");
      вернути РезультатКомпіляціїЗмінити { помилка_компіляції };
    }
    ціль обʼєкт_структури = тип.дані як комірка<ОбʼєктСтруктури>;
    ціль назва = дані.ідентифікатор.значення;
    змінна параметр: комірка<Параметр> = пусто;
    змінна позиція_параметра: позитивне = 0;
    змінна пх: позитивне = 0;
    поки пх < обʼєкт_структури.параметри.довжина {
      якщо strcmp(обʼєкт_структури.параметри.дані[пх].назва, назва) == 0 {
        параметр = обʼєкт_структури.параметри.дані[пх];
        позиція_параметра = пх;
      }
      пх = пх + 1;
    }
    якщо параметр == пусто {
      ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Параметр не знайдено");
      вернути РезультатКомпіляціїЗмінити { помилка_компіляції };
    }
    ціль позиції_gep = виділити_список<комірка<ЛЗначення>>();
    // відкласти звільнити_список<комірка<ЛЗначення>>(позиції_gep);
    додати_до_списку<комірка<ЛЗначення>>(позиції_gep, LLVM::const_int32(К.Л, 0));
    додати_до_списку<комірка<ЛЗначення>>(позиції_gep, LLVM::const_int32(К.Л, позиція_параметра));
    ціль л_значення_gep = LLVM::getelementptr(К.Л, л_блок, отримати_ЛТип(К, тип), результат_компіляції_обʼєкта_як_значення.л_значення, позиції_gep.довжина, позиції_gep.дані);

    ціль результат_компіляції_значення_як_значення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.значення, так);
    якщо результат_компіляції_значення_як_значення.помилка != пусто {
      вернути РезультатКомпіляціїЗмінити { результат_компіляції_значення_як_значення.помилка };
    }

    LLVM::store(К.Л, л_блок, результат_компіляції_значення_як_значення.л_значення, л_значення_gep);

    вернути РезультатКомпіляціїЗмінити { пусто };
  }
}