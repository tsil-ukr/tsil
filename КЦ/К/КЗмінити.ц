взяти визначення К;

секція ц {
  місцева дія скомпілювати_змінити(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніЗмінити>): комірка<ПомилкаКомпіляції> {
    ціль результат_компіляції_обʼєкта = скомпілювати_значення(К, інформація_середовища, дані.обʼєкт, пусто);
    якщо результат_компіляції_обʼєкта.помилка != пусто {
      вернути результат_компіляції_обʼєкта.помилка;
    }
    ціль обʼєкт = результат_компіляції_обʼєкта.обʼєкт;
    змінна тип: комірка<ОбʼєктТипу>;
    змінна llvm_value: комірка<LLVM::Value>;
    якщо обʼєкт.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт_незавантаженого_значення = обʼєкт.дані як ОбʼєктНезавантаженогоЗначення;
      тип = обʼєкт_незавантаженого_значення.тип;
      llvm_value = обʼєкт_незавантаженого_значення.llvm_value;
      якщо тип.вид == ВидТипуКомірка {
        llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, тип.llvm_type, llvm_value);
        тип = тип.тип_комірки;
      }
    } інакше {
      ціль помилка_компіляції = виділити_помилку_компіляції(дані.ідентифікатор.місцезнаходження, ю8"Не вийшло");
      вернути помилка_компіляції;
    }
    якщо тип.вид != ВидТипуСтруктура {
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Не можна");
      вернути помилка_компіляції;
    }
    змінна позиція_знайденої_властивості: позитивне = 0;
    змінна властивість_структури: ВластивістьСтруктури;
    змінна властивість_структури_знайдено: логічне = ні;
    змінна пх: позитивне = 0;
    поки пх < тип.властивості_структури.довжина {
      якщо strcmp(тип.властивості_структури.дані[пх].назва, дані.ідентифікатор.значення) == 0 {
        позиція_знайденої_властивості = пх;
        властивість_структури = тип.властивості_структури.дані[пх];
        властивість_структури_знайдено = так;
      }
      пх = пх + 1;
    }
    якщо властивість_структури_знайдено == ні {
      ціль помилка_компіляції = виділити_помилку_компіляції(дані.ідентифікатор.місцезнаходження, ю8"Властивість не знайдено");
      вернути помилка_компіляції;
    }
    ціль gep_positions_llvm_values = виділити<комірка<LLVM::Value>>(2);
    gep_positions_llvm_values[0] = LLVM::const_int32(К.L, 0);
    gep_positions_llvm_values[1] = LLVM::const_int32(К.L, позиція_знайденої_властивості);
    ціль llvm_value_gep = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, тип.llvm_type, llvm_value, 2, gep_positions_llvm_values);
    ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, інформація_середовища, дані.значення, властивість_структури.тип);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути результат_компіляції_значення.помилка;
    }
    ціль обʼєкт_значення = результат_компіляції_значення.обʼєкт_значення;
    якщо перевірити_тип(обʼєкт_значення.тип, властивість_структури.тип) == ні {
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Невідповідні типи");
      вернути помилка_компіляції;
    }
    LLVM::store(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, llvm_value_gep);
    вернути пусто;
  }
}