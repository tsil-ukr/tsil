взяти визначення К;
взяти визначення КД;

зовнішня дія tsil_replace_backslashes(значення: памʼять<п8>): памʼять<п8>;

секція ц {
  дія система_КД_виділити_сиру_памʼять(системаКД: адреса<КД::Система>, розмір: позитивне): памʼять<п8> {
    вернути виділити<п8>(розмір);
  }

  дія система_КД_перевиділити_сиру_памʼять(системаКД: адреса<КД::Система>, значення: памʼять<п8>, новий_розмір: позитивне): памʼять<п8> {
    вернути перевиділити<п8>(значення, новий_розмір);
  }

  дія система_КД_звільнити_сиру_памʼять(системаКД: адреса<КД::Система>, значення: невідома_памʼять) {
    звільнити(значення як адреса);
  }

  місцева дія скомпілювати_текст(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: адреса<Місцезнаходження>, дані: адреса<АСДДаніЗначенняТекст>, очікуваний_тип: адреса<ОбʼєктТипу>): Результат {
    ціль системаКД = КД::Система {
      дані = пусто,
      виділити_сиру_памʼять = система_КД_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = система_КД_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = система_КД_звільнити_сиру_памʼять,
    };

    якщо дані.ідентифікатор == пусто {
      змінна val: памʼять<п8> = пусто;
      змінна розмір_значення: позитивне = 0;
      якщо strlen(дані.значення) == 0 {
      } інакше {
       змінна вихідКД = т8 { 0, пусто };
       якщо КД::перекодувати_ю8_в_т8(системаКД::адреса, ю8 { strlen(дані.значення), дані.значення }, вихідКД::адреса, так) == ні {
         ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Невідомий символ КД");
         вернути результат_помилка(помилка_компіляції);
       }
       val = вихідКД.дані;
       розмір_значення = вихідКД.розмір;
      }
      змінна llvm_value_value: адреса<LLVM::Value> = пусто;
      якщо val == пусто {
        llvm_value_value = LLVM::null(К.L);
      } інакше {
        llvm_value_value = LLVM::const_string_KD(К.L, т8 { розмір_значення, val });
      }
      якщо llvm_value_value == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Помилка LLVM створення тексту");
        вернути результат_помилка(помилка_компіляції);
      }

      ціль llvm_value_struct = LLVM::alloca(К.L, інформація_середовища.обʼєкт_дії.llvm_alloca_block, ю8"construct", К.тип_т8.llvm_type);

      ціль gep_positions_for_value = виділити<адреса<LLVM::Value>>(2);
      gep_positions_for_value[0] = LLVM::const_int32(К.L, 0);
      gep_positions_for_value[1] = LLVM::const_int32(К.L, 1);
      ціль llvm_value_struct_gep_value = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, К.тип_т8.llvm_type, llvm_value_struct, 2, gep_positions_for_value);
      LLVM::store(К.L, інформація_середовища.llvm_block, llvm_value_value, llvm_value_struct_gep_value);

      ціль gep_positions_for_size = виділити<адреса<LLVM::Value>>(2);
      gep_positions_for_size[0] = LLVM::const_int32(К.L, 0);
      gep_positions_for_size[1] = LLVM::const_int32(К.L, 0);
      ціль llvm_value_struct_gep_size = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, К.тип_т8.llvm_type, llvm_value_struct, 2, gep_positions_for_size);
      LLVM::store(К.L, інформація_середовища.llvm_block, LLVM::const_uint64(К.L, п64(розмір_значення)), llvm_value_struct_gep_size);

      ціль обʼєкт_значення: ОбʼєктНезавантаженогоЗначення;
      обʼєкт_значення.тип = К.тип_т8;
      обʼєкт_значення.llvm_value = llvm_value_struct;
      вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, дані = обʼєкт_значення }, помилка = пусто };
    } інакше якщо перевірити_чи_ю8_рівні(ю8 { дані.ідентифікатор.розмір_значення, дані.ідентифікатор.значення }, ю8"т8") {
      змінна val: памʼять<п8> = пусто;
      змінна розмір_значення: позитивне = 0;
      якщо strlen(дані.значення) == 0 {
      } інакше {
        змінна вихідКД = т8 { 0, пусто };
        якщо КД::перекодувати_ю8_в_т8(системаКД::адреса, ю8 { strlen(дані.значення), дані.значення }, вихідКД::адреса, так) == ні {
          ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Невідомий символ КД");
          вернути результат_помилка(помилка_компіляції);
        }
        val = вихідКД.дані;
        розмір_значення = вихідКД.розмір;
      }
      змінна llvm_value_value: адреса<LLVM::Value> = пусто;
      якщо val == пусто {
        llvm_value_value = LLVM::null(К.L);
      } інакше {
        llvm_value_value = LLVM::const_string_KD(К.L, т8 { розмір_значення, val });
      }
      якщо llvm_value_value == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Помилка LLVM створення тексту");
        вернути результат_помилка(помилка_компіляції);
      }

      ціль llvm_value_struct = LLVM::alloca(К.L, інформація_середовища.обʼєкт_дії.llvm_alloca_block, ю8"construct", К.тип_т8.llvm_type);

      ціль gep_positions_for_value = виділити<адреса<LLVM::Value>>(2);
      gep_positions_for_value[0] = LLVM::const_int32(К.L, 0);
      gep_positions_for_value[1] = LLVM::const_int32(К.L, 1);
      ціль llvm_value_struct_gep_value = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, К.тип_т8.llvm_type, llvm_value_struct, 2, gep_positions_for_value);
      LLVM::store(К.L, інформація_середовища.llvm_block, llvm_value_value, llvm_value_struct_gep_value);

      ціль gep_positions_for_size = виділити<адреса<LLVM::Value>>(2);
      gep_positions_for_size[0] = LLVM::const_int32(К.L, 0);
      gep_positions_for_size[1] = LLVM::const_int32(К.L, 0);
      ціль llvm_value_struct_gep_size = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, К.тип_т8.llvm_type, llvm_value_struct, 2, gep_positions_for_size);
      LLVM::store(К.L, інформація_середовища.llvm_block, LLVM::const_uint64(К.L, п64(розмір_значення)), llvm_value_struct_gep_size);

      ціль обʼєкт_значення: ОбʼєктНезавантаженогоЗначення;
      обʼєкт_значення.тип = К.тип_т8;
      обʼєкт_значення.llvm_value = llvm_value_struct;
      вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, дані = обʼєкт_значення }, помилка = пусто };
    } інакше якщо перевірити_чи_ю8_рівні(ю8 { дані.ідентифікатор.розмір_значення, дані.ідентифікатор.значення }, ю8"т8сі") {
      змінна значення = виділити<п8>(strlen(дані.значення) + 1);
      змінна розмір_значення: позитивне = 0;
      якщо strlen(дані.значення) == 0 {
      } інакше {
        змінна вихідКД = т8 { 0, пусто };
        якщо КД::перекодувати_ю8_в_т8(системаКД::адреса, ю8 { strlen(дані.значення), дані.значення }, вихідКД::адреса, так) == ні {
          ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Невідомий символ КД");
          вернути результат_помилка(помилка_компіляції);
        }
        значення = вихідКД.дані;
        розмір_значення = вихідКД.розмір;
      }
      значення[strlen(дані.значення)] = 0;
      ціль llvm_value = LLVM::const_string(К.L, ю8 { розмір_значення, значення });
      якщо llvm_value == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Помилка LLVM створення тексту");
        вернути результат_помилка(помилка_компіляції);
      }
      ціль обʼєкт_типу_комірки = виділити_обʼєкт_типу(ВидТипуПамʼять);
      обʼєкт_типу_комірки.тип_памʼяті = К.тип_п8;
      обʼєкт_типу_комірки.llvm_type = LLVM::pointer(К.L);
      ціль обʼєкт_значення: ОбʼєктЗначення;
      обʼєкт_значення.тип = обʼєкт_типу_комірки;
      обʼєкт_значення.llvm_value = llvm_value;
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
    } інакше якщо перевірити_чи_ю8_рівні(ю8 { дані.ідентифікатор.розмір_значення, дані.ідентифікатор.значення }, ю8"ю8") {
      ціль val = tsil_replace_backslashes(дані.значення);
      ціль llvm_value_value = LLVM::const_string(К.L, ю8 { strlen(val), val });
      якщо llvm_value_value == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Помилка LLVM створення юнікоду");
        вернути результат_помилка(помилка_компіляції);
      }

      ціль llvm_value_struct = LLVM::alloca(К.L, інформація_середовища.обʼєкт_дії.llvm_alloca_block, ю8"construct", К.тип_ю8.llvm_type);

      ціль gep_positions_for_value = виділити<адреса<LLVM::Value>>(2);
      gep_positions_for_value[0] = LLVM::const_int32(К.L, 0);
      gep_positions_for_value[1] = LLVM::const_int32(К.L, 1);
      ціль llvm_value_struct_gep_value = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, К.тип_ю8.llvm_type, llvm_value_struct, 2, gep_positions_for_value);
      LLVM::store(К.L, інформація_середовища.llvm_block, llvm_value_value, llvm_value_struct_gep_value);

      ціль gep_positions_for_size = виділити<адреса<LLVM::Value>>(2);
      gep_positions_for_size[0] = LLVM::const_int32(К.L, 0);
      gep_positions_for_size[1] = LLVM::const_int32(К.L, 0);
      ціль llvm_value_struct_gep_size = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, К.тип_ю8.llvm_type, llvm_value_struct, 2, gep_positions_for_size);
      LLVM::store(К.L, інформація_середовища.llvm_block, LLVM::const_uint64(К.L, п64(strlen(val))), llvm_value_struct_gep_size);

      ціль обʼєкт_значення: ОбʼєктНезавантаженогоЗначення;
      обʼєкт_значення.тип = К.тип_ю8;
      обʼєкт_значення.llvm_value = llvm_value_struct;
      вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, дані = обʼєкт_значення }, помилка = пусто };
    } інакше якщо перевірити_чи_ю8_рівні(ю8 { дані.ідентифікатор.розмір_значення, дані.ідентифікатор.значення }, ю8"ю8сі") {
      ціль val = tsil_replace_backslashes(дані.значення);
      ціль llvm_value = LLVM::const_string(К.L, ю8 { strlen(val), val });
      якщо llvm_value == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Помилка LLVM створення юнікоду");
        вернути результат_помилка(помилка_компіляції);
      }
      ціль обʼєкт_типу_комірки = виділити_обʼєкт_типу(ВидТипуПамʼять);
      обʼєкт_типу_комірки.тип_памʼяті = К.тип_п8;
      обʼєкт_типу_комірки.llvm_type = LLVM::pointer(К.L);
      ціль обʼєкт_значення: ОбʼєктЗначення;
      обʼєкт_значення.тип = обʼєкт_типу_комірки;
      обʼєкт_значення.llvm_value = llvm_value;
      вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення }, помилка = пусто };
    }
    ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Таке кодування наразі не підтримується");
    вернути результат_помилка(помилка_компіляції);
  }
}