взяти визначення К;

секція цк {
  місцева дія скомпілювати_дію(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніДія>): РезультатКомпіляціїДії {
    якщо інформація_виконання_шаблону != пусто {
      якщо дані.тіло == пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Тіло дії не вказано");
        вернути РезультатКомпіляціїДії { помилка = помилка_компіляції };
      }
    }

    ціль середовище_створення_дії = створити_середовище(середовище);

    ціль назва = дані.ідентифікатор.значення;
    ціль параметри = виділити_список<Параметр>();
    ціль тип_результату = К.тип_ніщо;

    ціль л_типи_параметрів = виділити<комірка<ЛТип>>(дані.кількість_параметрів);

    змінна пх: позитивне = 0;
    поки пх < дані.кількість_параметрів {
      ціль асд_параметр = дані.параметри[пх];
      ціль параметр = Параметр {};
      параметр.назва = асд_параметр.ідентифікатор.значення;
      ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, пусто, середовище_створення_дії, асд_параметр.тип);
      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатКомпіляціїДії { помилка = результат_компіляції_типу.помилка };
      }
      параметр.тип = результат_компіляції_типу.тип;
      додати_до_списку<Параметр>(параметри, параметр);
      л_типи_параметрів[пх] = отримати_ЛТип(К, результат_компіляції_типу.тип);
      пх = пх + 1;
    }

    якщо дані.тип_результату != пусто {
      ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, пусто, середовище_створення_дії, дані.тип_результату);
      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатКомпіляціїДії { помилка = результат_компіляції_типу.помилка };
      }
      тип_результату = результат_компіляції_типу.тип;
    }

    змінна лінкування: позитивне = 0;
    якщо дані.видимість == АСДВидимістьЗовнішня {
      лінкування = LLVM::LINKAGE_EXTERNAL;
    } інакше якщо дані.видимість == АСДВидимістьМісцева {
      лінкування = LLVM::LINKAGE_DSO_LOCAL;
    } інакше {
      лінкування = LLVM::LINKAGE_INTERNAL;
    }

    якщо strcmp(назва, ю8"main") == 0 {
      лінкування = LLVM::LINKAGE_EXTERNAL;
    }

    змінна назва_з_префіксом = назва;
    ціль префікс = отримати_префікс_назви(середовище_створення_дії);
    якщо префікс != пусто {
      назва_з_префіксом = зʼєднати_ю8(зʼєднати_ю8(префікс, ю8"::"), назва);
    }

    ціль д = виділити<Дія>();
    д.назва = назва;
    д.параметри = параметри;
    д.тип_результату = тип_результату;
    д.л_функція = LLVM::function(К.Л, лінкування, назва_з_префіксом, отримати_ЛТип(К, тип_результату), параметри.довжина, л_типи_параметрів, ні);

    ціль дтд = виділити<ДаніТипуДія>();
    дтд.л_тип_функції = LLVM::type_of_function(К.Л, д.л_функція);
    дтд.параметри = параметри;
    дтд.тип_результату = тип_результату;

    ціль дт = Тип {};
    дт.вид = ВидТипуДія;
    дт.дані = дтд;

    д.тип = дт;

    ціль значення = Значення {};
    значення.вид = ВидЗначенняОВ;
    значення.в = ОбʼєктВиконання { дт, д.л_функція як комірка<ЛЗначення> };

    якщо інформація_виконання_шаблону == пусто {
      змінити_в_середовищі(середовище_створення_дії, назва, ОбʼєктКомпіляції { ВидОКДія, д });
    } інакше {
      ціль значення = Значення {};
      значення.вид = ВидЗначенняОК;
      значення.к = ОбʼєктКомпіляції { ВидОКДія, д };

      ціль шаблон = інформація_виконання_шаблону.шаблон;
      ціль аргументи = інформація_виконання_шаблону.аргументи;
      ціль карта_готових_значень = шаблон.карта_готових_значень;

      змінити_значення_карти<комірка<список<Значення>>, Значення>(карта_готових_значень, аргументи, значення);
    }

    якщо дані.тіло != пусто {
      ціль середовище_дії = створити_середовище(середовище_створення_дії);

      ціль блок = виділити<Блок>();
      блок.ret_value = пусто;
      блок.alloca_block = LLVM::block(К.Л, д.л_функція, ю8"alloca");
      блок.block = LLVM::block(К.Л, д.л_функція, ю8"entry");
      блок.exit_block = LLVM::block(К.Л, д.л_функція, ю8"exit");
      блок.function_exit_block = блок.exit_block;

      якщо перевірити_тип(К, д.тип_результату, К.тип_ніщо) == ні {
        блок.ret_value = LLVM::alloca(К.Л, блок.alloca_block, ю8"return", отримати_ЛТип(К, д.тип_результату));
      }

      змінна пх: позитивне = 0;
      поки пх < д.параметри.довжина {
        ціль параметр = д.параметри.дані[пх];
        ціль arg = LLVM::function_arg(К.Л, д.л_функція, пх);
        ціль л_значення = LLVM::alloca(К.Л, блок.alloca_block, параметр.назва, отримати_ЛТип(К, параметр.тип));
        LLVM::store(К.Л, блок.alloca_block, arg, л_значення);
        ціль ц = виділити<Ціль>();
        ц.тип = параметр.тип;
        ц.л_значення_alloca = л_значення;
        змінити_в_середовищі(середовище_дії, параметр.назва, ОбʼєктКомпіляції { ВидОКЦіль, ц });
        пх = пх + 1;
      }

      ціль результат_компіляції_блоку = скомпілювати_блок(К, блок, середовище_дії, дані.тіло);
      якщо результат_компіляції_блоку.помилка != пусто {
        вернути РезультатКомпіляціїДії { помилка = результат_компіляції_блоку.помилка };
      }

      LLVM::br(К.Л, блок.alloca_block, блок.block);
      якщо блок.ret_value == пусто {
        LLVM::ret(К.Л, блок.exit_block, пусто);
      } інакше {
        ціль л_значення = LLVM::load(К.Л, блок.exit_block, отримати_ЛТип(К, д.тип_результату), блок.ret_value);
        LLVM::ret(К.Л, блок.exit_block, л_значення);
      }
    }

    вернути РезультатКомпіляціїДії { дія_ = д, помилка = пусто };
  }
}