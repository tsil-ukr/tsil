взяти визначення К;

секція ц {
  дія скомпілювати_обʼєкт_вручну(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: адреса<Місцезнаходження>, тип: адреса<ОбʼєктТипу>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<АСДАргументОбʼєкта>>, автозаповнення: логічне): Результат {
    якщо тип == пусто {
      ціль помилка_компіляції = виділити_помилку_неможливо_зробити_обʼєкт(місцезнаходження);
      вернути результат_помилка(помилка_компіляції);
    }
    якщо тип.вид == ВидТипуЕлементПереліку {
      ціль обʼєкт_типу_переліку = тип.обʼєкт_типу_переліку_елемента_переліку;
      якщо тип.обʼєкт_типу_структури_елемента_переліку != пусто {
        ціль llvm_value = LLVM::alloca(К.L, інформація_середовища.обʼєкт_дії.llvm_alloca_block, ю8"construct", обʼєкт_типу_переліку.llvm_type);
        ціль результат_чогосьтам = скомпілювати_обʼєкт_вручну(К, інформація_середовища, місцезнаходження, тип.обʼєкт_типу_структури_елемента_переліку, кількість_аргументів, аргументи, автозаповнення);
        якщо результат_чогосьтам.помилка != пусто {
          вернути результат_чогосьтам;
        }
        ціль результат_чогосьтам_як_значення = отримати_як_значення(К, інформація_середовища, місцезнаходження, результат_чогосьтам.обʼєкт, пусто);
        якщо результат_чогосьтам_як_значення.помилка != пусто {
          вернути результат_помилка(результат_чогосьтам_як_значення.помилка);
        }
        ціль обʼєкт_значення = результат_чогосьтам_як_значення.обʼєкт_значення;
        ціль gep_positions_for_type = виділити<адреса<LLVM::Value>>(2);
        gep_positions_for_type[0] = LLVM::const_int32(К.L, 0);
        gep_positions_for_type[1] = LLVM::const_int32(К.L, 0);
        ціль llvm_value_gep_type = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, обʼєкт_типу_переліку.llvm_type, llvm_value, 2, gep_positions_for_type);
        LLVM::store(К.L, інформація_середовища.llvm_block, LLVM::const_int64(К.L, ц64(тип.позиція_елемента_переліку)), llvm_value_gep_type);
        ціль gep_positions_for_value = виділити<адреса<LLVM::Value>>(2);
        gep_positions_for_value[0] = LLVM::const_int32(К.L, 0);
        gep_positions_for_value[1] = LLVM::const_int32(К.L, 1);
        ціль llvm_value_gep_value = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, обʼєкт_типу_переліку.llvm_type, llvm_value, 2, gep_positions_for_value);
        LLVM::store(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, llvm_value_gep_value);
        вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, дані = ОбʼєктНезавантаженогоЗначення { тип, llvm_value, позитивне(так) } }, помилка = пусто };
      }
    }
    якщо тип.вид == ВидТипуСтруктура {
      ціль llvm_value = LLVM::alloca(К.L, інформація_середовища.обʼєкт_дії.llvm_alloca_block, ю8"construct", тип.llvm_type);
      ціль заповнені_властивості = виділити_накопичувач<ю8>();
      змінна ціль ах: позитивне = 0;
      поки ах < кількість_аргументів {
        якщо ах >= тип.властивості_структури.розмір {
          ціль помилка_компіляції = виділити_помилку_компіляції_невірна_кількість_аргументів_обʼєкта(місцезнаходження, тип.властивості_структури.розмір, кількість_аргументів);
          вернути результат_помилка(помилка_компіляції);
        }
        змінна ціль властивість_структури: адреса<ВластивістьСтруктури> = пусто;
        змінна ціль позиція_властивості_структури: позитивне = 0;
        ціль аргумент = аргументи[ах];
        змінна ціль місцезнаходження_аргумента = аргумент.місцезнаходження;
        якщо аргумент.ідентифікатор == пусто {
          місцезнаходження_аргумента = аргумент.значення.місцезнаходження;
          властивість_структури = тип.властивості_структури.дані[ах]::адреса;
          позиція_властивості_структури = ах;
        } інакше {
          місцезнаходження_аргумента = аргумент.ідентифікатор.місцезнаходження;
          змінна ціль пх: позитивне = 0;
          поки пх < тип.властивості_структури.розмір {
            якщо strcmp(ю8_в_ю8сі(тип.властивості_структури.дані[пх].назва.значення), аргумент.ідентифікатор.значення) == 0 {
              властивість_структури = тип.властивості_структури.дані[пх]::адреса;
              позиція_властивості_структури = пх;
            }
            пх = пх + 1;
          }
        }
        якщо властивість_структури == пусто {
          ціль помилка_компіляції = виділити_помилку_компіляції_властивість_не_знайдено(місцезнаходження_аргумента, ю8сі_в_ю8(аргумент.ідентифікатор.значення), тип);
          вернути результат_помилка(помилка_компіляції);
        }
        змінна ціль пзв: позитивне = 0;
        поки пзв < заповнені_властивості.розмір {
          якщо перевірити_чи_ю8_рівні(властивість_структури.назва.значення, заповнені_властивості.дані[пзв]) {
            ціль помилка_компіляції = виділити_помилку_компіляції_властивість_вже_заповнено(місцезнаходження_аргумента, властивість_структури.назва.значення);
            вернути результат_помилка(помилка_компіляції);
          }
          пзв += 1;
        }
        ціль gep_positions_llvm_values = виділити<адреса<LLVM::Value>>(2);
        gep_positions_llvm_values[0] = LLVM::const_int32(К.L, 0);
        gep_positions_llvm_values[1] = LLVM::const_int32(К.L, ц32(позиція_властивості_структури));
        ціль llvm_value_gep = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, тип.llvm_type, llvm_value, 2, gep_positions_llvm_values);
        ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, інформація_середовища, аргумент.значення, властивість_структури.тип);
        якщо результат_компіляції_значення.помилка != пусто {
          вернути результат_помилка(результат_компіляції_значення.помилка);
        }
        змінна ціль обʼєкт_значення = результат_компіляції_значення.обʼєкт_значення;
        якщо властивість_структури.тип.вид == ВидТипуВаріація {
          змінна ціль знайдений_тип_варіації: адреса<ОбʼєктТипу> = пусто;
          змінна ціль пх: позитивне = 0;
          поки пх < властивість_структури.тип.типи_варіації.розмір {
            якщо перевірити_тип(обʼєкт_значення.тип, властивість_структури.тип.типи_варіації.дані[пх]) == так {
              знайдений_тип_варіації = властивість_структури.тип.типи_варіації.дані[пх];
            }
            пх = пх + 1;
          }
          якщо знайдений_тип_варіації == пусто {
            ціль помилка_компіляції = виділити_помилку_компіляції_невірний_тип_значення_властивості(місцезнаходження_аргумента, властивість_структури.назва.значення, властивість_структури.тип, обʼєкт_значення.тип, Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення });
            вернути результат_помилка(помилка_компіляції);
          }
        } інакше {
          ціль результат_перевірки_типу_значення = перевірити_тип_значення_і_перетворити_якщо_треба(К, інформація_середовища, властивість_структури.тип, обʼєкт_значення);
          якщо результат_перевірки_типу_значення.успіх == позитивне(ні) {
            ціль помилка_компіляції = виділити_помилку_компіляції_невірний_тип_значення_властивості(місцезнаходження_аргумента, властивість_структури.назва.значення, властивість_структури.тип, обʼєкт_значення.тип, Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення });
            вернути результат_помилка(помилка_компіляції);
          }
          обʼєкт_значення = результат_перевірки_типу_значення.обʼєкт_значення;
        }
        LLVM::store(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, llvm_value_gep);
        покласти_в_накопичувач<ю8>(заповнені_властивості, властивість_структури.назва.значення);
        ах = ах + 1;
      }
      якщо автозаповнення {
        // потім: заповнити незаповнені властивості
      } інакше {
        змінна ціль пх: позитивне = 0;
        поки пх < тип.властивості_структури.розмір {
          змінна ціль пзв: позитивне = 0;
          змінна ціль знайдено = ні;
          поки пзв < заповнені_властивості.розмір {
            якщо перевірити_чи_ю8_рівні(тип.властивості_структури.дані[пх].назва.значення, заповнені_властивості.дані[пзв]) {
              знайдено = так;
            }
            пзв += 1;
          }
          якщо знайдено == ні {
            ціль помилка_компіляції = виділити_помилку_компіляції_пропущено_властивість(місцезнаходження, тип.властивості_структури.дані[пх].назва.значення);
            вернути результат_помилка(помилка_компіляції);
          }
          пх += 1;
        }
      }
      ціль обʼєкт_значення: ОбʼєктНезавантаженогоЗначення;
      обʼєкт_значення.тип = тип;
      обʼєкт_значення.llvm_value = llvm_value;
      обʼєкт_значення.змінний = позитивне(так);
      вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженеЗначення, дані = обʼєкт_значення }, помилка = пусто };
    }
    ціль помилка_компіляції = виділити_помилку_неможливо_зробити_обʼєкт(місцезнаходження);
    вернути результат_помилка(помилка_компіляції);
  }

  місцева дія скомпілювати_обʼєкт(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: адреса<Місцезнаходження>, дані: адреса<АСДДаніЗначенняОбʼєкт>): Результат {
    ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, інформація_середовища, дані.тип, так);
    якщо результат_компіляції_типу.помилка != пусто {
      вернути результат_помилка(результат_компіляції_типу.помилка);
    }
    ціль тип = результат_компіляції_типу.обʼєкт_типу;
    вернути скомпілювати_обʼєкт_вручну(К, інформація_середовища, місцезнаходження, тип, дані.кількість_аргументів, дані.аргументи, логічне(дані.автозаповнення));
  }

  місцева дія скомпілювати_безтиповий_обʼєкт(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: адреса<Місцезнаходження>, дані: адреса<АСДДаніЗначенняБезтиповийОбʼєкт>, очікуваний_тип: адреса<ОбʼєктТипу>): Результат {
    вернути скомпілювати_обʼєкт_вручну(К, інформація_середовища, місцезнаходження, очікуваний_тип, дані.кількість_аргументів, дані.аргументи, логічне(дані.автозаповнення));
  }
}