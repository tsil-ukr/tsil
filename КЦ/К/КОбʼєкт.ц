взяти визначення К;

секція ц {

  дія скомпілювати_обʼєкт_вручну(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, тип: комірка<ОбʼєктТипу>, кількість_аргументів: позитивне, аргументи: памʼять<комірка<АСДАргументОбʼєкта>>): Результат {
    якщо тип == пусто {
      ціль помилка_компіляції = виділити_помилку_неможливо_зробити_обʼєкт(місцезнаходження);
      вернути Результат { помилка = помилка_компіляції };
    }
    якщо тип.вид == ВидТипуСтруктура {
      ціль llvm_value = LLVM::alloca(К.L, інформація_середовища.обʼєкт_дії.llvm_alloca_block, ю8"construct", тип.llvm_type);
      // потім: перевіряти які властивості вже заповнено
      змінна ах: позитивне = 0;
      поки ах < кількість_аргументів {
        якщо ах >= тип.властивості_структури.довжина {
          ціль помилка_компіляції = виділити_помилку_компіляції_невірна_кількість_аргументів_обʼєкта(місцезнаходження, тип.властивості_структури.довжина, кількість_аргументів);
          вернути Результат { помилка = помилка_компіляції };
        }
        змінна властивість_структури: ВластивістьСтруктури;
        змінна позиція_властивості_структури: позитивне = 0;
        ціль аргумент = аргументи[ах];
        якщо аргумент.ідентифікатор == пусто {
          властивість_структури = тип.властивості_структури.дані[ах];
          позиція_властивості_структури = ах;
        } інакше {
          змінна пх: позитивне = 0;
          поки пх < тип.властивості_структури.довжина {
            якщо strcmp(тип.властивості_структури.дані[пх].назва, аргумент.ідентифікатор.значення) == 0 {
              властивість_структури = тип.властивості_структури.дані[пх];
              позиція_властивості_структури = пх;
            }
            пх = пх + 1;
          }
        }
        ціль gep_positions_llvm_values = виділити<комірка<LLVM::Value>>(2);
        gep_positions_llvm_values[0] = LLVM::const_int32(К.L, 0);
        gep_positions_llvm_values[1] = LLVM::const_int32(К.L, позиція_властивості_структури як ц32);
        ціль llvm_value_gep = LLVM::getelementptr(К.L, інформація_середовища.llvm_block, тип.llvm_type, llvm_value, 2, gep_positions_llvm_values);
        ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, інформація_середовища, аргумент.значення, властивість_структури.тип);
        якщо результат_компіляції_значення.помилка != пусто {
          вернути Результат { помилка = результат_компіляції_значення.помилка };
        }
        ціль обʼєкт_значення = результат_компіляції_значення.обʼєкт_значення;
        якщо властивість_структури.тип.вид == ВидТипуВаріація {
          змінна знайдений_тип_варіації: комірка<ОбʼєктТипу> = пусто;
          змінна пх: позитивне = 0;
          поки пх < властивість_структури.тип.типи_варіації.довжина {
            якщо перевірити_тип(обʼєкт_значення.тип, властивість_структури.тип.типи_варіації.дані[пх]) == так {
              знайдений_тип_варіації = властивість_структури.тип.типи_варіації.дані[пх];
            }
            пх = пх + 1;
          }
          якщо знайдений_тип_варіації == пусто {
            ціль помилка_компіляції = виділити_помилку_компіляції_невірний_тип_значення_властивості(місцезнаходження, властивість_структури.назва, властивість_структури.тип, обʼєкт_значення.тип, Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення });
            вернути Результат { помилка = помилка_компіляції };
          }
        } інакше {
          ціль результат_перевірки_типу_значення = перевірити_тип_значення_і_перетворити_якщо_треба(К, властивість_структури.тип, обʼєкт_значення);
          якщо результат_перевірки_типу_значення.успіх == ні {
            ціль помилка_компіляції = виділити_помилку_компіляції_невірний_тип_значення_властивості(місцезнаходження, властивість_структури.назва, властивість_структури.тип, обʼєкт_значення.тип, Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення });
            вернути Результат { помилка = помилка_компіляції };
          }
          обʼєкт_значення = результат_перевірки_типу_значення.обʼєкт_значення;
        }
        LLVM::store(К.L, інформація_середовища.llvm_block, обʼєкт_значення.llvm_value, llvm_value_gep);
        ах = ах + 1;
      }
      // потім: помилка якщо заповнено не всі властивості
      ціль обʼєкт_значення = ОбʼєктНезавантаженогоЗначення {};
      обʼєкт_значення.тип = тип;
      обʼєкт_значення.llvm_value = llvm_value;
      вернути Результат { Обʼєкт { ВидОбʼєктаНезавантаженогоЗначення, дані = обʼєкт_значення }, помилка = пусто };
    }
    ціль помилка_компіляції = виділити_помилку_неможливо_зробити_обʼєкт(місцезнаходження);
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія скомпілювати_обʼєкт(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніЗначенняОбʼєкт>): Результат {
    ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, інформація_середовища, дані.тип, так);
    якщо результат_компіляції_типу.помилка != пусто {
      вернути Результат { помилка = результат_компіляції_типу.помилка };
    }
    ціль тип = результат_компіляції_типу.обʼєкт_типу;
    вернути скомпілювати_обʼєкт_вручну(К, інформація_середовища, місцезнаходження, тип, дані.кількість_аргументів, дані.аргументи);
  }

  місцева дія скомпілювати_безтиповий_обʼєкт(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніЗначенняБезтиповийОбʼєкт>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    вернути скомпілювати_обʼєкт_вручну(К, інформація_середовища, місцезнаходження, очікуваний_тип, дані.кількість_аргументів, дані.аргументи);
  }
}