взяти визначення К;

секція ц {
  дія отримати_обʼєкт_типу_з_асд_типу_числа(К: комірка<Компілятор>, тип: позитивне): комірка<ОбʼєктТипу> {
    якщо тип == АСДТипЧислаЦ8 {
      вернути К.тип_ц8;
    } інакше якщо тип == АСДТипЧислаЦ16 {
      вернути К.тип_ц16;
    } інакше якщо тип == АСДТипЧислаЦ32 {
      вернути К.тип_ц32;
    } інакше якщо тип == АСДТипЧислаЦ64 {
      вернути К.тип_ц64;
    } інакше якщо тип == АСДТипЧислаП8 {
      вернути К.тип_п8;
    } інакше якщо тип == АСДТипЧислаП16 {
      вернути К.тип_п16;
    } інакше якщо тип == АСДТипЧислаП32 {
      вернути К.тип_п32;
    } інакше якщо тип == АСДТипЧислаП64 {
      вернути К.тип_п64;
    } інакше якщо тип == АСДТипЧислаД32 {
      вернути К.тип_д32;
    } інакше якщо тип == АСДТипЧислаД64 {
      вернути К.тип_д64;
    } інакше {
      вернути К.тип_ніщо;
    }
  }

  місцева дія скомпілювати_число(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніЗначенняЧисло>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    ціль значення = дані.значення;
    якщо дані.база != 10 {
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Підтримується тільки десяткова система числення");
      вернути Результат { помилка = помилка_компіляції };
    }
    якщо очікуваний_тип == пусто {
      якщо дані.тип == АСДТипЧислаАВТО {
        якщо дані.дробове == так {
          очікуваний_тип = К.тип_д64;
        } інакше {
          очікуваний_тип = К.тип_ц64;
        }
      } інакше {
        очікуваний_тип = отримати_обʼєкт_типу_з_асд_типу_числа(К, дані.тип);
      }
    } інакше {
      якщо дані.тип == АСДТипЧислаАВТО {
        // ок
      } інакше {
        якщо отримати_обʼєкт_типу_з_асд_типу_числа(К, дані.тип) != очікуваний_тип {
          ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Невідповідні типи");
          вернути Результат { помилка = помилка_компіляції };
        }
      }
    }
    змінна тип: комірка<ОбʼєктТипу>;
    змінна llvm_value: комірка<LLVM::Value>;
    якщо очікуваний_тип == К.тип_ц8 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаЦ8);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути Результат { помилка = помилка_компіляції };
      }
      тип = К.тип_ц8;
      llvm_value = LLVM::const_int8(К.L, результат_розбору_числа.значення як ц8);
    } інакше якщо очікуваний_тип == К.тип_ц16 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаЦ16);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути Результат { помилка = помилка_компіляції };
      }
      тип = К.тип_ц16;
      llvm_value = LLVM::const_int16(К.L, результат_розбору_числа.значення як ц16);
    } інакше якщо очікуваний_тип == К.тип_ц32 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаЦ32);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути Результат { помилка = помилка_компіляції };
      }
      тип = К.тип_ц32;
      llvm_value = LLVM::const_int32(К.L, результат_розбору_числа.значення як ц32);
    } інакше якщо очікуваний_тип == К.тип_ц64 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаЦ64);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути Результат { помилка = помилка_компіляції };
      }
      тип = К.тип_ц64;
      llvm_value = LLVM::const_int64(К.L, результат_розбору_числа.значення як ц64);
    } інакше якщо очікуваний_тип == К.тип_логічне {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП8);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути Результат { помилка = помилка_компіляції };
      }
      тип = К.тип_логічне;
      llvm_value = LLVM::const_uint1(К.L, результат_розбору_числа.значення як п8);
    } інакше якщо очікуваний_тип == К.тип_п8 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП8);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути Результат { помилка = помилка_компіляції };
      }
      тип = К.тип_п8;
      llvm_value = LLVM::const_uint8(К.L, результат_розбору_числа.значення як п8);
    } інакше якщо очікуваний_тип == К.тип_п16 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП16);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути Результат { помилка = помилка_компіляції };
      }
      тип = К.тип_п16;
      llvm_value = LLVM::const_uint16(К.L, результат_розбору_числа.значення як п16);
    } інакше якщо очікуваний_тип == К.тип_п32 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП32);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути Результат { помилка = помилка_компіляції };
      }
      тип = К.тип_п32;
      llvm_value = LLVM::const_uint32(К.L, результат_розбору_числа.значення як п32);
    } інакше якщо очікуваний_тип == К.тип_п64 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП64);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути Результат { помилка = помилка_компіляції };
      }
      тип = К.тип_п64;
      llvm_value = LLVM::const_uint64(К.L, результат_розбору_числа.значення як п64);
    } інакше якщо очікуваний_тип == К.тип_д32 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаД32);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути Результат { помилка = помилка_компіляції };
      }
      тип = К.тип_д32;
      llvm_value = LLVM::const_float(К.L, результат_розбору_числа.значення як д32);
    } інакше якщо очікуваний_тип == К.тип_д64 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаД64);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути Результат { помилка = помилка_компіляції };
      }
      тип = К.тип_д64;
      llvm_value = LLVM::const_double(К.L, результат_розбору_числа.значення як д64);
    } інакше {
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Невідомий тип числа");
      вернути Результат { помилка = помилка_компіляції };
    }
    ціль обʼєкт_значення = ОбʼєктЗначення {};
    обʼєкт_значення.тип = тип;
    обʼєкт_значення.llvm_value = llvm_value;
    ціль обʼєкт = Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення };
    вернути Результат { обʼєкт, помилка = пусто };
  }
}