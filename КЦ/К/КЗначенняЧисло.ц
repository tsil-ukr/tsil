взяти визначення К;

зовнішня дія strtod(значення: памʼять<п8>, вихід: невідома_комірка, база: ц32): дійсне;

секція цк {
  місцева дія скомпілювати_значення_число(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніЗначенняЧисло>, очікуваний_тип: позитивне): РезультатЗначення {
    ціль значення = дані.значення;

    якщо дані.база != 10 {
      ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Підтримується тільки десяткова система числення");
      вернути РезультатЗначення { помилка = помилка_компіляції };
    }

    змінна тип: Тип;
    змінна llvm_value: комірка<LLVM::Value>;

    якщо дані.тип == АСДТипЧислаЦ8 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаЦ8);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_ц8;
      llvm_value = LLVM::const_int8(К.Л, результат_розбору_числа.значення як ц8);
    } інакше якщо дані.тип == АСДТипЧислаЦ16 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаЦ16);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_ц16;
      llvm_value = LLVM::const_int16(К.Л, результат_розбору_числа.значення як ц16);
    } інакше якщо дані.тип == АСДТипЧислаЦ32 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаЦ32);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_ц32;
      llvm_value = LLVM::const_int32(К.Л, результат_розбору_числа.значення як ц32);
    } інакше якщо дані.тип == АСДТипЧислаЦ64 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаЦ64);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_ц64;
      llvm_value = LLVM::const_int64(К.Л, результат_розбору_числа.значення як ц64);
    } інакше якщо дані.тип == АСДТипЧислаП8 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП8);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_п8;
      llvm_value = LLVM::const_uint8(К.Л, результат_розбору_числа.значення як п8);
    } інакше якщо дані.тип == АСДТипЧислаП16 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП16);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_п16;
      llvm_value = LLVM::const_uint16(К.Л, результат_розбору_числа.значення як п16);
    } інакше якщо дані.тип == АСДТипЧислаП32 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП32);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_п32;
      llvm_value = LLVM::const_uint32(К.Л, результат_розбору_числа.значення як п32);
    } інакше якщо дані.тип == АСДТипЧислаП64 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП64);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_п64;
      llvm_value = LLVM::const_uint64(К.Л, результат_розбору_числа.значення як п64);
    } інакше якщо дані.тип == АСДТипЧислаД32 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаД32);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_д32;
      llvm_value = LLVM::const_float(К.Л, результат_розбору_числа.значення як д32);
    } інакше якщо дані.тип == АСДТипЧислаД64 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаД64);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_д64;
      llvm_value = LLVM::const_double(К.Л, результат_розбору_числа.значення як д64);
    } інакше {
      ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Невідомий тип числа");
      вернути РезультатЗначення { помилка = помилка_компіляції };
    }

    ціль обʼєкт_виконання = ОбʼєктВиконання { тип = тип, llvm_value = llvm_value, unloaded = ні };
    вернути РезультатЗначення { Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, пусто };
  }
}