взяти визначення К;

секція цк {
  місцева дія скомпілювати_значення_число(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніЗначенняЧисло>, очікуваний_тип: позитивне): РезультатЗначення {
    ціль значення = дані.значення;

    якщо дані.база != 10 {
      ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Підтримується тільки десяткова система числення");
      вернути РезультатЗначення { помилка = помилка_компіляції };
    }

    якщо очікуваний_тип == ОчікуванийТипЧислаАВТО {
      якщо дані.тип == АСДТипЧислаАВТО {
        якщо дані.дробове == так {
          очікуваний_тип = АСДТипЧислаД64;
        } інакше {
          очікуваний_тип = АСДТипЧислаЦ64;
        }
      } інакше {
        очікуваний_тип = дані.тип;
      }
    } інакше {
      якщо дані.тип == АСДТипЧислаАВТО {
        // ок
      } інакше {
        якщо дані.тип != очікуваний_тип {
          ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Невідповідні типи");
          вернути РезультатЗначення { помилка = помилка_компіляції };
        }
      }
    }

    змінна тип: Тип;
    змінна llvm_value: комірка<LLVM::Value>;

    якщо очікуваний_тип == АСДТипЧислаЦ8 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаЦ8);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_ц8;
      llvm_value = LLVM::const_int8(К.Л, результат_розбору_числа.значення як ц8);
    } інакше якщо очікуваний_тип == АСДТипЧислаЦ16 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаЦ16);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_ц16;
      llvm_value = LLVM::const_int16(К.Л, результат_розбору_числа.значення як ц16);
    } інакше якщо очікуваний_тип == АСДТипЧислаЦ32 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаЦ32);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_ц32;
      llvm_value = LLVM::const_int32(К.Л, результат_розбору_числа.значення як ц32);
    } інакше якщо очікуваний_тип == АСДТипЧислаЦ64 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаЦ64);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_ц64;
      llvm_value = LLVM::const_int64(К.Л, результат_розбору_числа.значення як ц64);
    } інакше якщо очікуваний_тип == АСДТипЧислаП8 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП8);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_п8;
      llvm_value = LLVM::const_uint8(К.Л, результат_розбору_числа.значення як п8);
    } інакше якщо очікуваний_тип == АСДТипЧислаП16 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП16);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_п16;
      llvm_value = LLVM::const_uint16(К.Л, результат_розбору_числа.значення як п16);
    } інакше якщо очікуваний_тип == АСДТипЧислаП32 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП32);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_п32;
      llvm_value = LLVM::const_uint32(К.Л, результат_розбору_числа.значення як п32);
    } інакше якщо очікуваний_тип == АСДТипЧислаП64 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаП64);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_п64;
      llvm_value = LLVM::const_uint64(К.Л, результат_розбору_числа.значення як п64);
    } інакше якщо очікуваний_тип == АСДТипЧислаД32 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаД32);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_д32;
      llvm_value = LLVM::const_float(К.Л, результат_розбору_числа.значення як д32);
    } інакше якщо очікуваний_тип == АСДТипЧислаД64 {
      ціль результат_розбору_числа = різне::числа::розібрати_число_з_ю8сі(дані.значення, різне::числа::ТипЧислаД64);
      якщо результат_розбору_числа.помилка != пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, результат_розбору_числа.помилка);
        вернути РезультатЗначення { помилка = помилка_компіляції };
      }
      тип = К.тип_д64;
      llvm_value = LLVM::const_double(К.Л, результат_розбору_числа.значення як д64);
    } інакше {
      ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Невідомий тип числа");
      вернути РезультатЗначення { помилка = помилка_компіляції };
    }

    ціль обʼєкт_виконання = ОбʼєктВиконання { тип = тип, llvm_value = llvm_value, unloaded = ні };
    вернути РезультатЗначення { Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, пусто };
  }
}