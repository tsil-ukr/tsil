взяти визначення К;

секція цк {
  місцева дія скомпілювати_створити_ціль(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСтворитиЦіль>): комірка<ПомилкаКомпіляції> {
    ціль назва = дані.ідентифікатор.значення;

    ціль ц = виділити<Ціль>();

    якщо дані.тип == пусто {
      якщо дані.значення == пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Не вказано тип цілі");
        вернути помилка_компіляції;
      } інакше {
        ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.значення, так);
        якщо результат_компіляції_значення.помилка != пусто {
          вернути результат_компіляції_значення.помилка;
        }
        ціль тип = результат_компіляції_значення.в.тип;
        якщо тип.вид == ВидТипуНативний {
          якщо перевірити_тип(К, тип, К.тип_ніщо) == так {
            ціль помилка_компіляції = створити_помилку_компіляції(дані.значення.місцезнаходження, ю8"Тип не визначено");
            вернути помилка_компіляції;
          }
        }
        ц.тип = тип;
        ц.л_значення_alloca = LLVM::alloca(К.Л, блок.alloca_block, назва, отримати_ЛТип(К, тип));

        LLVM::store(К.Л, блок.block, результат_компіляції_значення.в.л_значення, ц.л_значення_alloca);
      }
    } інакше {
      ціль результат_компіляції_як_типу = скомпілювати_значення_як_тип(К, блок, середовище, дані.тип);
      якщо результат_компіляції_як_типу.помилка != пусто {
        вернути результат_компіляції_як_типу.помилка;
      }
      ціль тип = результат_компіляції_як_типу.тип;
      ц.тип = тип;
      ц.л_значення_alloca = LLVM::alloca(К.Л, блок.alloca_block, назва, отримати_ЛТип(К, тип));

      якщо дані.значення != пусто {
        ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.значення, так);
        якщо результат_компіляції_значення.помилка != пусто {
          вернути результат_компіляції_значення.помилка;
        }
        якщо перевірити_тип(К, результат_компіляції_значення.в.тип, тип) == ні {
          ціль помилка_компіляції = створити_помилку_компіляції(дані.значення.місцезнаходження, ю8"Невідповідні типи");
          вернути помилка_компіляції;
        }
        LLVM::store(К.Л, блок.block, результат_компіляції_значення.в.л_значення, ц.л_значення_alloca);
      }
    }

    ціль обʼєкт_компіляції = ОбʼєктКомпіляції { ВидОКЦіль, ц };

    змінити_в_середовищі(середовище, назва, обʼєкт_компіляції);

    вернути пусто;
  }
}