взяти визначення К;

секція ц {
  місцева дія скомпілювати_створити_ціль_в_тілі_дії(К: комірка<Компілятор>, л_блок_алокацій: комірка<ЛБлок>, л_блок: комірка<ЛБлок>, вихідний_л_блок: комірка<ЛБлок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСтворитиЦіль>): РезультатКомпіляціїСтворитиЦільВТіліДії {
    ціль назва = дані.ідентифікатор.значення;

    ціль обʼєкт_цілі = виділити<ОбʼєктЦілі>();
    обʼєкт_цілі.назва = назва;

    якщо дані.тип == пусто {
      якщо дані.значення == пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вказано тип цілі");
        вернути РезультатКомпіляціїСтворитиЦільВТіліДії { помилка_компіляції };
      } інакше {
        ціль результат_компіляції_значення_як_значення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.значення, так);
        якщо результат_компіляції_значення_як_значення.помилка != пусто {
          вернути РезультатКомпіляціїСтворитиЦільВТіліДії { результат_компіляції_значення_як_значення.помилка };
        }
        ціль тип = результат_компіляції_значення_як_значення.тип;
        якщо тип.вид == ВидТипуНативний {
          якщо перевірити_тип(К, тип, К.тип_ніщо) == так {
            ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Тип не визначено");
            вернути РезультатКомпіляціїСтворитиЦільВТіліДії { помилка_компіляції };
          }
        }
        обʼєкт_цілі.тип = тип;
        обʼєкт_цілі.л_значення = LLVM::alloca(К.Л, л_блок_алокацій, назва, отримати_ЛТип(К, тип));

        LLVM::store(К.Л, л_блок, результат_компіляції_значення_як_значення.л_значення, обʼєкт_цілі.л_значення);
      }
    } інакше {
      ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище, дані.тип, пусто);
      якщо результат_компіляції_як_типу.помилка != пусто {
        вернути РезультатКомпіляціїСтворитиЦільВТіліДії { результат_компіляції_як_типу.помилка };
      }
      ціль тип = результат_компіляції_як_типу.тип;
      обʼєкт_цілі.тип = тип;
      обʼєкт_цілі.л_значення = LLVM::alloca(К.Л, л_блок_алокацій, назва, отримати_ЛТип(К, тип));

      якщо дані.значення != пусто {
        ціль результат_компіляції_значення_як_значення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.значення, так);
        якщо результат_компіляції_значення_як_значення.помилка != пусто {
          вернути РезультатКомпіляціїСтворитиЦільВТіліДії { результат_компіляції_значення_як_значення.помилка };
        }
        якщо перевірити_тип(К, результат_компіляції_значення_як_значення.тип, тип) == ні {
          ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Невідповідні типи");
          вернути РезультатКомпіляціїСтворитиЦільВТіліДії { помилка_компіляції };
        }
        LLVM::store(К.Л, л_блок, результат_компіляції_значення_як_значення.л_значення, обʼєкт_цілі.л_значення);
      }
    }

    змінити_в_середовищі(середовище, назва, Субʼєкт { ВидСубʼєктаЦіль, обʼєкт_цілі });

    вернути РезультатКомпіляціїСтворитиЦільВТіліДії { пусто };
  }
}