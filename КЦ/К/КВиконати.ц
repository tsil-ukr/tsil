взяти визначення К;

секція цк {
  місцева дія скомпілювати_значення_виконати(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніВиконати>): РезультатЗначення {
    ціль результат_компіляції_обʼєкта_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.обʼєкт, так);
    якщо результат_компіляції_обʼєкта_значення.помилка != пусто {
      вернути РезультатЗначення { Значення {}, результат_компіляції_обʼєкта_значення.помилка };
    }

    ціль тип = результат_компіляції_обʼєкта_значення.в.тип;
    ціль llvm_value = результат_компіляції_обʼєкта_значення.в.llvm_value;

    якщо тип.вид != ВидТипуДія {
      ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Тип не є дією");
      вернути РезультатЗначення { Значення {}, помилка_компіляції };
    }

    ціль дані_типу_дії = тип.дані як комірка<ДаніТипуДія>;

    якщо дані_типу_дії.параметри.довжина != дані.аргументи.довжина {
      ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Невірна кількість аргументів");
      вернути РезультатЗначення { Значення {}, помилка_компіляції };
    }

    ціль llvm_value_аргументів = виділити<комірка<LLVM::Value>>(дані.аргументи.довжина);

    змінна ах: позитивне = 0;
    поки ах < дані.аргументи.довжина {
      ціль аргумент = дані.аргументи.елементи[ах];
      ціль результат_компіляції_значення_аргумента = скомпілювати_значення_як_значення(К, блок, середовище, аргумент, так);
      якщо результат_компіляції_значення_аргумента.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_значення_аргумента.помилка };
      }
      ціль тип_аргумента = результат_компіляції_значення_аргумента.в.тип;
      ціль llvm_value_аргумента = результат_компіляції_значення_аргумента.в.llvm_value;
      ціль параметр = дані_типу_дії.параметри.дані[ах];
      якщо перевірити_тип(К, тип_аргумента, параметр.тип) == ні {
        ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Невірний тип аргумента");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }
      llvm_value_аргументів[ах] = llvm_value_аргумента;
      ах = ах + 1;
    }

    ціль llvm_value_call = LLVM::call(К.Л, блок.llvm_block, отримати_llvm_type(К, тип), llvm_value, дані.аргументи.довжина, llvm_value_аргументів);

    ціль обʼєкт_виконання = ОбʼєктВиконання { дані_типу_дії.тип_результату, llvm_value_call, unloaded = ні };

    вернути РезультатЗначення { Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, пусто };
  }
}

секція ц {
  місцева дія скомпілювати_виконати(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніВиконати>): Результат {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, інформація_виконання_шаблону, середовище, дані.обʼєкт, пусто);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути Результат { помилка = результат_компіляції_значення.помилка };
    }
    змінна параметри: комірка<список<ПараметрДії>> = пусто;
    змінна тип_результату: комірка<ОбʼєктТипу> = пусто;
    змінна llvm_function_type: комірка<LLVM::FunctionType> = пусто;
    змінна llvm_value: комірка<LLVM::Value> = пусто;
    ціль обʼєкт = результат_компіляції_значення.обʼєкт;
    якщо обʼєкт.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = обʼєкт.дані як комірка<ОбʼєктДії>;
      параметри = обʼєкт_дії.параметри;
      тип_результату = обʼєкт_дії.тип_результату;
      llvm_function_type = LLVM::type_of_function(К.L, обʼєкт_дії.llvm_function);
      llvm_value = обʼєкт_дії.llvm_function як комірка<LLVM::Value>;
    } інакше {
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Обʼєкт не є дією");
      вернути Результат { помилка = помилка_компіляції };
    }
    якщо дані.аргументи.довжина != параметри.довжина {
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Невірна кількість аргументів");
      вернути Результат { помилка = помилка_компіляції };
    }
    ціль args_llvm_values = виділити<комірка<LLVM::Value>>(параметри.довжина);
    змінна ах: позитивне = 0;
    поки ах < параметри.довжина {
      ціль параметр = параметри.дані[ах];
      ціль аргумент = дані.аргументи.елементи[ах];
      ціль результат_компіляції_значення_аргумента = скомпілювати_значення_як_значення(К, блок, пусто, середовище, аргумент, параметр.тип);
      якщо результат_компіляції_значення_аргумента.помилка != пусто {
        вернути Результат { помилка = результат_компіляції_значення_аргумента.помилка };
      }
      ціль обʼєкт_значення_аргумента = результат_компіляції_значення_аргумента.обʼєкт_значення;
      якщо перевірити_тип(К, обʼєкт_значення_аргумента.тип, параметр.тип) == ні {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8"Невірний тип аргумента");
        вернути Результат { помилка = помилка_компіляції };
      }
      args_llvm_values[ах] = обʼєкт_значення_аргумента.llvm_value;
      ах = ах + 1;
    }
    ціль llvm_value_call = LLVM::call(К.L, блок.llvm_block, llvm_function_type як комірка<LLVM::Type>, llvm_value, параметри.довжина, args_llvm_values);
//    звільнити(args_llvm_values);
    ціль обʼєкт_значення_виконання = виділити<ОбʼєктЗначення>();
    обʼєкт_значення_виконання.тип = тип_результату;
    обʼєкт_значення_виконання.llvm_value = llvm_value_call;
    вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_виконання }, помилка = пусто };
  }
}