взяти визначення К;

секція ц {
  місцева дія скомпілювати_виконати(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніВиконати>): Результат {
    ціль результат_компіляції_значення = скомпілювати_значення(К, інформація_середовища, дані.обʼєкт, пусто);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути Результат { помилка = результат_компіляції_значення.помилка };
    }
    ціль скомпільовані_типи_аргументів = виділити_список<комірка<ОбʼєктТипу>>();
    ціль args_llvm_values = виділити<комірка<LLVM::Value>>(дані.аргументи.довжина);
    змінна параметри: комірка<список<ПараметрДії>> = пусто;
    змінна тип_результату: комірка<ОбʼєктТипу> = пусто;
    змінна llvm_function_type: комірка<LLVM::FunctionType> = пусто;
    змінна llvm_value: комірка<LLVM::Value> = пусто;
    ціль обʼєкт = результат_компіляції_значення.обʼєкт;
    якщо обʼєкт.вид == ВидОбʼєктаДії {
      ціль обʼєкт_дії = обʼєкт.дані як комірка<ОбʼєктДії>;
      параметри = обʼєкт_дії.параметри;
      тип_результату = обʼєкт_дії.тип_результату;
      llvm_function_type = LLVM::type_of_function(К.L, обʼєкт_дії.llvm_function);
      llvm_value = обʼєкт_дії.llvm_function як комірка<LLVM::Value>;
    } інакше якщо обʼєкт.вид == ВидОбʼєктаГрупиДій {
      ціль обʼєкт_групи_дій = обʼєкт.дані як ОбʼєктГрупиДій;
      змінна ах: позитивне = 0;
      поки ах < дані.аргументи.довжина {
        ціль аргумент = дані.аргументи.елементи[ах];
        ціль результат_компіляції_значення_аргумента = скомпілювати_значення_як_значення(К, інформація_середовища, аргумент, пусто);
        якщо результат_компіляції_значення_аргумента.помилка != пусто {
          вернути Результат { помилка = результат_компіляції_значення_аргумента.помилка };
        }
        ціль обʼєкт_значення_аргумента = результат_компіляції_значення_аргумента.обʼєкт_значення;
        додати_до_списку<комірка<ОбʼєктТипу>>(скомпільовані_типи_аргументів, обʼєкт_значення_аргумента.тип);
        args_llvm_values[ах] = обʼєкт_значення_аргумента.llvm_value;
        ах = ах + 1;
      }
      змінна знайдений_обʼєкт_дії: комірка<ОбʼєктДії> = пусто;
      змінна дх: позитивне = 0;
      поки дх < обʼєкт_групи_дій.обʼєкти_дій.довжина {
        ціль обʼєкт_дії = обʼєкт_групи_дій.обʼєкти_дій.дані[дх];
        якщо обʼєкт_дії.параметри.довжина == дані.аргументи.довжина {
          змінна пх: позитивне = 0;
          змінна кількість_норм_аргументів: позитивне = 0;
          поки пх < обʼєкт_дії.параметри.довжина {
            якщо перевірити_тип(обʼєкт_дії.параметри.дані[пх].тип, скомпільовані_типи_аргументів.дані[пх]) == так {
              кількість_норм_аргументів = кількість_норм_аргументів + 1;
            }
            пх = пх + 1;
          }
          якщо кількість_норм_аргументів == обʼєкт_дії.параметри.довжина {
            знайдений_обʼєкт_дії = обʼєкт_дії;
          }
        }
        дх = дх + 1;
      }
      якщо знайдений_обʼєкт_дії == пусто {
        ціль помилка_компіляції = виділити_помилку_компіляції_не_вдалось_знайти_відповідну_дію(місцезнаходження);
        вернути Результат { помилка = помилка_компіляції };
      }
      параметри = знайдений_обʼєкт_дії.параметри;
      тип_результату = знайдений_обʼєкт_дії.тип_результату;
      llvm_function_type = LLVM::type_of_function(К.L, знайдений_обʼєкт_дії.llvm_function);
      llvm_value = знайдений_обʼєкт_дії.llvm_function як комірка<LLVM::Value>;
    } інакше {
      ціль помилка_компіляції = виділити_помилку_компіляції_неможливо_виконати(місцезнаходження, обʼєкт);
      вернути Результат { помилка = помилка_компіляції };
    }
    якщо дані.аргументи.довжина != параметри.довжина {
      ціль помилка_компіляції = виділити_помилку_компіляції_невірна_кількість_аргументів(місцезнаходження, параметри.довжина, дані.аргументи.довжина);
      вернути Результат { помилка = помилка_компіляції };
    }
    якщо скомпільовані_типи_аргументів.довжина == 0 {
      змінна ах: позитивне = 0;
      поки ах < параметри.довжина {
        ціль параметр = параметри.дані[ах];
        ціль аргумент = дані.аргументи.елементи[ах];
        ціль результат_компіляції_значення_аргумента = скомпілювати_значення_як_значення(К, інформація_середовища, аргумент, параметр.тип);
        якщо результат_компіляції_значення_аргумента.помилка != пусто {
          вернути Результат { помилка = результат_компіляції_значення_аргумента.помилка };
        }
        ціль обʼєкт_значення_аргумента = результат_компіляції_значення_аргумента.обʼєкт_значення;
        якщо перевірити_тип(обʼєкт_значення_аргумента.тип, параметр.тип) == ні {
          ціль помилка_компіляції = виділити_помилку_компіляції_невірний_тип_аргумента(місцезнаходження, параметр.назва, параметр.тип, обʼєкт_значення_аргумента.тип);
          вернути Результат { помилка = помилка_компіляції };
        }
        додати_до_списку<комірка<ОбʼєктТипу>>(скомпільовані_типи_аргументів, обʼєкт_значення_аргумента.тип);
        args_llvm_values[ах] = обʼєкт_значення_аргумента.llvm_value;
        ах = ах + 1;
      }
    }
    ціль llvm_value_call = LLVM::call(К.L, інформація_середовища.llvm_block, llvm_function_type як комірка<LLVM::Type>, llvm_value, параметри.довжина, args_llvm_values);
    звільнити(args_llvm_values);
    ціль обʼєкт_значення_виконання = ОбʼєктЗначення {};
    обʼєкт_значення_виконання.тип = тип_результату;
    обʼєкт_значення_виконання.llvm_value = llvm_value_call;
    вернути Результат { Обʼєкт { ВидОбʼєктаЗначення, дані = обʼєкт_значення_виконання }, помилка = пусто };
  }
}