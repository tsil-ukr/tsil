взяти визначення К;

секція ц {
  місцева дія скомпілювати_отримати(К: комірка<Компілятор>, л_блок: комірка<ЛБлок>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніОтримати>, load: логічне): РезультатКомпіляціїОтримати {
    ціль результат_компіляції_обʼєкта_як_значення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.обʼєкт, ні);
    якщо результат_компіляції_обʼєкта_як_значення.помилка != пусто {
      вернути РезультатКомпіляціїОтримати { Тип {}, пусто, результат_компіляції_обʼєкта_як_значення.помилка };
    }
    змінна л_значення = результат_компіляції_обʼєкта_як_значення.л_значення;
    змінна тип = результат_компіляції_обʼєкта_як_значення.тип;
    змінна обʼєкт_структури: комірка<ОбʼєктСтруктури> = пусто;
    якщо тип.вид == ВидТипуСтруктура {
      обʼєкт_структури = тип.дані як комірка<ОбʼєктСтруктури>;
    } інакше якщо тип.вид == ВидТипуКомірка {
      ціль обʼєкт_типу_комірка = тип.дані як комірка<ОбʼєктТипуКомірка>;
      тип = обʼєкт_типу_комірка.тип_елемента;
      якщо тип.вид == ВидТипуСтруктура {
        обʼєкт_структури = тип.дані як комірка<ОбʼєктСтруктури>;
        л_значення = LLVM::load(К.Л, л_блок, LLVM::pointer(К.Л), л_значення);
      } інакше {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Тип не є структурою");
        вернути РезультатКомпіляціїОтримати { Тип {}, пусто, помилка_компіляції };
      }
    } інакше {
      ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Тип не є структурою");
      вернути РезультатКомпіляціїОтримати { Тип {}, пусто, помилка_компіляції };
    }
    ціль назва = дані.ідентифікатор.значення;
    змінна параметр: комірка<Параметр> = пусто;
    змінна позиція_параметра: позитивне = 0;
    змінна пх: позитивне = 0;
    поки пх < обʼєкт_структури.параметри.довжина {
      якщо strcmp(обʼєкт_структури.параметри.дані[пх].назва, назва) == 0 {
        параметр = обʼєкт_структури.параметри.дані[пх];
        позиція_параметра = пх;
      }
      пх = пх + 1;
    }
    якщо параметр == пусто {
      ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Параметр не знайдено");
      вернути РезультатКомпіляціїОтримати { Тип {}, пусто, помилка_компіляції };
    }
    ціль позиції_gep = виділити_список<комірка<ЛЗначення>>();
    // відкласти звільнити_список<комірка<ЛЗначення>>(позиції_gep);
    додати_до_списку<комірка<ЛЗначення>>(позиції_gep, LLVM::const_int32(К.Л, 0));
    додати_до_списку<комірка<ЛЗначення>>(позиції_gep, LLVM::const_int32(К.Л, позиція_параметра));
    ціль л_значення_gep = LLVM::getelementptr(К.Л, л_блок, отримати_ЛТип(К, тип), л_значення, позиції_gep.довжина, позиції_gep.дані);

    якщо load == так {
      ціль л_значення = LLVM::load(К.Л, л_блок, отримати_ЛТип(К, параметр.тип), л_значення_gep);
      вернути РезультатКомпіляціїОтримати { параметр.тип, л_значення, пусто };
    } інакше {
      вернути РезультатКомпіляціїОтримати { параметр.тип, л_значення_gep, пусто };
    }
  }
}