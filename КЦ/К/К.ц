взяти визначення К;

секція ц {
  місцева дія скомпілювати_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, очікуваний_тип: комірка<ОбʼєктТипу>, завантажити: логічне): Результат {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      вернути скомпілювати_звернутись(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані, завантажити);
    } інакше якщо асд_значення.вид == АСДВидЗначенняЧисло {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняЧисло>;
      вернути скомпілювати_число(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані, очікуваний_тип);
    } інакше якщо асд_значення.вид == АСДВидЗначенняОбʼєкт {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняОбʼєкт>;
      вернути скомпілювати_обʼєкт(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані, завантажити);
    } інакше якщо асд_значення.вид == АСДВидЗначенняБезтиповийОбʼєкт {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняБезтиповийОбʼєкт>;
      вернути скомпілювати_безтиповий_обʼєкт(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані, очікуваний_тип, завантажити);
    } інакше якщо асд_значення.вид == АСДВидОперація {
      ціль дані = асд_значення.дані як комірка<АСДДаніОперація>;
      вернути скомпілювати_операцію(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      вернути скомпілювати_виконати(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      вернути скомпілювати_отримати(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані, завантажити);
    }

    ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати значення");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЯкТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, інформація_виконання_шаблону, середовище, асд_значення, пусто, так);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЯкТип { помилка = результат_компіляції_значення.помилка };
    }
    якщо результат_компіляції_значення.обʼєкт.вид != ВидОбʼєктаТипу {
      ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Значення не є типом");
      вернути РезультатЯкТип { помилка = помилка_компіляції };
    }
    ціль обʼєкт = результат_компіляції_значення.обʼєкт;
    вернути РезультатЯкТип { обʼєкт_типу = обʼєкт.дані як комірка<ОбʼєктТипу>, помилка = пусто };
  }

  місцева дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, очікуваний_тип: комірка<ОбʼєктТипу>): РезультатЯкЗначення {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, інформація_виконання_шаблону, середовище, асд_значення, очікуваний_тип, так);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЯкЗначення { помилка = результат_компіляції_значення.помилка };
    }
    якщо результат_компіляції_значення.обʼєкт.вид != ВидОбʼєктаЗначення {
      ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Значення не є значенням");
      вернути РезультатЯкЗначення { помилка = помилка_компіляції };
    }
    ціль обʼєкт = результат_компіляції_значення.обʼєкт;
    вернути РезультатЯкЗначення { обʼєкт_значення = обʼєкт.дані як ОбʼєктЗначення, помилка = пусто };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, дія_: комірка<ОбʼєктДії>, блок: комірка<Блок>, середовище: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
      якщо асд_значення.вид == АСДВидЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніЦіль>;
        ціль помилка_компіляції = скомпілювати_визначити_ціль(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
        ціль помилка_компіляції = скомпілювати_змінити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль результат_компіляції_виконання = скомпілювати_значення_як_значення(К, блок, пусто, середовище, асд_значення, пусто);
        якщо результат_компіляції_виконання.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_виконання.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль помилка_компіляції = скомпілювати_перевизначити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидПоки {
        ціль дані = асд_значення.дані як комірка<АСДДаніПоки>;
        ціль помилка_компіляції = скомпілювати_поки(К, дія_, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      }
      х = х + 1;
    }
    LLVM::br(К.L, блок.llvm_block, блок.llvm_exit_block);
    вернути РезультатКомпіляціїБлоку { пусто };
  }

  місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
      якщо асд_значення.вид == АСДВидДія {
        ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
        ціль помилка_компіляції = скомпілювати_визначити_дію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСтруктура {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
        ціль помилка_компіляції = скомпілювати_визначити_структуру(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидШаблон {
        ціль дані = асд_значення.дані як комірка<АСДДаніШаблон>;
        ціль помилка_компіляції = скомпілювати_визначити_шаблон(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСинонім {
        ціль дані = асд_значення.дані як комірка<АСДДаніСинонім>;
        ціль помилка_компіляції = скомпілювати_визначити_синонім(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСекція {
        ціль дані = асд_значення.дані як комірка<АСДДаніСекція>;
        ціль помилка_компіляції = скомпілювати_визначити_секцію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      }
      х = х + 1;
    }
    вернути РезультатКомпіляціїТілаСекції { помилка = пусто };
  }
}