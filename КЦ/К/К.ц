взяти визначення К;

секція ц {
  місцева дія скомпілювати_створити_структуру(К: комірка<Компілятор>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСтворитиСтруктуру>, обʼєкт_шаблону: комірка<ОбʼєктШаблону>): РезультатКомпіляціїЗначенняЯкТипу {
    ціль назва = дані.ідентифікатор.значення;

    змінна обʼєкт_структури: комірка<ОбʼєктСтруктури> = пусто;

    ціль результат_отримання_з_середовища = отримати_з_локального_середовища(середовище, назва);
    якщо результат_отримання_з_середовища.знайдено == так {
      ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
      якщо субʼєкт.вид == ВидСубʼєктаСтруктура {
        обʼєкт_структури = субʼєкт.дані як комірка<ОбʼєктСтруктури>;
        якщо обʼєкт_структури.параметри.довжина != 0 {
          ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Структура вже визначена");
          вернути РезультатКомпіляціїЗначенняЯкТипу { Тип {}, помилка_компіляції };
        }
      } інакше {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт вже визначено");
        вернути РезультатКомпіляціїЗначенняЯкТипу { Тип {}, помилка_компіляції };
      }
    } інакше {
      обʼєкт_структури = виділити<ОбʼєктСтруктури>();
      обʼєкт_структури.назва = назва;
      обʼєкт_структури.параметри = виділити_список<комірка<Параметр>>();
      обʼєкт_структури.л_тип = LLVM::struct(К.Л, назва);

      змінити_в_середовищі(середовище, назва, Субʼєкт { ВидСубʼєктаСтруктура, обʼєкт_структури });
    }

    якщо дані.кількість_параметрів != 0 {
      ціль список_лтипів_параметрів = виділити_список<комірка<ЛТип>>();
      // відкласти звільнити_список<комірка<ЛТип>>(список_лтипів_параметрів);

      змінна пх: позитивне = 0;
      поки пх < дані.кількість_параметрів {
        ціль асд_параметр = дані.параметри[пх];
        ціль параметр = виділити<Параметр>();
        параметр.назва = асд_параметр.ідентифікатор.значення;
        ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище, асд_параметр.тип, пусто);
        якщо результат_компіляції_як_типу.помилка != пусто {
          вернути РезультатКомпіляціїЗначенняЯкТипу { Тип {}, результат_компіляції_як_типу.помилка };
        }
        параметр.тип = результат_компіляції_як_типу.тип;
        додати_до_списку<комірка<Параметр>>(обʼєкт_структури.параметри, параметр);
        додати_до_списку<комірка<ЛТип>>(список_лтипів_параметрів, отримати_ЛТип(К, результат_компіляції_як_типу.тип));
        пх = пх + 1;
      }

      LLVM::struct_set_fields(К.Л, обʼєкт_структури.л_тип, список_лтипів_параметрів.довжина, список_лтипів_параметрів.дані);
    }

    вернути РезультатКомпіляціїЗначенняЯкТипу { Тип { ВидТипуСтруктура, обʼєкт_структури }, пусто };
  }

  місцева дія скомпілювати_асд_значення_як_значення(К: комірка<Компілятор>, л_блок: комірка<ЛБлок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, load: логічне): РезультатКомпіляціїЗначенняЯкЗначення {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      ціль результат_компіляції_звернутись = скомпілювати_звернутись(К, л_блок, середовище, асд_значення.місцезнаходження, дані, load);
      вернути РезультатКомпіляціїЗначенняЯкЗначення { результат_компіляції_звернутись.тип, результат_компіляції_звернутись.л_значення, результат_компіляції_звернутись.помилка };
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      ціль результат_компіляції_отримати = скомпілювати_отримати(К, л_блок, середовище, асд_значення.місцезнаходження, дані, load);
      вернути РезультатКомпіляціїЗначенняЯкЗначення { результат_компіляції_отримати.тип, результат_компіляції_отримати.л_значення, результат_компіляції_отримати.помилка };
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      ціль результат_компіляції_виконати = скомпілювати_виконати(К, л_блок, середовище, асд_значення.місцезнаходження, дані);
      вернути РезультатКомпіляціїЗначенняЯкЗначення { результат_компіляції_виконати.тип, результат_компіляції_виконати.л_значення, результат_компіляції_виконати.помилка };
    } інакше якщо асд_значення.вид == АСДВидОперація {
      ціль дані = асд_значення.дані як комірка<АСДДаніОперація>;
      ціль результат_компіляції_операції = скомпілювати_операцію(К, л_блок, середовище, асд_значення.місцезнаходження, дані);
      вернути РезультатКомпіляціїЗначенняЯкЗначення { результат_компіляції_операції.тип, результат_компіляції_операції.л_значення, результат_компіляції_операції.помилка };
    }
    ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати значення як значення");
    вернути РезультатКомпіляціїЗначенняЯкЗначення { Тип {}, пусто, помилка_компіляції };
  }

  місцева дія скомпілювати_асд_значення_як_тип(К: комірка<Компілятор>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, обʼєкт_шаблону: комірка<ОбʼєктШаблону>): РезультатКомпіляціїЗначенняЯкТипу {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      ціль результат_отримання_з_середовища = отримати_з_середовища(середовище, дані.ідентифікатор.значення);
      якщо результат_отримання_з_середовища.знайдено == ні {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт не визначено");
        вернути РезультатКомпіляціїЗначенняЯкТипу { Тип {}, помилка_компіляції };
      } інакше {
        ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
        якщо субʼєкт.вид == ВидСубʼєктаНативнийТип {
          ціль обʼєкт_нативного_типу = субʼєкт.дані як комірка<ОбʼєктНативногоТипу>;
          вернути РезультатКомпіляціїЗначенняЯкТипу { Тип { ВидТипуНативний, обʼєкт_нативного_типу }, пусто };
        } інакше якщо субʼєкт.вид == ВидСубʼєктаСтруктура {
          ціль обʼєкт_структури = субʼєкт.дані як комірка<ОбʼєктСтруктури>;
          вернути РезультатКомпіляціїЗначенняЯкТипу { Тип { ВидТипуСтруктура, обʼєкт_структури }, пусто };
        } інакше якщо субʼєкт.вид == ВидСубʼєктаШаблон {
          ціль обʼєкт_шаблону = субʼєкт.дані як комірка<ОбʼєктШаблону>;
          вернути РезультатКомпіляціїЗначенняЯкТипу { Тип { ВидТипуШаблон, обʼєкт_шаблону }, пусто };
        }
      }
    } інакше якщо асд_значення.вид == АСДВидВиконатиШаблон {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконатиШаблон>;
      ціль результат_компіляції_виконати_шаблон = скомпілювати_виконати_шаблон(К, середовище, асд_значення.місцезнаходження, дані);
      якщо результат_компіляції_виконати_шаблон.помилка != пусто {
        вернути РезультатКомпіляціїЗначенняЯкТипу { Тип {}, результат_компіляції_виконати_шаблон.помилка };
      }
      вернути РезультатКомпіляціїЗначенняЯкТипу { результат_компіляції_виконати_шаблон.тип, пусто };
    } інакше якщо асд_значення.вид == АСДВидСтворитиСтруктуру {
      ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСтруктуру>;
      ціль середовище_структури = створити_середовище(середовище);
      ціль результат_компіляції_створити_структуру = скомпілювати_створити_структуру(К, середовище_структури, асд_значення.місцезнаходження, дані, обʼєкт_шаблону);
      якщо результат_компіляції_створити_структуру.помилка != пусто {
        вернути РезультатКомпіляціїЗначенняЯкТипу { Тип {}, результат_компіляції_створити_структуру.помилка };
      }
      вернути РезультатКомпіляціїЗначенняЯкТипу { результат_компіляції_створити_структуру.тип, пусто };
    }
    ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати значення як тип");
    вернути РезультатКомпіляціїЗначенняЯкТипу { Тип {}, помилка_компіляції };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, обʼєкт_дії: комірка<ОбʼєктДії>, середовище: комірка<Середовище>, л_значення_повернення: комірка<ЛЗначення>, л_блок_алокацій: комірка<ЛБлок>, л_блок: комірка<ЛБлок>, вихідний_л_блок: комірка<ЛБлок>, л_блок_виходу_з_функції: комірка<ЛБлок>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаДії {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
      якщо асд_значення.вид == АСДВидСтворитиЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиЦіль>;
        ціль результат_компіляції_створити_ціль_в_тілі_дії = скомпілювати_створити_ціль_в_тілі_дії(К, л_блок_алокацій, л_блок, вихідний_л_блок, середовище, асд_значення.місцезнаходження, дані);
        якщо результат_компіляції_створити_ціль_в_тілі_дії.помилка != пусто {
          вернути РезультатКомпіляціїТілаДії { результат_компіляції_створити_ціль_в_тілі_дії.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль результат_компіляції_перевизначити = скомпілювати_перевизначити(К, л_блок, середовище, асд_значення.місцезнаходження, дані);
        якщо результат_компіляції_перевизначити.помилка != пусто {
          вернути РезультатКомпіляціїТілаДії { результат_компіляції_перевизначити.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
        ціль результат_компіляції_змінити = скомпілювати_змінити(К, л_блок, середовище, асд_значення.місцезнаходження, дані);
        якщо результат_компіляції_змінити.помилка != пусто {
          вернути РезультатКомпіляціїТілаДії { результат_компіляції_змінити.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидОтримати {
        ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
        ціль результат_компіляції_отримати = скомпілювати_отримати(К, л_блок, середовище, асд_значення.місцезнаходження, дані, так);
        якщо результат_компіляції_отримати.помилка != пусто {
          вернути РезультатКомпіляціїТілаДії { результат_компіляції_отримати.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
        ціль результат_компіляції_виконати = скомпілювати_виконати(К, л_блок, середовище, асд_значення.місцезнаходження, дані);
        якщо результат_компіляції_виконати.помилка != пусто {
          вернути РезультатКомпіляціїТілаДії { результат_компіляції_виконати.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидВернути {
        ціль дані = асд_значення.дані як комірка<АСДДаніВернути>;
        якщо л_значення_повернення == пусто {
          якщо дані.значення == пусто {
            LLVM::br(К.Л, л_блок, л_блок_виходу_з_функції);
          } інакше {
            ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати значення повернення");
            вернути РезультатКомпіляціїТілаДії { помилка_компіляції };
          }
        } інакше {
          ціль результат_компіляції_значення_повернення = скомпілювати_асд_значення_як_значення(К, л_блок, середовище, дані.значення, так);
          якщо результат_компіляції_значення_повернення.помилка != пусто {
            вернути РезультатКомпіляціїТілаДії { результат_компіляції_значення_повернення.помилка };
          }
          якщо перевірити_тип(К, результат_компіляції_значення_повернення.тип, обʼєкт_дії.тип_результату) == ні {
            ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Тип значення повернення не співпадає");
            вернути РезультатКомпіляціїТілаДії { помилка_компіляції };
          }
          LLVM::store(К.Л, л_блок, результат_компіляції_значення_повернення.л_значення, л_значення_повернення);
          LLVM::br(К.Л, л_блок, л_блок_виходу_з_функції);
        }
      } інакше {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати тіло дії");
        вернути РезультатКомпіляціїТілаДії { помилка_компіляції };
      }
      х = х + 1;
    }
    LLVM::br(К.Л, л_блок, вихідний_л_блок);
    вернути РезультатКомпіляціїТілаДії { пусто };
  }

  місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
//      біб::вивести_позитивне(х);
//      біб::вивести_ю8(ю8" ");
//      біб::друк_позитивне(асд_значення.вид);
      якщо асд_значення.вид == АСДВидСтворитиДію {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиДію>;

        ціль назва = дані.ідентифікатор.значення;

        змінна обʼєкт_дії: комірка<ОбʼєктДії> = пусто;

        ціль результат_отримання_з_середовища = отримати_з_локального_середовища(середовище_секції, назва);
        якщо результат_отримання_з_середовища.знайдено == так {
          ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
          якщо субʼєкт.вид == ВидСубʼєктаДія {
            обʼєкт_дії = субʼєкт.дані як комірка<ОбʼєктДії>;

            якщо обʼєкт_дії.параметри.довжина != дані.кількість_параметрів {
              ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Кількість параметрів не співпадає");
              вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
            }

            змінна пх: позитивне = 0;
            поки пх < дані.кількість_параметрів {
              ціль асд_параметр = дані.параметри[пх];
              ціль параметр = виділити<Параметр>();
              параметр.назва = асд_параметр.ідентифікатор.значення;
              ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище_секції, асд_параметр.тип, пусто);
              якщо результат_компіляції_як_типу.помилка != пусто {
                вернути РезультатКомпіляціїТілаСекції { результат_компіляції_як_типу.помилка };
              }
              параметр.тип = результат_компіляції_як_типу.тип;
              ціль попередній_параметр = обʼєкт_дії.параметри.дані[пх];
              якщо strcmp(параметр.назва, попередній_параметр.назва) != 0 {
                ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Назва параметра не співпадає");
                вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
              }
              якщо перевірити_тип(К, параметр.тип, попередній_параметр.тип) == ні {
                ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Тип параметра не співпадає");
                вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
              }
              пх = пх + 1;
            }

            змінна тип_результату: Тип;

            якщо дані.тип_результату == пусто {
              тип_результату = К.тип_ніщо;
            } інакше {
              ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище_секції, дані.тип_результату, пусто);
              якщо результат_компіляції_як_типу.помилка != пусто {
                вернути РезультатКомпіляціїТілаСекції { результат_компіляції_як_типу.помилка };
              }
              тип_результату = результат_компіляції_як_типу.тип;
            }

            якщо перевірити_тип(К, тип_результату, обʼєкт_дії.тип_результату) == ні {
              ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Тип результату не співпадає");
              вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
            }
          } інакше {
            ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт вже визначено");
            вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
          }
        } інакше {
          обʼєкт_дії = виділити<ОбʼєктДії>();
          обʼєкт_дії.назва = назва;
          обʼєкт_дії.параметри = виділити_список<комірка<Параметр>>();

          обʼєкт_дії.обʼєкт_типу_дії = виділити<ОбʼєктТипуДії>();
          обʼєкт_дії.обʼєкт_типу_дії.параметри = обʼєкт_дії.параметри;

          ціль список_лтипів_параметрів = виділити_список<комірка<ЛТип>>();
          // відкласти звільнити_список<комірка<ЛТип>>(список_лтипів_параметрів);

          змінна пх: позитивне = 0;
          поки пх < дані.кількість_параметрів {
            ціль асд_параметр = дані.параметри[пх];
            ціль параметр = виділити<Параметр>();
            параметр.назва = асд_параметр.ідентифікатор.значення;
            ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище_секції, асд_параметр.тип, пусто);
            якщо результат_компіляції_як_типу.помилка != пусто {
              вернути РезультатКомпіляціїТілаСекції { результат_компіляції_як_типу.помилка };
            }
            параметр.тип = результат_компіляції_як_типу.тип;
            додати_до_списку<комірка<Параметр>>(обʼєкт_дії.параметри, параметр);
            додати_до_списку<комірка<ЛТип>>(список_лтипів_параметрів, отримати_ЛТип(К, результат_компіляції_як_типу.тип));
            пх = пх + 1;
          }

          якщо дані.тип_результату == пусто {
            обʼєкт_дії.тип_результату = К.тип_ніщо;
          } інакше {
            ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище_секції, дані.тип_результату, пусто);
            якщо результат_компіляції_як_типу.помилка != пусто {
              вернути РезультатКомпіляціїТілаСекції { результат_компіляції_як_типу.помилка };
            }
            обʼєкт_дії.тип_результату = результат_компіляції_як_типу.тип;
          }
          обʼєкт_дії.обʼєкт_типу_дії.тип_результату = обʼєкт_дії.тип_результату;

          змінна лінкування: позитивне = 0;
          якщо дані.видимість == АСДВидимістьЗовнішня {
            лінкування = LLVM::LINKAGE_EXTERNAL;
          } інакше якщо дані.видимість == АСДВидимістьМісцева {
            лінкування = LLVM::LINKAGE_DSO_LOCAL;
          } інакше {
            лінкування = LLVM::LINKAGE_INTERNAL;
          }

          якщо strcmp(обʼєкт_дії.назва, ю8"main") == 0 {
            лінкування = LLVM::LINKAGE_EXTERNAL;
          }

          ціль лф = LLVM::function(К.Л, лінкування, обʼєкт_дії.назва, отримати_ЛТип(К, обʼєкт_дії.тип_результату), список_лтипів_параметрів.довжина, список_лтипів_параметрів.дані, ні);
          обʼєкт_дії.л_функція = лф;

          обʼєкт_дії.обʼєкт_типу_дії.л_тип_функції = LLVM::type_of_function(К.Л, лф);

          змінити_в_середовищі(середовище_секції, обʼєкт_дії.назва, Субʼєкт { ВидСубʼєктаДія, обʼєкт_дії });
        }

        якщо дані.тіло != пусто {
          ціль середовище_дії = створити_середовище(середовище_секції);

          ціль л_блок_алокацій = LLVM::створити_блок(К.Л, обʼєкт_дії.л_функція, ю8"alloca");
          ціль л_блок = LLVM::створити_блок(К.Л, обʼєкт_дії.л_функція, ю8"entry");
          ціль вихідний_л_блок = LLVM::створити_блок(К.Л, обʼєкт_дії.л_функція, ю8"exit");

          змінна л_значення_повернення: комірка<ЛЗначення> = пусто;
          якщо перевірити_тип(К, обʼєкт_дії.тип_результату, К.тип_ніщо) == ні {
            л_значення_повернення = LLVM::alloca(К.Л, л_блок_алокацій, ю8"return", отримати_ЛТип(К, обʼєкт_дії.тип_результату));
          }

          змінна пх: позитивне = 0;
          поки пх < обʼєкт_дії.параметри.довжина {
            ціль параметр = обʼєкт_дії.параметри.дані[пх];
            ціль arg = LLVM::function_arg(К.Л, обʼєкт_дії.л_функція, пх);
            ціль л_значення = LLVM::alloca(К.Л, л_блок_алокацій, параметр.назва, отримати_ЛТип(К, параметр.тип));
            LLVM::store(К.Л, л_блок_алокацій, arg, л_значення);
            ціль обʼєкт_цілі = виділити<ОбʼєктЦілі>();
            обʼєкт_цілі.назва = параметр.назва;
            обʼєкт_цілі.тип = параметр.тип;
            обʼєкт_цілі.л_значення = л_значення;
            змінити_в_середовищі(середовище_дії, параметр.назва, Субʼєкт { ВидСубʼєктаЦіль, обʼєкт_цілі });
            пх = пх + 1;
          }

          ціль результат_компіляції_тіла_дії = скомпілювати_блок(К, обʼєкт_дії, середовище_дії, л_значення_повернення, л_блок_алокацій, л_блок, вихідний_л_блок, вихідний_л_блок, дані.тіло);
          якщо результат_компіляції_тіла_дії.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { результат_компіляції_тіла_дії.помилка };
          }

          LLVM::br(К.Л, л_блок_алокацій, л_блок);
          якщо л_значення_повернення == пусто {
            LLVM::ret(К.Л, вихідний_л_блок, пусто);
          } інакше {
            ціль л_значення = LLVM::load(К.Л, вихідний_л_блок, отримати_ЛТип(К, обʼєкт_дії.тип_результату), л_значення_повернення);
            LLVM::ret(К.Л, вихідний_л_блок, л_значення);
          }
        }
      } інакше якщо асд_значення.вид == АСДВидСтворитиСтруктуру {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСтруктуру>;
        ціль результат_компіляції_створити_структуру = скомпілювати_створити_структуру(К, середовище_секції, асд_значення.місцезнаходження, дані, пусто);
        якщо результат_компіляції_створити_структуру.помилка != пусто {
          вернути РезультатКомпіляціїТілаСекції { результат_компіляції_створити_структуру.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидСтворитиШаблон {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиШаблон>;

        ціль назва = дані.ідентифікатор.значення;

        ціль обʼєкт_шаблону = виділити<ОбʼєктШаблону>();
        обʼєкт_шаблону.зовнішнє_середовище = середовище_секції;
        обʼєкт_шаблону.параметри = виділити_список<памʼять<п8>>();
        обʼєкт_шаблону.асд_значення = дані.значення;

        змінна пх: позитивне = 0;
        поки пх < дані.кількість_параметрів {
          ціль асд_ідентифікатор = дані.параметри[пх];
          додати_до_списку<памʼять<п8>>(обʼєкт_шаблону.параметри, асд_ідентифікатор.значення);
          пх = пх + 1;
        }

        змінити_в_середовищі(середовище_секції, назва, Субʼєкт { ВидСубʼєктаШаблон, обʼєкт_шаблону });
      } інакше {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати тіло секції");
        вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
      }
      х = х + 1;
    }

    вернути РезультатКомпіляціїТілаСекції { пусто };
  }
}

секція цк {
  місцева дія скомпілювати_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначення {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      ціль назва = дані.ідентифікатор.значення;
      ціль обʼєкт_компіляції_з_середовища = отримати_з_середовища(середовище, назва);
      якщо обʼєкт_компіляції_з_середовища.знайдено == ні {
        ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Субʼєкт не визначено");
        вернути РезультатЗначення { Значення {}, створити_помилку_компіляції };
      }
      вернути РезультатЗначення { Значення { ВидЗначенняОК, к = обʼєкт_компіляції_з_середовища.субʼєкт }, пусто };
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      ціль результат_компіляції_обʼєкта_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.обʼєкт, ні);
      якщо результат_компіляції_обʼєкта_значення.помилка != пусто {
        вернути РезультатЗначення { Значення{}, результат_компіляції_обʼєкта_значення.помилка };
      }
      ціль тип = результат_компіляції_обʼєкта_значення.в.тип;
      якщо тип.вид != ВидТипуСтруктура {
        ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Тип не є структурою");
        вернути РезультатЗначення { Значення{}, помилка_компіляції };
      }
      ціль дані_типу_структури = тип.дані як комірка<ДаніТипуСтруктура>;
      ціль назва_властивості = дані.ідентифікатор.значення;
      змінна параметр: Параметр;
      змінна позиція_параметра: позитивне = 0;
      змінна параметр_знайдено: логічне = ні;
      змінна пх: позитивне = 0;
      поки пх < дані_типу_структури.параметри.довжина {
        якщо strcmp(дані_типу_структури.параметри.дані[пх].назва, назва_властивості) == 0 {
          параметр = дані_типу_структури.параметри.дані[пх];
          позиція_параметра = пх;
          параметр_знайдено = так;
        }
        пх = пх + 1;
      }
      якщо параметр_знайдено == ні {
        ціль помилка_компіляції = створити_помилку_компіляції(дані.ідентифікатор.місцезнаходження, ю8"Параметр не знайдено");
        вернути РезультатЗначення { Значення{}, помилка_компіляції };
      }
      ціль позиції_gep = виділити<комірка<ЛЗначення>>(2);
      позиції_gep[0] = LLVM::const_int32(К.Л, 0);
      позиції_gep[1] = LLVM::const_int32(К.Л, позиція_параметра);

      ціль л_значення_gep = LLVM::getelementptr(К.Л, блок.block, отримати_ЛТип(К, тип), результат_компіляції_обʼєкта_значення.в.л_значення, 2, позиції_gep);

      ціль обʼєкт_виконання = ОбʼєктВиконання { параметр.тип, л_значення = л_значення_gep, unloaded = так };

      вернути РезультатЗначення { Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, пусто };
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;

      ціль результат_компіляції_обʼєкта_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.обʼєкт, так);
      якщо результат_компіляції_обʼєкта_значення.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_обʼєкта_значення.помилка };
      }

      ціль тип = результат_компіляції_обʼєкта_значення.в.тип;
      ціль л_значення = результат_компіляції_обʼєкта_значення.в.л_значення;

      якщо тип.вид != ВидТипуДія {
        ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Тип не є дією");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }

      ціль дані_типу_дії = тип.дані як комірка<ДаніТипуДія>;

      якщо дані_типу_дії.параметри.довжина != дані.аргументи.довжина {
        ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Невірна кількість аргументів");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }

      ціль л_значення_аргументів = виділити<комірка<ЛЗначення>>(дані.аргументи.довжина);

      змінна ах: позитивне = 0;
      поки ах < дані.аргументи.довжина {
        ціль аргумент = дані.аргументи.елементи[ах];
        ціль результат_компіляції_значення_аргумента = скомпілювати_значення_як_значення(К, блок, середовище, аргумент, так);
        якщо результат_компіляції_значення_аргумента.помилка != пусто {
          вернути РезультатЗначення { Значення {}, результат_компіляції_значення_аргумента.помилка };
        }
        ціль тип_аргумента = результат_компіляції_значення_аргумента.в.тип;
        ціль л_значення_аргумента = результат_компіляції_значення_аргумента.в.л_значення;
        ціль параметр = дані_типу_дії.параметри.дані[ах];
        якщо перевірити_тип(К, тип_аргумента, параметр.тип) == ні {
          ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Невірний тип аргумента");
          вернути РезультатЗначення { Значення {}, помилка_компіляції };
        }
        л_значення_аргументів[ах] = л_значення_аргумента;
        ах = ах + 1;
      }

      ціль л_значення_call = LLVM::call(К.Л, блок.block, отримати_ЛТип(К, тип), л_значення, дані.аргументи.довжина, л_значення_аргументів);

      ціль обʼєкт_виконання = ОбʼєктВиконання { дані_типу_дії.тип_результату, л_значення_call, unloaded = ні };

      вернути РезультатЗначення { Значення { ВидЗначенняОВ, в = обʼєкт_виконання }, пусто };
    } інакше якщо асд_значення.вид == АСДВидВиконатиШаблон {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконатиШаблон>;

      ціль результат_компіляції_обʼєкта = скомпілювати_значення(К, блок, пусто, середовище, дані.обʼєкт);
      якщо результат_компіляції_обʼєкта.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_обʼєкта.помилка };
      }

      ціль значення = результат_компіляції_обʼєкта.значення;

      якщо значення.вид == ВидЗначенняОВ {
        ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Обʼєкт не є шаблоном");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }

      ціль к = значення.к;
      якщо к.вид != ВидОКШаблон {
        ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Обʼєкт не є шаблоном");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }

      ціль ш = к.дані як комірка<Шаблон>;

      якщо дані.аргументи.довжина != ш.параметри.довжина {
        ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Невірна кількість аргументів шаблону");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }

      ціль інформація_шаблону = виділити<ІнформаціяШаблону>();
      інформація_шаблону.шаблон = ш;
      інформація_шаблону.аргументи = виділити_список<Значення>();

      ціль середовище_шаблону = створити_середовище(середовище);

      змінна ах: позитивне = 0;
      поки ах < дані.аргументи.довжина {
        ціль аргумент = дані.аргументи.елементи[ах];
        ціль результат_компіляції_значення_аргумента = скомпілювати_значення(К, блок, інформація_шаблону, середовище, аргумент);
        якщо результат_компіляції_значення_аргумента.помилка != пусто {
          вернути РезультатЗначення { Значення {}, результат_компіляції_значення_аргумента.помилка };
        }
        якщо результат_компіляції_значення_аргумента.значення.вид == ВидЗначенняОВ {
          ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Аргумент не є значенням");
          вернути РезультатЗначення { Значення {}, помилка_компіляції };
        }
        додати_до_списку<Значення>(інформація_шаблону.аргументи, результат_компіляції_значення_аргумента.значення);
        змінити_в_середовищі(середовище_шаблону, ш.параметри.дані[ах], результат_компіляції_значення_аргумента.значення.к);
        ах = ах + 1;
      }

      якщо перевірити_чи_карта_містить_значення<комірка<список<Значення>>, Значення>(ш.карта_готових_значень, інформація_шаблону.аргументи) == так {
        ціль значення = отримати_значення_з_карти<комірка<список<Значення>>, Значення>(ш.карта_готових_значень, інформація_шаблону.аргументи, Значення {});
        вернути РезультатЗначення { значення, пусто };
      }

      ціль результат_компіляції_значення_шаблона = скомпілювати_значення(К, блок, інформація_шаблону, середовище_шаблону, ш.асд_значення);
      якщо результат_компіляції_значення_шаблона.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_значення_шаблона.помилка };
      }

      вернути результат_компіляції_значення_шаблона;
    } інакше якщо асд_значення.вид == АСДВидСтворитиСтруктуру {
      ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСтруктуру>;
      вернути скомпілювати_створити_структуру(К, блок, інформація_шаблону, середовище, асд_значення.місцезнаходження, дані);
    }

    ціль помилка = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення");
    вернути РезультатЗначення { Значення {}, помилка };
  }

  місцева дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначенняТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняТип { Тип {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОВ {
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням типу");
      вернути РезультатЗначенняТип { Тип {}, створити_помилку_компіляції };
    }
    ціль обʼєкт_компіляції = значення.к;
    якщо обʼєкт_компіляції.вид != ВидОКТип {
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є типом");
      вернути РезультатЗначенняТип { Тип {}, створити_помилку_компіляції };
    }
    ціль комірка_типу = обʼєкт_компіляції.дані як комірка<Тип>;
    ціль тип = вміст(комірка_типу);
    вернути РезультатЗначенняТип { тип, пусто };
  }

  місцева дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, load: логічне): РезультатЗначенняЗначення {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОК {
      ціль ок = значення.к;
      якщо ок.вид == ВидОКЦіль {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль ц = ок.дані як комірка<Ціль>;
        якщо load == так {
          ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, ц.тип), ц.л_значення_alloca);
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, л_значення }, пусто };
        } інакше {
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, ц.л_значення_alloca }, пусто };
        }
      } інакше якщо ок.вид == ВидОКДія {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль д = ок.дані як комірка<Дія>;
        ціль тип = зробити_тип_з_дії(К, д);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { тип, д.л_функція як комірка<ЛЗначення> }, пусто };
      }
      біб::друк_позитивне(ок.вид);
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням");
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
    }
    якщо load == так {
      якщо значення.в.unloaded == так {
        ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, значення.в.тип), значення.в.л_значення);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { значення.в.тип, л_значення, unloaded = ні }, пусто };
      }
    }
    вернути РезультатЗначенняЗначення { значення.в, пусто };
  }

  місцева дія скомпілювати_створити_дію(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСтворитиДію>): РезультатЗначення {
    якщо інформація_шаблону != пусто {
      якщо дані.тіло == пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Тіло дії не вказано");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }
    }

    ціль назва = дані.ідентифікатор.значення;
    ціль параметри = виділити_список<Параметр>();
    ціль тип_результату = К.тип_ніщо;

    ціль л_типи_параметрів = виділити<комірка<ЛТип>>(дані.кількість_параметрів);

    змінна пх: позитивне = 0;
    поки пх < дані.кількість_параметрів {
      ціль асд_параметр = дані.параметри[пх];
      ціль параметр = Параметр {};
      параметр.назва = асд_параметр.ідентифікатор.значення;
      ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, пусто, середовище, асд_параметр.тип);
      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_типу.помилка };
      }
      параметр.тип = результат_компіляції_типу.тип;
      додати_до_списку<Параметр>(параметри, параметр);
      л_типи_параметрів[пх] = отримати_ЛТип(К, результат_компіляції_типу.тип);
      пх = пх + 1;
    }

    якщо дані.тип_результату != пусто {
      ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, пусто, середовище, дані.тип_результату);
      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_типу.помилка };
      }
      тип_результату = результат_компіляції_типу.тип;
    }

    змінна лінкування: позитивне = 0;
    якщо дані.видимість == АСДВидимістьЗовнішня {
      лінкування = LLVM::LINKAGE_EXTERNAL;
    } інакше якщо дані.видимість == АСДВидимістьМісцева {
      лінкування = LLVM::LINKAGE_DSO_LOCAL;
    } інакше {
      лінкування = LLVM::LINKAGE_INTERNAL;
    }

    якщо strcmp(назва, ю8"main") == 0 {
      лінкування = LLVM::LINKAGE_EXTERNAL;
    }

    ціль д = виділити<Дія>();
    д.назва = назва;
    д.параметри = параметри;
    д.тип_результату = тип_результату;
    д.л_функція = LLVM::function(К.Л, лінкування, назва, отримати_ЛТип(К, тип_результату), параметри.довжина, л_типи_параметрів, ні);

    ціль дтд = виділити<ДаніТипуДія>();
    дтд.л_тип_функції = LLVM::type_of_function(К.Л, д.л_функція);
    дтд.параметри = параметри;
    дтд.тип_результату = тип_результату;

    ціль дт = Тип {};
    дт.вид = ВидТипуДія;
    дт.дані = дтд;

    ціль значення = Значення {};
    значення.вид = ВидЗначенняОВ;
    значення.в = ОбʼєктВиконання { дт, д.л_функція як комірка<ЛЗначення> };

    змінити_в_середовищі(середовище, назва, ОбʼєктКомпіляції { ВидОКДія, д });

    якщо інформація_шаблону != пусто {
      // потім: обробляти шаблон
    }

    якщо дані.тіло != пусто {
      ціль середовище_дії = створити_середовище(середовище);

      ціль блок = виділити<Блок>();
      блок.ret_value = пусто;
      блок.alloca_block = LLVM::block(К.Л, д.л_функція, ю8"alloca");
      блок.block = LLVM::block(К.Л, д.л_функція, ю8"entry");
      блок.exit_block = LLVM::block(К.Л, д.л_функція, ю8"exit");
      блок.function_exit_block = блок.exit_block;

      якщо перевірити_тип(К, д.тип_результату, К.тип_ніщо) == ні {
        блок.ret_value = LLVM::alloca(К.Л, блок.alloca_block, ю8"return", отримати_ЛТип(К, д.тип_результату));
      }

      змінна пх: позитивне = 0;
      поки пх < д.параметри.довжина {
        ціль параметр = д.параметри.дані[пх];
        ціль arg = LLVM::function_arg(К.Л, д.л_функція, пх);
        ціль л_значення = LLVM::alloca(К.Л, блок.alloca_block, параметр.назва, отримати_ЛТип(К, параметр.тип));
        LLVM::store(К.Л, блок.alloca_block, arg, л_значення);
        ціль ц = виділити<Ціль>();
        ц.тип = параметр.тип;
        ц.л_значення_alloca = л_значення;
        змінити_в_середовищі(середовище_дії, параметр.назва, ОбʼєктКомпіляції { ВидОКЦіль, ц });
        пх = пх + 1;
      }

      ціль результат_компіляції_блоку = скомпілювати_блок(К, блок, середовище_дії, дані.тіло);
      якщо результат_компіляції_блоку.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_блоку.помилка };
      }

      LLVM::br(К.Л, блок.alloca_block, блок.block);
      якщо блок.ret_value == пусто {
        LLVM::ret(К.Л, блок.exit_block, пусто);
      } інакше {
        ціль л_значення = LLVM::load(К.Л, блок.exit_block, отримати_ЛТип(К, д.тип_результату), блок.ret_value);
        LLVM::ret(К.Л, блок.exit_block, л_значення);
      }
    }

    вернути РезультатЗначення { значення, пусто };
  }

  місцева дія скомпілювати_створити_структуру(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСтворитиСтруктуру>): РезультатЗначення {
    якщо інформація_шаблону != пусто {
      якщо дані.кількість_параметрів == 0 {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Кількість параметрів не вказано");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }
    }

    ціль назва = дані.ідентифікатор.значення;

    змінна дані_типу_структури: комірка<ДаніТипуСтруктура> = пусто;

    ціль результат_отримання_з_середовища = отримати_з_локального_середовища(середовище, назва);
    якщо результат_отримання_з_середовища.знайдено == так {
      ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
      якщо субʼєкт.вид == ВидОКТип {
        ціль тип = субʼєкт.дані як комірка<Тип>;
        якщо тип.вид == ВидТипуСтруктура {
          дані_типу_структури = тип.дані як комірка<ДаніТипуСтруктура>;
          якщо дані_типу_структури.параметри.довжина != 0 {
            ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Структура вже визначена");
            вернути РезультатЗначення { Значення {}, помилка_компіляції };
          }
        } інакше {
          ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт вже визначено");
          вернути РезультатЗначення { Значення {}, помилка_компіляції };
        }
      } інакше {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт вже визначено");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }
    } інакше {
      дані_типу_структури = виділити<ДаніТипуСтруктура>();
      дані_типу_структури.л_тип = LLVM::struct(К.Л, назва);
      дані_типу_структури.параметри = виділити_список<Параметр>();

      ціль тип = виділити<Тип>();
      тип.вид = ВидТипуСтруктура;
      тип.дані = дані_типу_структури;

      змінити_в_середовищі(середовище, назва, ОбʼєктКомпіляції { ВидОКТип, тип });

      якщо інформація_шаблону != пусто {
        ціль значення = Значення {};
        значення.вид = ВидЗначенняОК;
        значення.к = ОбʼєктКомпіляції { ВидОКТип, тип };

        ціль шаблон = інформація_шаблону.шаблон;
        ціль аргументи = інформація_шаблону.аргументи;
        ціль карта_готових_значень = шаблон.карта_готових_значень;

        змінити_значення_карти<комірка<список<Значення>>, Значення>(карта_готових_значень, аргументи, значення);
      }
    }

    ціль л_типи_параметрів = виділити<комірка<ЛТип>>(дані.кількість_параметрів);

    змінна пх: позитивне = 0;
    поки пх < дані.кількість_параметрів {
      ціль асд_параметр = дані.параметри[пх];
      ціль параметр = Параметр {};
      параметр.назва = асд_параметр.ідентифікатор.значення;
      ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, пусто, середовище, асд_параметр.тип);
      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_типу.помилка };
      }
      параметр.тип = результат_компіляції_типу.тип;
      додати_до_списку<Параметр>(дані_типу_структури.параметри, параметр);
      л_типи_параметрів[пх] = отримати_ЛТип(К, результат_компіляції_типу.тип);
      пх = пх + 1;
    }

    якщо дані.кількість_параметрів != 0 {
      LLVM::struct_set_fields(К.Л, дані_типу_структури.л_тип, дані.кількість_параметрів, л_типи_параметрів);
    }

    ціль тип = виділити<Тип>();
    тип.вид = ВидТипуСтруктура;
    тип.дані = дані_типу_структури;
    ціль обʼєкт_компіляції = ОбʼєктКомпіляції { ВидОКТип, тип };

    вернути РезультатЗначення { Значення { ВидЗначенняОК, к = обʼєкт_компіляції }, пусто };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидСтворитиЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиЦіль>;
        ціль назва = дані.ідентифікатор.значення;

        ціль ц = виділити<Ціль>();

        якщо дані.тип == пусто {
          якщо дані.значення == пусто {
            ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вказано тип цілі");
            вернути РезультатКомпіляціїБлоку { помилка_компіляції };
          } інакше {
            ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.значення, так);
            якщо результат_компіляції_значення.помилка != пусто {
              вернути РезультатКомпіляціїБлоку { результат_компіляції_значення.помилка };
            }
            ціль тип = результат_компіляції_значення.в.тип;
            якщо тип.вид == ВидТипуНативний {
              якщо перевірити_тип(К, тип, К.тип_ніщо) == так {
                ціль помилка_компіляції = створити_помилку_компіляції(дані.значення.місцезнаходження, ю8"Тип не визначено");
                вернути РезультатКомпіляціїБлоку { помилка_компіляції };
              }
            }
            ц.тип = тип;
            ц.л_значення_alloca = LLVM::alloca(К.Л, блок.alloca_block, назва, отримати_ЛТип(К, тип));

            LLVM::store(К.Л, блок.block, результат_компіляції_значення.в.л_значення, ц.л_значення_alloca);
          }
        } інакше {
          ціль результат_компіляції_як_типу = скомпілювати_значення_як_тип(К, блок, середовище, дані.тип);
          якщо результат_компіляції_як_типу.помилка != пусто {
            вернути РезультатКомпіляціїБлоку { результат_компіляції_як_типу.помилка };
          }
          ціль тип = результат_компіляції_як_типу.тип;
          ц.тип = тип;
          ц.л_значення_alloca = LLVM::alloca(К.Л, блок.alloca_block, назва, отримати_ЛТип(К, тип));

          якщо дані.значення != пусто {
            ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.значення, так);
            якщо результат_компіляції_значення.помилка != пусто {
              вернути РезультатКомпіляціїБлоку { результат_компіляції_значення.помилка };
            }
            якщо перевірити_тип(К, результат_компіляції_значення.в.тип, тип) == ні {
              ціль помилка_компіляції = створити_помилку_компіляції(дані.значення.місцезнаходження, ю8"Невідповідні типи");
              вернути РезультатКомпіляціїБлоку { помилка_компіляції };
            }
            LLVM::store(К.Л, блок.block, результат_компіляції_значення.в.л_значення, ц.л_значення_alloca);
          }
        }

        ціль обʼєкт_компіляції = ОбʼєктКомпіляції { ВидОКЦіль, ц };

        змінити_в_середовищі(середовище, назва, обʼєкт_компіляції);
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;

        ціль результат_компіляції_обʼєкта_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.обʼєкт, ні);
        якщо результат_компіляції_обʼєкта_значення.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_обʼєкта_значення.помилка };
        }
        ціль тип = результат_компіляції_обʼєкта_значення.в.тип;
        якщо тип.вид != ВидТипуСтруктура {
          ціль помилка_компіляції = створити_помилку_компіляції(дані.обʼєкт.місцезнаходження, ю8"Тип не є структурою");
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
        ціль дані_типу_структури = тип.дані як комірка<ДаніТипуСтруктура>;
        ціль назва_властивості = дані.ідентифікатор.значення;
        змінна параметр: Параметр;
        змінна позиція_параметра: позитивне = 0;
        змінна параметр_знайдено: логічне = ні;
        змінна пх: позитивне = 0;
        поки пх < дані_типу_структури.параметри.довжина {
          якщо strcmp(дані_типу_структури.параметри.дані[пх].назва, назва_властивості) == 0 {
            параметр = дані_типу_структури.параметри.дані[пх];
            позиція_параметра = пх;
            параметр_знайдено = так;
          }
          пх = пх + 1;
        }
        якщо параметр_знайдено == ні {
          ціль помилка_компіляції = створити_помилку_компіляції(дані.ідентифікатор.місцезнаходження, ю8"Параметр не знайдено");
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
        ціль позиції_gep = виділити<комірка<ЛЗначення>>(2);
        позиції_gep[0] = LLVM::const_int32(К.Л, 0);
        позиції_gep[1] = LLVM::const_int32(К.Л, позиція_параметра);

        ціль л_значення_gep = LLVM::getelementptr(К.Л, блок.block, отримати_ЛТип(К, тип), результат_компіляції_обʼєкта_значення.в.л_значення, 2, позиції_gep);

        ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.значення, так);
        якщо результат_компіляції_значення.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_значення.помилка };
        }

        якщо перевірити_тип(К, результат_компіляції_значення.в.тип, параметр.тип) == ні {
          ціль помилка_компіляції = створити_помилку_компіляції(дані.значення.місцезнаходження, ю8"Невідповідні типи");
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }

        LLVM::store(К.Л, блок.block, результат_компіляції_значення.в.л_значення, л_значення_gep);
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль результат_компіляції_виконання = скомпілювати_значення_як_значення(К, блок, середовище, асд_значення, так);
        якщо результат_компіляції_виконання.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_виконання.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль назва = дані.ідентифікатор.значення;

        ціль результат_отримання_з_середовища = отримати_з_середовища(середовище, назва);
        якщо результат_отримання_з_середовища.знайдено == ні {
          ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Субʼєкт не визначено");
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        } інакше {
          ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
          якщо субʼєкт.вид == ВидОКЦіль {
            ціль ц = субʼєкт.дані як комірка<Ціль>;
            ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, середовище, дані.значення, так);
            якщо результат_компіляції_значення.помилка != пусто {
              вернути РезультатКомпіляціїБлоку { результат_компіляції_значення.помилка };
            }
            якщо перевірити_тип(К, результат_компіляції_значення.в.тип, ц.тип) == ні {
              ціль помилка_компіляції = створити_помилку_компіляції(дані.значення.місцезнаходження, ю8"Невідповідні типи");
              вернути РезультатКомпіляціїБлоку { помилка_компіляції };
            }
            LLVM::store(К.Л, блок.block, результат_компіляції_значення.в.л_значення, ц.л_значення_alloca);
          } інакше {
            ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Субʼєкт не є ціллю");
            вернути РезультатКомпіляціїБлоку { помилка_компіляції };
          }
        }
      }

      х = х + 1;
    }
    LLVM::br(К.Л, блок.block, блок.exit_block);
    вернути РезультатКомпіляціїБлоку { пусто };
  }

    дія порівняти_ов(ов1: ОбʼєктВиконання, ов2: ОбʼєктВиконання): логічне {
      біб::друк_ю8(ю8"СТОП порівняти_ов");
      вернути ні;
    }

    дія порівняти_тип(тип1: комірка<Тип>, тип2: комірка<Тип>): логічне {
      якщо тип1.вид != тип2.вид {
        вернути ні;
      }
      якщо тип1.вид == ВидТипуНативний {
        ціль тип_тип1 = тип1.дані як комірка<ДаніТипуНативний>;
        ціль тип_тип2 = тип2.дані як комірка<ДаніТипуНативний>;
        якщо тип_тип1 == тип_тип2 {
          вернути так;
        }
      }
      біб::друк_ю8(ю8"СТОП порівняти_ок");
      вернути ні;
    }

    дія порівняти_ок(ок1: ОбʼєктКомпіляції, ок2: ОбʼєктКомпіляції): логічне {
      якщо ок1.вид != ок2.вид {
        вернути ні;
      }
      якщо ок1.вид == ВидОКТип {
        ціль тип_ок1 = ок1.дані як комірка<Тип>;
        ціль тип_ок2 = ок2.дані як комірка<Тип>;
        вернути порівняти_тип(тип_ок1, тип_ок2);
      }
      біб::друк_ю8(ю8"СТОП порівняти_ок");
      вернути ні;
    }

    дія порівняти_значення(з1: Значення, з2: Значення): логічне {
      якщо з1.вид != з2.вид {
        вернути ні;
      }
      якщо з1.вид == ВидЗначенняОВ {
        вернути порівняти_ов(з1.в, з2.в);
      }
      якщо з1.вид == ВидЗначенняОК {
        вернути порівняти_ок(з1.к, з2.к);
      }
      біб::друк_ю8(ю8"СТОП порівняти_значення");
      вернути ні;
    }

    дія порівняти_списки_значень(с1: комірка<список<Значення>>, с2: комірка<список<Значення>>): логічне {
      якщо с1.довжина != с2.довжина {
        вернути ні;
      }
      змінна х: позитивне = 0;
      поки х < с1.довжина {
        якщо порівняти_значення(с1.дані[х], с2.дані[х]) == ні {
          вернути ні;
        }
        х = х + 1;
      }
      вернути так;
    }

    місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
      змінна х: позитивне = 0;
      поки х < тіло.довжина {
        ціль асд_значення = тіло.елементи[х];

        якщо асд_значення.вид == АСДВидСтворитиДію {
          ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиДію>;
          ціль результат_створення_дії = скомпілювати_створити_дію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
          якщо результат_створення_дії.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { результат_створення_дії.помилка };
          }
        } інакше якщо асд_значення.вид == АСДВидСтворитиСтруктуру {
          ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСтруктуру>;
          ціль результат_створення_структури = скомпілювати_створити_структуру(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
          якщо результат_створення_структури.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { результат_створення_структури.помилка };
          }
        } інакше якщо асд_значення.вид == АСДВидСтворитиШаблон {
          ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиШаблон>;

          ціль назва = дані.ідентифікатор.значення;

          ціль ш = виділити<Шаблон>();
          ш.зовнішнє_середовище = середовище_секції;
          ш.параметри = виділити_список<памʼять<п8>>();
          ш.асд_значення = дані.значення;
          ш.карта_готових_значень = виділити_карту<комірка<список<Значення>>, Значення>(порівняти_списки_значень);

          змінна пх: позитивне = 0;
          поки пх < дані.кількість_параметрів {
            ціль асд_ідентифікатор = дані.параметри[пх];
            додати_до_списку<памʼять<п8>>(ш.параметри, асд_ідентифікатор.значення);
            пх = пх + 1;
          }

          змінити_в_середовищі(середовище_секції, назва, ОбʼєктКомпіляції { ВидОКШаблон, ш });
        }

        х = х + 1;
      }
      вернути РезультатКомпіляціїТілаСекції { пусто };
    }
}