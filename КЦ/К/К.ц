взяти визначення К;

секція цк {
  місцева дія скомпілювати_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначення {
    змінна результат: РезультатЗначення;
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      результат = скомпілювати_значення_звернутись(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      результат = скомпілювати_значення_отримати(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтриматиЗіСекції {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтриматиЗіСекції>;
      результат = скомпілювати_значення_отримати_зі_секції(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      результат = скомпілювати_значення_виконати(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконатиШаблон {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконатиШаблон>;
      результат = скомпілювати_значення_виконати_шаблон(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидСтруктура {
      ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
      результат = скомпілювати_структуру(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидДія {
      ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
      ціль результат_компіляції_дії = скомпілювати_дію(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
      якщо результат_компіляції_дії.помилка == пусто {
        ціль дія_ = результат_компіляції_дії.дія_;
        результат.значення = Значення { ВидЗначенняОВ, в = ОбʼєктВиконання { тип = дія_.тип, л_значення = дія_.л_функція як комірка<ЛЗначення>, unloaded = ні } };
        результат.помилка = пусто;
      } інакше {
        результат.помилка = результат_компіляції_дії.помилка;
      }
    } інакше якщо асд_значення.вид == АСДВидСинонім {
      ціль дані = асд_значення.дані як комірка<АСДДаніСинонім>;
      результат = скомпілювати_синонім(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОперація {
      ціль дані = асд_значення.дані як комірка<АСДДаніОперація>;
      результат = скомпілювати_значення_операція(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЗначенняЧисло {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняЧисло>;
      результат = скомпілювати_значення_число(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані, ОчікуванийТипЧислаАВТО);
    } інакше якщо асд_значення.вид == АСДВидЗначенняТекст {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняТекст>;
      результат = скомпілювати_значення_текст(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЯк {
      ціль дані = асд_значення.дані як комірка<АСДДаніЯк>;
      результат = скомпілювати_як(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЯк {
      ціль дані = асд_значення.дані як комірка<АСДДаніЯк>;
      результат = скомпілювати_як(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше {
      біб::друк_позитивне(асд_значення.вид);
      ціль помилка = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення");
      вернути РезультатЗначення { Значення {}, помилка };
    }

    якщо результат.помилка == пусто {
      якщо результат.значення.вид == ВидЗначенняОК {
        ціль ок = результат.значення.к;
        якщо ок.вид == ВидОКСинонім {
          ціль син = ок.дані як комірка<Синонім>;
          вернути скомпілювати_значення(К, блок, пусто, син.зовнішнє_середовище, син.асд_значення);
        }
      }
    }

    вернути результат;
  }

  місцева дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначенняТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняТип { Тип {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОВ {
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням типу");
      вернути РезультатЗначенняТип { Тип {}, створити_помилку_компіляції };
    }
    ціль обʼєкт_компіляції = значення.к;
    якщо обʼєкт_компіляції.вид != ВидОКТип {
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є типом");
      вернути РезультатЗначенняТип { Тип {}, створити_помилку_компіляції };
    }
    ціль комірка_типу = обʼєкт_компіляції.дані як комірка<Тип>;
    ціль тип = вміст(комірка_типу);
    вернути РезультатЗначенняТип { тип, пусто };
  }

  місцева дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, load: логічне): РезультатЗначенняЗначення {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОК {
      ціль ок = значення.к;
      якщо ок.вид == ВидОКЦіль {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль ц = ок.дані як комірка<Ціль>;
        якщо load == так {
          ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, ц.тип), ц.л_значення_alloca);
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, л_значення }, пусто };
        } інакше {
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, ц.л_значення_alloca }, пусто };
        }
      } інакше якщо ок.вид == ВидОКДія {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль д = ок.дані як комірка<Дія>;
        ціль тип = зробити_тип_з_дії(К, д);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { тип, д.л_функція як комірка<ЛЗначення> }, пусто };
      }
      біб::друк_позитивне(ок.вид);
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням");
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
    }
    якщо load == так {
      якщо значення.в.unloaded == так {
        ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, значення.в.тип), значення.в.л_значення);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { значення.в.тип, л_значення, unloaded = ні }, пусто };
      }
    }
    вернути РезультатЗначенняЗначення { значення.в, пусто };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидСтворитиЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиЦіль>;
        ціль помилка_компіляції = скомпілювати_створити_ціль(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
        ціль помилка_компіляції = скомпілювати_змінити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль результат_компіляції_виконання = скомпілювати_значення_як_значення(К, блок, середовище, асд_значення, так);
        якщо результат_компіляції_виконання.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_виконання.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль помилка_компіляції = скомпілювати_перевизначити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      }

      х = х + 1;
    }
    LLVM::br(К.Л, блок.block, блок.exit_block);
    вернути РезультатКомпіляціїБлоку { пусто };
  }

  дія скомпілювати_визначити_дію(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніДія>): комірка<ПомилкаКомпіляції> {
    ціль назва = дані.ідентифікатор.значення;
    ціль результат_отримання_з_середовища = отримати_з_локального_середовища(середовище, назва);
    якщо результат_отримання_з_середовища.знайдено == так {
      ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
      якщо субʼєкт.вид == ВидОКДія {
        ціль ок_дія = субʼєкт.дані як комірка<Дія>;
        // ...
      }
      ціль помилка_компіляції = створити_помилку_компіляції_субʼєкт_вже_визначено(місцезнаходження, назва);
      вернути помилка_компіляції;
    } інакше {
      ціль результат_створення_дії = скомпілювати_дію(К, пусто, пусто, середовище, місцезнаходження, дані);
      якщо результат_створення_дії.помилка != пусто {
        вернути результат_створення_дії.помилка;
      }
      змінити_в_середовищі(середовище, назва, ОбʼєктКомпіляції { ВидОКДія, дані = результат_створення_дії.дія_ });
    }
    вернути пусто;
  }

  дія скомпілювати_визначити_структуру(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСтруктура>): комірка<ПомилкаКомпіляції> {
    ціль назва = дані.ідентифікатор.значення;
    ціль результат_отримання_з_середовища = отримати_з_локального_середовища(середовище, назва);
    якщо результат_отримання_з_середовища.знайдено == так {
      ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
      якщо субʼєкт.вид == ВидОКТип {
        ціль тип = субʼєкт.дані як комірка<Тип>;
        якщо тип.вид == ВидТипуСтруктура {
          ціль дані_типу_структури = тип.дані як комірка<ДаніТипуСтруктура>;
          якщо дані_типу_структури.параметри.довжина == 0 {
            ціль помилка_заповнення = заповнити_дані_типу_структури(К, середовище, дані_типу_структури, дані);
            якщо помилка_заповнення != пусто {
              вернути помилка_заповнення;
            }
            вернути пусто;
          }
        }
      }
      ціль помилка_компіляції = створити_помилку_компіляції_субʼєкт_вже_визначено(місцезнаходження, назва);
      вернути помилка_компіляції;
    } інакше {
      ціль результат_створення_структури = скомпілювати_структуру(К, пусто, пусто, середовище, місцезнаходження, дані);
      якщо результат_створення_структури.помилка != пусто {
        вернути результат_створення_структури.помилка;
      }
      змінити_в_середовищі(середовище, назва, результат_створення_структури.значення.к);
    }
    вернути пусто;
  }

  дія скомпілювати_визначити_шаблон(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніШаблон>): комірка<ПомилкаКомпіляції> {
    ціль назва = дані.ідентифікатор.значення;
    ціль результат_отримання_з_середовища = отримати_з_локального_середовища(середовище, назва);
    якщо результат_отримання_з_середовища.знайдено == так {
      ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
      якщо субʼєкт.вид == ВидОКШаблон {
        ціль шаблон = субʼєкт.дані як комірка<Шаблон>;
        якщо дані.значення.вид == АСДВидСтруктура {
          ціль дані_значення = дані.значення.дані як комірка<АСДДаніСтруктура>;
          якщо дані_значення.кількість_параметрів != 0 {
            якщо шаблон.асд_значення.вид == АСДВидСтруктура {
              ціль дані_значення_шаблону = шаблон.асд_значення.дані як комірка<АСДДаніСтруктура>;
              якщо дані_значення_шаблону.кількість_параметрів == 0 {
                шаблон.асд_значення = дані.значення;
                змінна пх: позитивне = 0;
                поки пх < шаблон.карта_готових_значень.елементи.довжина {
                  ціль значення = шаблон.карта_готових_значень.елементи.дані[пх];
                  ціль к = значення.значення.к;
                  ціль тип = к.дані як комірка<Тип>;
                  ціль дані_типу_структури = тип.дані як комірка<ДаніТипуСтруктура>;
                  ціль помилка_заповнення = заповнити_дані_типу_структури(К, дані_типу_структури.середовище_структури, дані_типу_структури, дані_значення);
                  якщо помилка_заповнення != пусто {
                    вернути помилка_заповнення;
                  }
                  пх = пх + 1;
                }
              }
              вернути пусто;
            }
          }
        }
      }
      ціль помилка_компіляції = створити_помилку_компіляції_субʼєкт_вже_визначено(місцезнаходження, назва);
      вернути помилка_компіляції;
    } інакше {
      якщо дані.значення.вид == АСДВидШаблон {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Неможливо створити шаблон для шаблону");
        вернути помилка_компіляції;
      }
      якщо дані.значення.вид == АСДВидДія {
        ціль дані_значення = дані.значення.дані як комірка<АСДДаніДія>;
        якщо дані_значення.видимість != АСДВидимістьВнутрішня {
          ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Шаблон дії може мати лише внутрішню видимість");
          вернути помилка_компіляції;
        }
      }
      ціль результат_створення_шаблону = скомпілювати_шаблон(К, пусто, пусто, середовище, місцезнаходження, дані);
      якщо результат_створення_шаблону.помилка != пусто {
        вернути результат_створення_шаблону.помилка;
      }
      змінити_в_середовищі(середовище, назва, результат_створення_шаблону.значення.к);
    }
    вернути пусто;
  }

  дія скомпілювати_визначити_синонім(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСинонім>): комірка<ПомилкаКомпіляції> {
    ціль назва = дані.ідентифікатор.значення;
    ціль результат_отримання_з_середовища = отримати_з_локального_середовища(середовище, назва);
    якщо результат_отримання_з_середовища.знайдено == так {
      ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
      якщо субʼєкт.вид == ВидОКСинонім {
        ціль ок_синонім = субʼєкт.дані як комірка<Синонім>;
        // ...
      }
      ціль помилка_компіляції = створити_помилку_компіляції_субʼєкт_вже_визначено(місцезнаходження, назва);
      вернути помилка_компіляції;
    } інакше {
      ціль результат_створення_синоніма = скомпілювати_синонім(К, пусто, пусто, середовище, місцезнаходження, дані);
      якщо результат_створення_синоніма.помилка != пусто {
        вернути результат_створення_синоніма.помилка;
      }
      змінити_в_середовищі(середовище, назва, результат_створення_синоніма.значення.к);
    }
    вернути пусто;
  }

  місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидДія {
        ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
        ціль помилка_компіляції = скомпілювати_визначити_дію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСтруктура {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
        ціль помилка_компіляції = скомпілювати_визначити_структуру(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидШаблон {
        ціль дані = асд_значення.дані як комірка<АСДДаніШаблон>;
        ціль помилка_компіляції = скомпілювати_визначити_шаблон(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСинонім {
        ціль дані = асд_значення.дані як комірка<АСДДаніСинонім>;
        ціль помилка_компіляції = скомпілювати_визначити_синонім(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСтворитиСекцію {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСекцію>;
        ціль результат_створення_секції = скомпілювати_створити_секцію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо результат_створення_секції.помилка != пусто {
          вернути РезультатКомпіляціїТілаСекції { результат_створення_секції.помилка };
        }
      }

      х = х + 1;
    }
    вернути РезультатКомпіляціїТілаСекції { пусто };
  }
}