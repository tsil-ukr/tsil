взяти визначення К;

секція цк {
  місцева дія скомпілювати_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначення {
    змінна результат: РезультатЗначення;
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      результат = скомпілювати_значення_звернутись(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      результат = скомпілювати_значення_отримати(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтриматиЗіСекції {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтриматиЗіСекції>;
      результат = скомпілювати_значення_отримати_зі_секції(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      результат = скомпілювати_значення_виконати(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконатиШаблон {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконатиШаблон>;
      результат = скомпілювати_значення_виконати_шаблон(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидСтруктура {
      ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
      результат = скомпілювати_структуру(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидДія {
      ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
      ціль результат_компіляції_дії = скомпілювати_дію(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
      якщо результат_компіляції_дії.помилка == пусто {
        ціль дія_ = результат_компіляції_дії.дія_;
        ціль тип = Тип { ВидТипуДія, дані = дія_.дані_типу_дія };
        результат.значення = Значення { ВидЗначенняОВ, в = ОбʼєктВиконання { тип = тип, llvm_value = дія_.llvm_function як комірка<LLVM::Value>, unloaded = ні } };
        результат.помилка = пусто;
      } інакше {
        результат.помилка = результат_компіляції_дії.помилка;
      }
    } інакше якщо асд_значення.вид == АСДВидСинонім {
      ціль дані = асд_значення.дані як комірка<АСДДаніСинонім>;
      результат = скомпілювати_синонім(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОперація {
      ціль дані = асд_значення.дані як комірка<АСДДаніОперація>;
      результат = скомпілювати_значення_операція(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЗначенняЧисло {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняЧисло>;
      результат = скомпілювати_значення_число(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані, ОчікуванийТипЧислаАВТО);
    } інакше якщо асд_значення.вид == АСДВидЗначенняТекст {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняТекст>;
      результат = скомпілювати_значення_текст(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЯк {
      ціль дані = асд_значення.дані як комірка<АСДДаніЯк>;
      результат = скомпілювати_як(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЯк {
      ціль дані = асд_значення.дані як комірка<АСДДаніЯк>;
      результат = скомпілювати_як(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше {
      біб::друк_позитивне(асд_значення.вид);
      ціль помилка = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення");
      вернути РезультатЗначення { Значення {}, помилка };
    }

    якщо результат.помилка == пусто {
      якщо результат.значення.вид == ВидЗначенняОК {
        ціль ок = результат.значення.к;
        якщо ок.вид == ВидОКСинонім {
          ціль син = ок.дані як комірка<Синонім>;
          вернути скомпілювати_значення(К, блок, пусто, син.зовнішнє_середовище, син.асд_значення);
        }
      }
    }

    вернути результат;
  }

  дія перевірити_чи_тип_є_повним(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо тип.вид == ВидТипуСтруктура {
      ціль дані_типу_структура = тип.дані як комірка<ДаніТипуСтруктура>;
      якщо дані_типу_структура.параметри.довжина == 0 {
        вернути ні;
      }
    }
    вернути так;
  }

  місцева дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначенняТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняТип { Тип {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОВ {
      ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням типу");
      вернути РезультатЗначенняТип { помилка = помилка_компіляції };
    }
    ціль обʼєкт_компіляції = значення.к;
    якщо обʼєкт_компіляції.вид != ВидОКТип {
      ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є типом");
      вернути РезультатЗначенняТип { помилка = помилка_компіляції };
    }
    ціль комірка_типу = обʼєкт_компіляції.дані як комірка<Тип>;
    якщо перевірити_чи_тип_є_повним(К, вміст(комірка_типу)) == ні {
      ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Тип не є повним");
      вернути РезультатЗначенняТип { помилка = помилка_компіляції };
    }
    ціль тип = вміст(комірка_типу);
    вернути РезультатЗначенняТип { тип, пусто };
  }

  місцева дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, load: логічне): РезультатЗначенняЗначення {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОК {
      ціль ок = значення.к;
      якщо ок.вид == ВидОКЦіль {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль ц = ок.дані як комірка<Ціль>;
        якщо load == так {
          ціль llvm_value = LLVM::load(К.Л, блок.llvm_block, отримати_llvm_type(К, ц.тип), ц.llvm_alloca_value);
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, llvm_value }, пусто };
        } інакше {
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, ц.llvm_alloca_value }, пусто };
        }
      } інакше якщо ок.вид == ВидОКДія {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль д = ок.дані як комірка<Дія>;
        ціль тип = зробити_тип_з_дії(К, д);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { тип, д.llvm_function як комірка<LLVM::Value> }, пусто };
      }
      біб::друк_позитивне(ок.вид);
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням");
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
    }
    якщо load == так {
      якщо значення.в.unloaded == так {
        ціль llvm_value = LLVM::load(К.Л, блок.llvm_block, отримати_llvm_type(К, значення.в.тип), значення.в.llvm_value);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { значення.в.тип, llvm_value, unloaded = ні }, пусто };
      }
    }
    вернути РезультатЗначенняЗначення { значення.в, пусто };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніЦіль>;
        ціль помилка_компіляції = скомпілювати_визначити_ціль(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
        ціль помилка_компіляції = скомпілювати_змінити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль результат_компіляції_виконання = скомпілювати_значення_як_значення(К, блок, середовище, асд_значення, так);
        якщо результат_компіляції_виконання.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_виконання.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль помилка_компіляції = скомпілювати_перевизначити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      }

      х = х + 1;
    }
    LLVM::br(К.Л, блок.llvm_block, блок.llvm_exit_block);
    вернути РезультатКомпіляціїБлоку { пусто };
  }

  місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидДія {
        ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
        ціль помилка_компіляції = скомпілювати_визначити_дію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСтруктура {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
        ціль помилка_компіляції = скомпілювати_визначити_структуру(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидШаблон {
        ціль дані = асд_значення.дані як комірка<АСДДаніШаблон>;
        ціль помилка_компіляції = скомпілювати_визначити_шаблон(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСинонім {
        ціль дані = асд_значення.дані як комірка<АСДДаніСинонім>;
        ціль помилка_компіляції = скомпілювати_визначити_синонім(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСекція {
        ціль дані = асд_значення.дані як комірка<АСДДаніСекція>;
        ціль помилка_компіляції = скомпілювати_визначити_секцію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      }

      х = х + 1;
    }
    вернути РезультатКомпіляціїТілаСекції { пусто };
  }
}

секція ц {
  місцева дія скомпілювати_блок(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніЦіль>;
        ціль назва = дані.ідентифікатор.значення;
        ціль результат_компіляції_значення_типу = скомпілювати_значення_як_тип(К, пусто, пусто, середовище, дані.тип);
        якщо результат_компіляції_значення_типу.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { помилка = результат_компіляції_значення_типу.помилка };
        }
        ціль обʼєкт_типу_цілі = результат_компіляції_значення_типу.обʼєкт_типу;
        ціль обʼєкт_цілі = виділити<ОбʼєктЦілі>();
        обʼєкт_цілі.тип = обʼєкт_типу_цілі;
        обʼєкт_цілі.llvm_value = LLVM::alloca(К.L, блок.llvm_alloca_block, назва, обʼєкт_типу_цілі.llvm_type);
        обʼєкт_цілі.додати = пусто;
        якщо дані.значення != пусто {
          ціль результат_компіляції_значення = скомпілювати_значення_як_значення(К, блок, пусто, середовище, дані.значення);
          якщо результат_компіляції_значення.помилка != пусто {
            вернути РезультатКомпіляціїБлоку { помилка = результат_компіляції_значення.помилка };
          }
          ціль обʼєкт_значення = результат_компіляції_значення.обʼєкт_значення;
          якщо перевірити_тип(К, обʼєкт_значення.тип, обʼєкт_типу_цілі) == ні {
            ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Тип значення не відповідає типу цілі");
            вернути РезультатКомпіляціїБлоку { помилка = помилка_компіляції };
          }
          LLVM::store(К.L, блок.llvm_block, обʼєкт_значення.llvm_value, обʼєкт_цілі.llvm_value);
        }
        ціль обʼєкт = Обʼєкт { ВидОбʼєктаЦілі, дані = обʼєкт_цілі };
        змінити_в_середовищі(середовище, назва, обʼєкт);
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
      }

      х = х + 1;
    }
    LLVM::br(К.L, блок.llvm_block, блок.llvm_exit_block);
    вернути РезультатКомпіляціїБлоку { пусто };
  }

  місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидДія {
        ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
        ціль назва = дані.ідентифікатор.значення;
        ціль обʼєкт_дії = виділити<ОбʼєктДії>();
        обʼєкт_дії.назва = назва;
        обʼєкт_дії.параметри = виділити_список<ПараметрДії>();
        обʼєкт_дії.тип_результату = К.тип_ніщо;
        обʼєкт_дії.тип = пусто;
        обʼєкт_дії.llvm_function = пусто;
        обʼєкт_дії.додати = пусто;
        ціль llvm_param_types = виділити<комірка<LLVM::Type>>(дані.кількість_параметрів);
        змінна пх: позитивне = 0;
        поки пх < дані.кількість_параметрів {
          ціль параметр = дані.параметри[пх];
          ціль назва_параметра = параметр.ідентифікатор.значення;
          ціль результат_компіляції_значення_типу_параметра = скомпілювати_значення_як_тип(К, пусто, пусто, середовище_секції, параметр.тип);
          якщо результат_компіляції_значення_типу_параметра.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { помилка = результат_компіляції_значення_типу_параметра.помилка };
          }
          ціль обʼєкт_типу_параметра = результат_компіляції_значення_типу_параметра.обʼєкт_типу;
          ціль параметр_дії = ПараметрДії { назва = назва_параметра, тип = обʼєкт_типу_параметра };
          додати_до_списку<ПараметрДії>(обʼєкт_дії.параметри, параметр_дії);
          llvm_param_types[пх] = обʼєкт_типу_параметра.llvm_type;
          пх = пх + 1;
        }
        якщо дані.тип_результату != пусто {
          ціль результат_компіляції_значення_типу_результату = скомпілювати_значення_як_тип(К, пусто, пусто, середовище_секції, дані.тип_результату);
          якщо результат_компіляції_значення_типу_результату.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { помилка = результат_компіляції_значення_типу_результату.помилка };
          }
          обʼєкт_дії.тип_результату = результат_компіляції_значення_типу_результату.обʼєкт_типу;
        }
        обʼєкт_дії.llvm_function = LLVM::function(К.L, LLVM::LINKAGE_INTERNAL, назва, обʼєкт_дії.тип_результату.llvm_type, обʼєкт_дії.параметри.довжина, llvm_param_types, ні);
        якщо дані.тіло != пусто {
          ціль блок = виділити<Блок>();
          блок.llvm_ret_value = пусто;
          блок.llvm_alloca_block = LLVM::block(К.L, обʼєкт_дії.llvm_function, ю8"alloca");
          блок.llvm_block = LLVM::block(К.L, обʼєкт_дії.llvm_function, ю8"entry");
          блок.llvm_exit_block = LLVM::block(К.L, обʼєкт_дії.llvm_function, ю8"exit");
          блок.llvm_function_exit_block = блок.llvm_exit_block;
          якщо обʼєкт_дії.тип_результату != К.тип_ніщо {
            блок.llvm_ret_value = LLVM::alloca(К.L, блок.llvm_alloca_block, ю8"return", обʼєкт_дії.тип_результату.llvm_type);
          }
          ціль результат_компіляції_блоку = скомпілювати_блок(К, блок, середовище_секції, дані.тіло);
          якщо результат_компіляції_блоку.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { помилка = результат_компіляції_блоку.помилка };
          }
          LLVM::br(К.L, блок.llvm_alloca_block, блок.llvm_block);
          якщо блок.llvm_ret_value == пусто {
            LLVM::ret(К.L, блок.llvm_exit_block, пусто);
          } інакше {
            ціль llvm_value = LLVM::load(К.L, блок.llvm_exit_block, обʼєкт_дії.тип_результату.llvm_type, блок.llvm_ret_value);
            LLVM::ret(К.L, блок.llvm_exit_block, llvm_value);
          }
        }
        ціль обʼєкт = Обʼєкт { ВидОбʼєктаДії, дані = обʼєкт_дії };
        змінити_в_середовищі(середовище_секції, назва, обʼєкт);
      } інакше якщо асд_значення.вид == АСДВидСтруктура {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
        ціль назва = дані.ідентифікатор.значення;
        ціль обʼєкт_типу = виділити<ОбʼєктТипу>();
        обʼєкт_типу.вид = ВидТипуСтруктура;
        обʼєкт_типу.назва = назва;
        обʼєкт_типу.властивості_структури = виділити_список<ВластивістьСтруктури>();
        обʼєкт_типу.параметри_дії = пусто;
        обʼєкт_типу.тип_результату_дії = пусто;
        обʼєкт_типу.llvm_type = LLVM::struct(К.L, назва);
        обʼєкт_типу.додати = пусто;
        ціль llvm_param_types = виділити<комірка<LLVM::Type>>(дані.кількість_параметрів);
        змінна пх: позитивне = 0;
        поки пх < дані.кількість_параметрів {
          ціль параметр = дані.параметри[пх];
          ціль назва_параметра = параметр.ідентифікатор.значення;
          ціль результат_компіляції_значення_типу_параметра = скомпілювати_значення_як_тип(К, пусто, пусто, середовище_секції, параметр.тип);
          якщо результат_компіляції_значення_типу_параметра.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { помилка = результат_компіляції_значення_типу_параметра.помилка };
          }
          ціль обʼєкт_типу_параметра = результат_компіляції_значення_типу_параметра.обʼєкт_типу;
          ціль властивість_структури = ВластивістьСтруктури { назва = назва_параметра, тип = обʼєкт_типу_параметра };
          додати_до_списку<ВластивістьСтруктури>(обʼєкт_типу.властивості_структури, властивість_структури);
          llvm_param_types[пх] = обʼєкт_типу_параметра.llvm_type;
          пх = пх + 1;
        }
        LLVM::struct_set_fields(К.L, обʼєкт_типу.llvm_type, дані.кількість_параметрів, llvm_param_types);
        ціль обʼєкт = Обʼєкт { ВидОбʼєктаТипу, дані = обʼєкт_типу };
        змінити_в_середовищі(середовище_секції, назва, обʼєкт);
      } інакше якщо асд_значення.вид == АСДВидШаблон {
        ціль дані = асд_значення.дані як комірка<АСДДаніШаблон>;
      } інакше якщо асд_значення.вид == АСДВидСинонім {
        ціль дані = асд_значення.дані як комірка<АСДДаніСинонім>;
      } інакше якщо асд_значення.вид == АСДВидСекція {
        ціль дані = асд_значення.дані як комірка<АСДДаніСекція>;
      }

      х = х + 1;
    }
    вернути РезультатКомпіляціїТілаСекції { помилка = пусто };
  }

  місцева дія скомпілювати_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: невідома_комірка, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): Результат {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      ціль назва = дані.ідентифікатор.значення;
      ціль обʼєкт: Обʼєкт;
      ціль успіх_отримання_зі_середовища = отримати_зі_середовища(середовище, назва, комірка(обʼєкт));
      якщо успіх_отримання_зі_середовища == так {
        вернути Результат { обʼєкт = обʼєкт, помилка = пусто };
      }
    }

    ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати значення");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: невідома_комірка, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЯкТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, інформація_виконання_шаблону, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЯкТип { помилка = результат_компіляції_значення.помилка };
    }
    якщо результат_компіляції_значення.обʼєкт.вид != ВидОбʼєктаТипу {
      ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Значення не є типом");
      вернути РезультатЯкТип { помилка = помилка_компіляції };
    }
    ціль обʼєкт = результат_компіляції_значення.обʼєкт;
    вернути РезультатЯкТип { обʼєкт_типу = обʼєкт.дані як комірка<ОбʼєктТипу>, помилка = пусто };
  }

  місцева дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: невідома_комірка, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЯкЗначення {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, інформація_виконання_шаблону, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЯкЗначення { помилка = результат_компіляції_значення.помилка };
    }
    якщо результат_компіляції_значення.обʼєкт.вид == ВидОбʼєктаЦілі {
      ціль обʼєкт_цілі = результат_компіляції_значення.обʼєкт.дані як комірка<ОбʼєктЦілі>;
      ціль loaded_llvm_value = LLVM::load(К.L, блок.llvm_block, обʼєкт_цілі.тип.llvm_type, обʼєкт_цілі.llvm_value);
      ціль обʼєкт_значення = виділити<ОбʼєктЗначення>();
      обʼєкт_значення.тип = обʼєкт_цілі.тип;
      обʼєкт_значення.llvm_value = loaded_llvm_value;
      вернути РезультатЯкЗначення { обʼєкт_значення = обʼєкт_значення, помилка = пусто };
    }
    якщо результат_компіляції_значення.обʼєкт.вид != ВидОбʼєктаЗначення {
      ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Значення не є значенням");
      вернути РезультатЯкЗначення { помилка = помилка_компіляції };
    }
    ціль обʼєкт = результат_компіляції_значення.обʼєкт;
    вернути РезультатЯкЗначення { обʼєкт_значення = обʼєкт.дані як комірка<ОбʼєктЗначення>, помилка = пусто };
  }
}