взяти визначення К;

секція ц {
  місцева дія скомпілювати_асд_значення_як_значення(К: комірка<Компілятор>, л_блок: комірка<ЛБлок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, load: логічне): РезультатКомпіляціїЗначенняЯкЗначення {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      ціль результат_компіляції_звернутись = скомпілювати_звернутись(К, л_блок, середовище, асд_значення.місцезнаходження, дані, load);
      вернути РезультатКомпіляціїЗначенняЯкЗначення { результат_компіляції_звернутись.тип, результат_компіляції_звернутись.л_значення, результат_компіляції_звернутись.помилка };
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      ціль результат_компіляції_отримати = скомпілювати_отримати(К, л_блок, середовище, асд_значення.місцезнаходження, дані, load);
      вернути РезультатКомпіляціїЗначенняЯкЗначення { результат_компіляції_отримати.тип, результат_компіляції_отримати.л_значення, результат_компіляції_отримати.помилка };
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      ціль результат_компіляції_виконати = скомпілювати_виконати(К, л_блок, середовище, асд_значення.місцезнаходження, дані);
      вернути РезультатКомпіляціїЗначенняЯкЗначення { результат_компіляції_виконати.тип, результат_компіляції_виконати.л_значення, результат_компіляції_виконати.помилка };
    }
    ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати значення як значення");
    вернути РезультатКомпіляціїЗначенняЯкЗначення { Тип {}, пусто, помилка_компіляції };
  }

  місцева дія скомпілювати_асд_значення_як_тип(К: комірка<Компілятор>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатКомпіляціїЗначенняЯкТипу {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      ціль результат_отримання_з_середовища = отримати_з_середовища(середовище, дані.ідентифікатор.значення);
      якщо результат_отримання_з_середовища.знайдено == ні {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт не визначено");
        вернути РезультатКомпіляціїЗначенняЯкТипу { Тип {}, помилка_компіляції };
      } інакше {
        ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
        якщо субʼєкт.вид == ВидСубʼєктаНативнийТип {
          ціль обʼєкт_нативного_типу = субʼєкт.дані як комірка<ОбʼєктНативногоТипу>;
          вернути РезультатКомпіляціїЗначенняЯкТипу { Тип { ВидТипуНативний, обʼєкт_нативного_типу }, пусто };
        } інакше якщо субʼєкт.вид == ВидСубʼєктаСтруктура {
          ціль обʼєкт_структури = субʼєкт.дані як комірка<ОбʼєктСтруктури>;
          вернути РезультатКомпіляціїЗначенняЯкТипу { Тип { ВидТипуСтруктура, обʼєкт_структури }, пусто };
        }
      }
    } інакше якщо асд_значення.вид == АСДВидВиконатиШаблон {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконатиШаблон>;
      ціль результат_компіляції_виконати_шаблон = скомпілювати_виконати_шаблон(К, середовище, асд_значення.місцезнаходження, дані);
      якщо результат_компіляції_виконати_шаблон.помилка != пусто {
        вернути РезультатКомпіляціїЗначенняЯкТипу { Тип {}, результат_компіляції_виконати_шаблон.помилка };
      }
      вернути РезультатКомпіляціїЗначенняЯкТипу { результат_компіляції_виконати_шаблон.тип, пусто };
    }
    ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати значення як тип");
    вернути РезультатКомпіляціїЗначенняЯкТипу { Тип {}, помилка_компіляції };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, обʼєкт_дії: комірка<ОбʼєктДії>, середовище: комірка<Середовище>, л_блок_алокацій: комірка<ЛБлок>, л_блок: комірка<ЛБлок>, вихідний_л_блок: комірка<ЛБлок>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаДії {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
      якщо асд_значення.вид == АСДВидСтворитиЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиЦіль>;
        ціль результат_компіляції_створити_ціль_в_тілі_дії = скомпілювати_створити_ціль_в_тілі_дії(К, л_блок_алокацій, л_блок, вихідний_л_блок, середовище, асд_значення.місцезнаходження, дані);
        якщо результат_компіляції_створити_ціль_в_тілі_дії.помилка != пусто {
          вернути РезультатКомпіляціїТілаДії { результат_компіляції_створити_ціль_в_тілі_дії.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль результат_компіляції_перевизначити = скомпілювати_перевизначити(К, л_блок, середовище, асд_значення.місцезнаходження, дані);
        якщо результат_компіляції_перевизначити.помилка != пусто {
          вернути РезультатКомпіляціїТілаДії { результат_компіляції_перевизначити.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
        ціль результат_компіляції_змінити = скомпілювати_змінити(К, л_блок, середовище, асд_значення.місцезнаходження, дані);
        якщо результат_компіляції_змінити.помилка != пусто {
          вернути РезультатКомпіляціїТілаДії { результат_компіляції_змінити.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидОтримати {
        ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
        ціль результат_компіляції_отримати = скомпілювати_отримати(К, л_блок, середовище, асд_значення.місцезнаходження, дані, так);
        якщо результат_компіляції_отримати.помилка != пусто {
          вернути РезультатКомпіляціїТілаДії { результат_компіляції_отримати.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
        ціль результат_компіляції_виконати = скомпілювати_виконати(К, л_блок, середовище, асд_значення.місцезнаходження, дані);
        якщо результат_компіляції_виконати.помилка != пусто {
          вернути РезультатКомпіляціїТілаДії { результат_компіляції_виконати.помилка };
        }
      } інакше {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати тіло дії");
        вернути РезультатКомпіляціїТілаДії { помилка_компіляції };
      }
      х = х + 1;
    }
    LLVM::br(К.Л, л_блок, вихідний_л_блок);
    вернути РезультатКомпіляціїТілаДії { пусто };
  }

  місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
//      біб::вивести_позитивне(х);
//      біб::вивести_ю8(ю8" ");
//      біб::друк_позитивне(асд_значення.вид);
      якщо асд_значення.вид == АСДВидСтворитиДію {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиДію>;

        ціль назва = дані.ідентифікатор.значення;

        змінна обʼєкт_дії: комірка<ОбʼєктДії> = пусто;

        ціль результат_отримання_з_середовища = отримати_з_середовища(середовище_секції, назва);
        якщо результат_отримання_з_середовища.знайдено == так {
          ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
          якщо субʼєкт.вид == ВидСубʼєктаДія {
            обʼєкт_дії = субʼєкт.дані як комірка<ОбʼєктДії>;

            якщо обʼєкт_дії.параметри.довжина != дані.кількість_параметрів {
              ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Кількість параметрів не співпадає");
              вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
            }

            змінна пх: позитивне = 0;
            поки пх < дані.кількість_параметрів {
              ціль асд_параметр = дані.параметри[пх];
              ціль параметр = виділити<Параметр>();
              параметр.назва = асд_параметр.ідентифікатор.значення;
              ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище_секції, асд_параметр.тип);
              якщо результат_компіляції_як_типу.помилка != пусто {
                вернути РезультатКомпіляціїТілаСекції { результат_компіляції_як_типу.помилка };
              }
              параметр.тип = результат_компіляції_як_типу.тип;
              ціль попередній_параметр = обʼєкт_дії.параметри.дані[пх];
              якщо strcmp(параметр.назва, попередній_параметр.назва) != 0 {
                ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Назва параметра не співпадає");
                вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
              }
              якщо перевірити_тип(К, параметр.тип, попередній_параметр.тип) == ні {
                ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Тип параметра не співпадає");
                вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
              }
              пх = пх + 1;
            }

            змінна тип_результату: Тип;

            якщо дані.тип_результату == пусто {
              тип_результату = К.тип_ніщо;
            } інакше {
              ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище_секції, дані.тип_результату);
              якщо результат_компіляції_як_типу.помилка != пусто {
                вернути РезультатКомпіляціїТілаСекції { результат_компіляції_як_типу.помилка };
              }
              тип_результату = результат_компіляції_як_типу.тип;
            }

            якщо перевірити_тип(К, тип_результату, обʼєкт_дії.тип_результату) == ні {
              ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Тип результату не співпадає");
              вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
            }
          } інакше {
            ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт вже визначено");
            вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
          }
        } інакше {
          обʼєкт_дії = виділити<ОбʼєктДії>();
          обʼєкт_дії.назва = назва;
          обʼєкт_дії.параметри = виділити_список<комірка<Параметр>>();

          обʼєкт_дії.обʼєкт_типу_дії = виділити<ОбʼєктТипуДії>();
          обʼєкт_дії.обʼєкт_типу_дії.параметри = обʼєкт_дії.параметри;

          ціль список_лтипів_параметрів = виділити_список<комірка<ЛТип>>();
          // відкласти звільнити_список<комірка<ЛТип>>(список_лтипів_параметрів);

          змінна пх: позитивне = 0;
          поки пх < дані.кількість_параметрів {
            ціль асд_параметр = дані.параметри[пх];
            ціль параметр = виділити<Параметр>();
            параметр.назва = асд_параметр.ідентифікатор.значення;
            ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище_секції, асд_параметр.тип);
            якщо результат_компіляції_як_типу.помилка != пусто {
              вернути РезультатКомпіляціїТілаСекції { результат_компіляції_як_типу.помилка };
            }
            параметр.тип = результат_компіляції_як_типу.тип;
            додати_до_списку<комірка<Параметр>>(обʼєкт_дії.параметри, параметр);
            додати_до_списку<комірка<ЛТип>>(список_лтипів_параметрів, отримати_ЛТип(К, результат_компіляції_як_типу.тип));
            пх = пх + 1;
          }

          якщо дані.тип_результату == пусто {
            обʼєкт_дії.тип_результату = К.тип_ніщо;
          } інакше {
            ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище_секції, дані.тип_результату);
            якщо результат_компіляції_як_типу.помилка != пусто {
              вернути РезультатКомпіляціїТілаСекції { результат_компіляції_як_типу.помилка };
            }
            обʼєкт_дії.тип_результату = результат_компіляції_як_типу.тип;
          }
          обʼєкт_дії.обʼєкт_типу_дії.тип_результату = обʼєкт_дії.тип_результату;

          змінна лінкування: позитивне = 0;
          якщо дані.видимість == АСДВидимістьЗовнішня {
            лінкування = LLVM::LINKAGE_EXTERNAL;
          } інакше якщо дані.видимість == АСДВидимістьМісцева {
            лінкування = LLVM::LINKAGE_DSO_LOCAL;
          } інакше {
            лінкування = LLVM::LINKAGE_INTERNAL;
          }

          якщо strcmp(обʼєкт_дії.назва, ю8"main") == 0 {
            лінкування = LLVM::LINKAGE_EXTERNAL;
          }

          ціль лф = LLVM::function(К.Л, лінкування, обʼєкт_дії.назва, отримати_ЛТип(К, обʼєкт_дії.тип_результату), список_лтипів_параметрів.довжина, список_лтипів_параметрів.дані, ні);
          обʼєкт_дії.л_функція = лф;

          обʼєкт_дії.обʼєкт_типу_дії.л_тип_функції = LLVM::type_of_function(К.Л, лф);

          змінити_в_середовищі(середовище_секції, обʼєкт_дії.назва, Субʼєкт { ВидСубʼєктаДія, обʼєкт_дії });
        }

        якщо дані.тіло != пусто {
          ціль середовище_дії = створити_середовище(середовище_секції);

          ціль л_блок_алокацій = LLVM::створити_блок(К.Л, обʼєкт_дії.л_функція, ю8"alloca");
          ціль л_блок = LLVM::створити_блок(К.Л, обʼєкт_дії.л_функція, ю8"entry");
          ціль вихідний_л_блок = LLVM::створити_блок(К.Л, обʼєкт_дії.л_функція, ю8"exit");

          змінна пх: позитивне = 0;
          поки пх < обʼєкт_дії.параметри.довжина {
            ціль параметр = обʼєкт_дії.параметри.дані[пх];
            ціль arg = LLVM::function_arg(К.Л, обʼєкт_дії.л_функція, пх);
            ціль л_значення = LLVM::alloca(К.Л, л_блок_алокацій, параметр.назва, отримати_ЛТип(К, параметр.тип));
            LLVM::store(К.Л, л_блок_алокацій, arg, л_значення);
            ціль обʼєкт_цілі = виділити<ОбʼєктЦілі>();
            обʼєкт_цілі.назва = параметр.назва;
            обʼєкт_цілі.тип = параметр.тип;
            обʼєкт_цілі.л_значення = л_значення;
            змінити_в_середовищі(середовище_дії, параметр.назва, Субʼєкт { ВидСубʼєктаЦіль, обʼєкт_цілі });
            пх = пх + 1;
          }

          ціль результат_компіляції_тіла_дії = скомпілювати_блок(К, обʼєкт_дії, середовище_дії, л_блок_алокацій, л_блок, вихідний_л_блок, дані.тіло);
          якщо результат_компіляції_тіла_дії.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { результат_компіляції_тіла_дії.помилка };
          }

          LLVM::br(К.Л, л_блок_алокацій, л_блок);
          LLVM::ret(К.Л, вихідний_л_блок, пусто);
        }
      } інакше якщо асд_значення.вид == АСДВидСтворитиСтруктуру {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСтруктуру>;
        ціль назва = дані.ідентифікатор.значення;

        змінна обʼєкт_структури: комірка<ОбʼєктСтруктури> = пусто;

        ціль результат_отримання_з_середовища = отримати_з_середовища(середовище_секції, назва);
        якщо результат_отримання_з_середовища.знайдено == так {
          ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
          якщо субʼєкт.вид == ВидСубʼєктаСтруктура {
            обʼєкт_структури = субʼєкт.дані як комірка<ОбʼєктСтруктури>;
            якщо обʼєкт_структури.параметри.довжина != 0 {
              ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Структура вже визначена");
              вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
            }
          } інакше {
            ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт вже визначено");
            вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
          }
        } інакше {
          обʼєкт_структури = виділити<ОбʼєктСтруктури>();
          обʼєкт_структури.назва = назва;
          обʼєкт_структури.параметри = виділити_список<комірка<Параметр>>();
          обʼєкт_структури.л_тип = LLVM::struct(К.Л, назва);

          змінити_в_середовищі(середовище_секції, назва, Субʼєкт { ВидСубʼєктаСтруктура, обʼєкт_структури });
        }

        якщо дані.кількість_параметрів != 0 {
          ціль список_лтипів_параметрів = виділити_список<комірка<ЛТип>>();
          // відкласти звільнити_список<комірка<ЛТип>>(список_лтипів_параметрів);

          змінна пх: позитивне = 0;
          поки пх < дані.кількість_параметрів {
            ціль асд_параметр = дані.параметри[пх];
            ціль параметр = виділити<Параметр>();
            параметр.назва = асд_параметр.ідентифікатор.значення;
            ціль результат_компіляції_як_типу = скомпілювати_асд_значення_як_тип(К, середовище_секції, асд_параметр.тип);
            якщо результат_компіляції_як_типу.помилка != пусто {
              вернути РезультатКомпіляціїТілаСекції { результат_компіляції_як_типу.помилка };
            }
            параметр.тип = результат_компіляції_як_типу.тип;
            додати_до_списку<комірка<Параметр>>(обʼєкт_структури.параметри, параметр);
            додати_до_списку<комірка<ЛТип>>(список_лтипів_параметрів, отримати_ЛТип(К, результат_компіляції_як_типу.тип));
            пх = пх + 1;
          }

          LLVM::struct_set_fields(К.Л, обʼєкт_структури.л_тип, список_лтипів_параметрів.довжина, список_лтипів_параметрів.дані);
        }
      } інакше {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати тіло секції");
        вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
      }
      х = х + 1;
    }

    вернути РезультатКомпіляціїТілаСекції { пусто };
  }
}