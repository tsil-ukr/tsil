взяти визначення К;

секція цк {
  місцева дія скомпілювати_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначення {
    змінна результат: РезультатЗначення;
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      результат = скомпілювати_значення_звернутись(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      результат = скомпілювати_значення_отримати(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтриматиЗіСекції {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтриматиЗіСекції>;
      результат = скомпілювати_значення_отримати_зі_секції(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      результат = скомпілювати_значення_виконати(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконатиШаблон {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконатиШаблон>;
      результат = скомпілювати_значення_виконати_шаблон(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидСтруктура {
      ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
      результат = скомпілювати_створити_структуру(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидДія {
      ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
      результат = скомпілювати_створити_дію(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидСтворитиСинонім {
      ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСинонім>;
      результат = скомпілювати_створити_синонім(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОперація {
      ціль дані = асд_значення.дані як комірка<АСДДаніОперація>;
      результат = скомпілювати_значення_операція(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЗначенняЧисло {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняЧисло>;
      результат = скомпілювати_значення_число(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані, ОчікуванийТипЧислаАВТО);
    } інакше якщо асд_значення.вид == АСДВидЗначенняТекст {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняТекст>;
      результат = скомпілювати_значення_текст(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЯк {
      ціль дані = асд_значення.дані як комірка<АСДДаніЯк>;
      результат = скомпілювати_як(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЯк {
      ціль дані = асд_значення.дані як комірка<АСДДаніЯк>;
      результат = скомпілювати_як(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше {
      біб::друк_позитивне(асд_значення.вид);
      ціль помилка = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення");
      вернути РезультатЗначення { Значення {}, помилка };
    }

    якщо результат.помилка == пусто {
      якщо результат.значення.вид == ВидЗначенняОК {
        ціль ок = результат.значення.к;
        якщо ок.вид == ВидОКСинонім {
          ціль син = ок.дані як комірка<Синонім>;
          вернути скомпілювати_значення(К, блок, пусто, син.зовнішнє_середовище, син.асд_значення);
        }
      }
    }

    вернути результат;
  }

  місцева дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначенняТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняТип { Тип {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОВ {
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням типу");
      вернути РезультатЗначенняТип { Тип {}, створити_помилку_компіляції };
    }
    ціль обʼєкт_компіляції = значення.к;
    якщо обʼєкт_компіляції.вид != ВидОКТип {
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є типом");
      вернути РезультатЗначенняТип { Тип {}, створити_помилку_компіляції };
    }
    ціль комірка_типу = обʼєкт_компіляції.дані як комірка<Тип>;
    ціль тип = вміст(комірка_типу);
    вернути РезультатЗначенняТип { тип, пусто };
  }

  місцева дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, load: логічне): РезультатЗначенняЗначення {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОК {
      ціль ок = значення.к;
      якщо ок.вид == ВидОКЦіль {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль ц = ок.дані як комірка<Ціль>;
        якщо load == так {
          ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, ц.тип), ц.л_значення_alloca);
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, л_значення }, пусто };
        } інакше {
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, ц.л_значення_alloca }, пусто };
        }
      } інакше якщо ок.вид == ВидОКДія {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль д = ок.дані як комірка<Дія>;
        ціль тип = зробити_тип_з_дії(К, д);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { тип, д.л_функція як комірка<ЛЗначення> }, пусто };
      }
      біб::друк_позитивне(ок.вид);
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням");
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
    }
    якщо load == так {
      якщо значення.в.unloaded == так {
        ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, значення.в.тип), значення.в.л_значення);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { значення.в.тип, л_значення, unloaded = ні }, пусто };
      }
    }
    вернути РезультатЗначенняЗначення { значення.в, пусто };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидСтворитиЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиЦіль>;
        ціль помилка_компіляції = скомпілювати_створити_ціль(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
        ціль помилка_компіляції = скомпілювати_змінити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль результат_компіляції_виконання = скомпілювати_значення_як_значення(К, блок, середовище, асд_значення, так);
        якщо результат_компіляції_виконання.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_виконання.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль помилка_компіляції = скомпілювати_перевизначити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      }

      х = х + 1;
    }
    LLVM::br(К.Л, блок.block, блок.exit_block);
    вернути РезультатКомпіляціїБлоку { пусто };
  }

  місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидДія {
        ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
        ціль результат_створення_дії = скомпілювати_створити_дію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо результат_створення_дії.помилка != пусто {
          вернути РезультатКомпіляціїТілаСекції { результат_створення_дії.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидСтруктура {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
        ціль назва = дані.ідентифікатор.значення;
        ціль результат_отримання_з_середовища = отримати_з_локального_середовища(середовище_секції, назва);
        якщо результат_отримання_з_середовища.знайдено == так {
          ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
          якщо субʼєкт.вид == ВидОКТип {
            ціль тип = субʼєкт.дані як комірка<Тип>;
            якщо тип.вид == ВидТипуСтруктура {
              ціль дані_типу_структури = тип.дані як комірка<ДаніТипуСтруктура>;
              якщо дані_типу_структури.параметри.довжина == 0 {
                ціль помилка_заповнення = заповнити_дані_типу_структури(К, середовище_секції, дані_типу_структури, дані);
                якщо помилка_заповнення != пусто {
                  вернути РезультатКомпіляціїТілаСекції { помилка_заповнення };
                }
              } інакше {
                ціль помилка_компіляції = створити_помилку_компіляції_субʼєкт_вже_визначено(асд_значення.місцезнаходження, назва);
                вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
              }
            } інакше {
              ціль помилка_компіляції = створити_помилку_компіляції_субʼєкт_вже_визначено(асд_значення.місцезнаходження, назва);
              вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
            }
          } інакше {
            ціль помилка_компіляції = створити_помилку_компіляції_субʼєкт_вже_визначено(асд_значення.місцезнаходження, назва);
            вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
          }
        } інакше {
          ціль результат_створення_структури = скомпілювати_створити_структуру(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
          якщо результат_створення_структури.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { результат_створення_структури.помилка };
          }
          змінити_в_середовищі(середовище_секції, назва, результат_створення_структури.значення.к);
        }
      } інакше якщо асд_значення.вид == АСДВидСтворитиШаблон {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиШаблон>;
        ціль назва = дані.ідентифікатор.значення;
        ціль результат_отримання_з_середовища = отримати_з_локального_середовища(середовище_секції, назва);
        якщо результат_отримання_з_середовища.знайдено == так {
          ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
          якщо субʼєкт.вид == ВидОКШаблон {
            ціль шаблон = субʼєкт.дані як комірка<Шаблон>;
            якщо дані.значення.вид == АСДВидСтруктура {
              // потім: заповнити параметри структур готових значень
            }
          }
          ціль помилка_компіляції = створити_помилку_компіляції_субʼєкт_вже_визначено(асд_значення.місцезнаходження, назва);
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        } інакше {
          якщо дані.значення.вид == АСДВидСтруктура {
            ціль дані_значення = дані.значення.дані як комірка<АСДДаніСтруктура>;
            якщо дані_значення.кількість_параметрів == 0 {
              // потім: дозволити створювати шаблон структури без властивостей і заповнювати пізніше
              ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Неможливо створити шаблон для структури без властивостей");
              вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
            }
          }
          якщо дані.значення.вид == АСДВидДія {
            ціль дані_значення = дані.значення.дані як комірка<АСДДаніДія>;
            якщо дані_значення.видимість != АСДВидимістьВнутрішня {
              ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Шаблон дії може мати лише внутрішню видимість");
              вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
            }
          }
          ціль результат_створення_шаблону = скомпілювати_створити_шаблон(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
          якщо результат_створення_шаблону.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { результат_створення_шаблону.помилка };
          }
          змінити_в_середовищі(середовище_секції, назва, результат_створення_шаблону.значення.к);
        }
      } інакше якщо асд_значення.вид == АСДВидСтворитиСинонім {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСинонім>;
        ціль результат_створення_синоніма = скомпілювати_створити_синонім(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо результат_створення_синоніма.помилка != пусто {
          вернути РезультатКомпіляціїТілаСекції { результат_створення_синоніма.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидСтворитиСекцію {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСекцію>;
        ціль результат_створення_секції = скомпілювати_створити_секцію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо результат_створення_секції.помилка != пусто {
          вернути РезультатКомпіляціїТілаСекції { результат_створення_секції.помилка };
        }
      }

      х = х + 1;
    }
    вернути РезультатКомпіляціїТілаСекції { пусто };
  }
}