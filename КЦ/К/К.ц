взяти визначення К;

секція цк {
  місцева дія скомпілювати_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_виконання_шаблону: комірка<ІнформаціяВиконанняШаблону>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначення {
    змінна результат: РезультатЗначення;
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      результат = скомпілювати_значення_звернутись(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      результат = скомпілювати_значення_отримати(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтриматиЗіСекції {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтриматиЗіСекції>;
      результат = скомпілювати_значення_отримати_зі_секції(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      результат = скомпілювати_значення_виконати(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконатиШаблон {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконатиШаблон>;
      результат = скомпілювати_значення_виконати_шаблон(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидСтруктура {
      ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
      результат = скомпілювати_структуру(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидДія {
      ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
      ціль результат_компіляції_дії = скомпілювати_дію(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
      якщо результат_компіляції_дії.помилка == пусто {
        ціль дія_ = результат_компіляції_дії.дія_;
        ціль тип = Тип { ВидТипуДія, дані = дія_.дані_типу_дія };
        результат.значення = Значення { ВидЗначенняОВ, в = ОбʼєктВиконання { тип = тип, л_значення = дія_.л_функція як комірка<LLVM::Value>, unloaded = ні } };
        результат.помилка = пусто;
      } інакше {
        результат.помилка = результат_компіляції_дії.помилка;
      }
    } інакше якщо асд_значення.вид == АСДВидСинонім {
      ціль дані = асд_значення.дані як комірка<АСДДаніСинонім>;
      результат = скомпілювати_синонім(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОперація {
      ціль дані = асд_значення.дані як комірка<АСДДаніОперація>;
      результат = скомпілювати_значення_операція(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЗначенняЧисло {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняЧисло>;
      результат = скомпілювати_значення_число(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані, ОчікуванийТипЧислаАВТО);
    } інакше якщо асд_значення.вид == АСДВидЗначенняТекст {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняТекст>;
      результат = скомпілювати_значення_текст(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЯк {
      ціль дані = асд_значення.дані як комірка<АСДДаніЯк>;
      результат = скомпілювати_як(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЯк {
      ціль дані = асд_значення.дані як комірка<АСДДаніЯк>;
      результат = скомпілювати_як(К, блок, інформація_виконання_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше {
      біб::друк_позитивне(асд_значення.вид);
      ціль помилка = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення");
      вернути РезультатЗначення { Значення {}, помилка };
    }

    якщо результат.помилка == пусто {
      якщо результат.значення.вид == ВидЗначенняОК {
        ціль ок = результат.значення.к;
        якщо ок.вид == ВидОКСинонім {
          ціль син = ок.дані як комірка<Синонім>;
          вернути скомпілювати_значення(К, блок, пусто, син.зовнішнє_середовище, син.асд_значення);
        }
      }
    }

    вернути результат;
  }

  дія перевірити_чи_тип_є_повним(К: комірка<Компілятор>, тип: Тип): логічне {
    якщо тип.вид == ВидТипуСтруктура {
      ціль дані_типу_структура = тип.дані як комірка<ДаніТипуСтруктура>;
      якщо дані_типу_структура.параметри.довжина == 0 {
        вернути ні;
      }
    }
    вернути так;
  }

  місцева дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначенняТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняТип { Тип {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОВ {
      ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням типу");
      вернути РезультатЗначенняТип { помилка = помилка_компіляції };
    }
    ціль обʼєкт_компіляції = значення.к;
    якщо обʼєкт_компіляції.вид != ВидОКТип {
      ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є типом");
      вернути РезультатЗначенняТип { помилка = помилка_компіляції };
    }
    ціль комірка_типу = обʼєкт_компіляції.дані як комірка<Тип>;
    якщо перевірити_чи_тип_є_повним(К, вміст(комірка_типу)) == ні {
      ціль помилка_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Тип не є повним");
      вернути РезультатЗначенняТип { помилка = помилка_компіляції };
    }
    ціль тип = вміст(комірка_типу);
    вернути РезультатЗначенняТип { тип, пусто };
  }

  місцева дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, load: логічне): РезультатЗначенняЗначення {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОК {
      ціль ок = значення.к;
      якщо ок.вид == ВидОКЦіль {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль ц = ок.дані як комірка<Ціль>;
        якщо load == так {
          ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, ц.тип), ц.llvm_alloca_value);
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, л_значення }, пусто };
        } інакше {
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, ц.llvm_alloca_value }, пусто };
        }
      } інакше якщо ок.вид == ВидОКДія {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль д = ок.дані як комірка<Дія>;
        ціль тип = зробити_тип_з_дії(К, д);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { тип, д.л_функція як комірка<LLVM::Value> }, пусто };
      }
      біб::друк_позитивне(ок.вид);
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням");
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
    }
    якщо load == так {
      якщо значення.в.unloaded == так {
        ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, значення.в.тип), значення.в.л_значення);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { значення.в.тип, л_значення, unloaded = ні }, пусто };
      }
    }
    вернути РезультатЗначенняЗначення { значення.в, пусто };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніЦіль>;
        ціль помилка_компіляції = скомпілювати_визначити_ціль(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
        ціль помилка_компіляції = скомпілювати_змінити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль результат_компіляції_виконання = скомпілювати_значення_як_значення(К, блок, середовище, асд_значення, так);
        якщо результат_компіляції_виконання.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_виконання.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль помилка_компіляції = скомпілювати_перевизначити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      }

      х = х + 1;
    }
    LLVM::br(К.Л, блок.block, блок.exit_block);
    вернути РезультатКомпіляціїБлоку { пусто };
  }

  місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидДія {
        ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
        ціль помилка_компіляції = скомпілювати_визначити_дію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСтруктура {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
        ціль помилка_компіляції = скомпілювати_визначити_структуру(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидШаблон {
        ціль дані = асд_значення.дані як комірка<АСДДаніШаблон>;
        ціль помилка_компіляції = скомпілювати_визначити_шаблон(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСинонім {
        ціль дані = асд_значення.дані як комірка<АСДДаніСинонім>;
        ціль помилка_компіляції = скомпілювати_визначити_синонім(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСекція {
        ціль дані = асд_значення.дані як комірка<АСДДаніСекція>;
        ціль помилка_компіляції = скомпілювати_визначити_секцію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      }

      х = х + 1;
    }
    вернути РезультатКомпіляціїТілаСекції { пусто };
  }
}