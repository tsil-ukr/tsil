взяти визначення К;

секція ц {
  місцева дія скомпілювати_значення(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, асд_значення: комірка<АСДЗначення>, очікуваний_тип: комірка<ОбʼєктТипу>): Результат {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      вернути скомпілювати_звернутись(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЗначенняЧисло {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняЧисло>;
      вернути скомпілювати_число(К, інформація_середовища, асд_значення.місцезнаходження, дані, очікуваний_тип);
    } інакше якщо асд_значення.вид == АСДВидЗначенняОбʼєкт {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняОбʼєкт>;
      вернути скомпілювати_обʼєкт(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЗначенняБезтиповийОбʼєкт {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняБезтиповийОбʼєкт>;
      вернути скомпілювати_безтиповий_обʼєкт(К, інформація_середовища, асд_значення.місцезнаходження, дані, очікуваний_тип);
    } інакше якщо асд_значення.вид == АСДВидОперація {
      ціль дані = асд_значення.дані як комірка<АСДДаніОперація>;
      вернути скомпілювати_операцію(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      вернути скомпілювати_виконати(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконатиШаблон {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконатиШаблон>;
      вернути скомпілювати_виконати_шаблон(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      вернути скомпілювати_отримати(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтриматиЗіСекції {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтриматиЗіСекції>;
      вернути скомпілювати_отримати_зі_секції(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЯк {
      ціль дані = асд_значення.дані як комірка<АСДДаніЯк>;
      вернути скомпілювати_як(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидДія {
      ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
      вернути скомпілювати_дію(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидСтруктура {
      ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
      вернути скомпілювати_структуру(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    }
    біб::друк_позитивне(асд_значення.вид);
    ціль помилка_компіляції = виділити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, асд_значення: комірка<АСДЗначення>): РезультатЯкТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, інформація_середовища, асд_значення, пусто);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЯкТип { помилка = результат_компіляції_значення.помилка };
    }
    якщо результат_компіляції_значення.обʼєкт.вид != ВидОбʼєктаТипу {
      ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Значення не є типом");
      вернути РезультатЯкТип { помилка = помилка_компіляції };
    }
    ціль обʼєкт = результат_компіляції_значення.обʼєкт;
    вернути РезультатЯкТип { обʼєкт_типу = обʼєкт.дані як комірка<ОбʼєктТипу>, помилка = пусто };
  }

  місцева дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, асд_значення: комірка<АСДЗначення>, очікуваний_тип: комірка<ОбʼєктТипу>): РезультатЯкЗначення {
    ціль результат_компіляції_значення = скомпілювати_значення(К, інформація_середовища, асд_значення, очікуваний_тип);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЯкЗначення { помилка = результат_компіляції_значення.помилка };
    }
    якщо результат_компіляції_значення.обʼєкт.вид == ВидОбʼєктаНезавантаженогоЗначення {
      ціль обʼєкт = результат_компіляції_значення.обʼєкт;
      ціль обʼєкт_незавантаженого_значення = обʼєкт.дані як ОбʼєктНезавантаженогоЗначення;
      ціль тип = обʼєкт_незавантаженого_значення.тип;
      ціль loaded_llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
      ціль обʼєкт_значення = ОбʼєктЗначення { тип, loaded_llvm_value };
      вернути РезультатЯкЗначення { обʼєкт_значення, помилка = пусто };
    }
    якщо результат_компіляції_значення.обʼєкт.вид == ВидОбʼєктаДії {
      ціль обʼєкт = результат_компіляції_значення.обʼєкт;
      ціль обʼєкт_дії = обʼєкт.дані як комірка<ОбʼєктДії>;
      ціль обʼєкт_значення = ОбʼєктЗначення { обʼєкт_дії.тип, обʼєкт_дії.llvm_function як комірка<LLVM::Value> };
      вернути РезультатЯкЗначення { обʼєкт_значення, помилка = пусто };
    }
    якщо результат_компіляції_значення.обʼєкт.вид != ВидОбʼєктаЗначення {
      ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Значення не є значенням");
      вернути РезультатЯкЗначення { помилка = помилка_компіляції };
    }
    ціль обʼєкт = результат_компіляції_значення.обʼєкт;
    вернути РезультатЯкЗначення { обʼєкт.дані як ОбʼєктЗначення, помилка = пусто };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, llvm_exit_block: комірка<LLVM::BasicBlock>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
      якщо асд_значення.вид == АСДВидЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніЦіль>;
        ціль помилка_компіляції = скомпілювати_визначити_ціль(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
        ціль помилка_компіляції = скомпілювати_змінити(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль результат_компіляції_виконання = скомпілювати_значення_як_значення(К, інформація_середовища, асд_значення, пусто);
        якщо результат_компіляції_виконання.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_виконання.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль помилка_компіляції = скомпілювати_перевизначити(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидПоки {
        ціль дані = асд_значення.дані як комірка<АСДДаніПоки>;
        ціль результат_компіляції_поки = скомпілювати_поки(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо результат_компіляції_поки.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { помилка = результат_компіляції_поки.помилка };
        }
        інформація_середовища.llvm_block = результат_компіляції_поки.new_llvm_block;
      } інакше якщо асд_значення.вид == АСДВидЯкщо {
        ціль дані = асд_значення.дані як комірка<АСДДаніЯкщо>;
        ціль результат_компіляції_якщо = скомпілювати_якщо(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо результат_компіляції_якщо.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { помилка = результат_компіляції_якщо.помилка };
        }
        інформація_середовища.llvm_block = результат_компіляції_якщо.new_llvm_block;
      } інакше якщо асд_значення.вид == АСДВидСинонім {
        ціль дані = асд_значення.дані як комірка<АСДДаніСинонім>;
        ціль помилка_компіляції = скомпілювати_визначити_синонім(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      }
      х = х + 1;
    }
    LLVM::br(К.L, інформація_середовища.llvm_block, llvm_exit_block);
    вернути РезультатКомпіляціїБлоку { помилка = пусто };
  }

  місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
      якщо асд_значення.вид == АСДВидДія {
        ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
        ціль помилка_компіляції = скомпілювати_визначити_дію(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСтруктура {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
        ціль помилка_компіляції = скомпілювати_визначити_структуру(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидШаблон {
        ціль дані = асд_значення.дані як комірка<АСДДаніШаблон>;
        ціль помилка_компіляції = скомпілювати_визначити_шаблон(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСинонім {
        ціль дані = асд_значення.дані як комірка<АСДДаніСинонім>;
        ціль помилка_компіляції = скомпілювати_визначити_синонім(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСекція {
        ціль дані = асд_значення.дані як комірка<АСДДаніСекція>;
        ціль помилка_компіляції = скомпілювати_визначити_секцію(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      }
      х = х + 1;
    }
    вернути РезультатКомпіляціїТілаСекції { помилка = пусто };
  }
}