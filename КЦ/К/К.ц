взяти визначення К;

секція ц {
  місцева дія скомпілювати_значення(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, асд_значення: адреса<АСДЗначення>, очікуваний_тип: адреса<ОбʼєктТипу>): Результат {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як адреса<АСДДаніЗвернутись>;
      вернути скомпілювати_звернутись(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЗначенняЧисло {
      ціль дані = асд_значення.дані як адреса<АСДДаніЗначенняЧисло>;
      вернути скомпілювати_число(К, інформація_середовища, асд_значення.місцезнаходження, дані, очікуваний_тип);
    } інакше якщо асд_значення.вид == АСДВидЗначенняТекст {
      ціль дані = асд_значення.дані як адреса<АСДДаніЗначенняТекст>;
      вернути скомпілювати_текст(К, інформація_середовища, асд_значення.місцезнаходження, дані, очікуваний_тип);
    } інакше якщо асд_значення.вид == АСДВидЗначенняОбʼєкт {
      ціль дані = асд_значення.дані як адреса<АСДДаніЗначенняОбʼєкт>;
      вернути скомпілювати_обʼєкт(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидЗначенняБезтиповийОбʼєкт {
      ціль дані = асд_значення.дані як адреса<АСДДаніЗначенняБезтиповийОбʼєкт>;
      вернути скомпілювати_безтиповий_обʼєкт(К, інформація_середовища, асд_значення.місцезнаходження, дані, очікуваний_тип);
    } інакше якщо асд_значення.вид == АСДВидОперація {
      ціль дані = асд_значення.дані як адреса<АСДДаніОперація>;
      вернути скомпілювати_операцію(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як адреса<АСДДаніВиконати>;
      вернути скомпілювати_виконати(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконатиШаблон {
      ціль дані = асд_значення.дані як адреса<АСДДаніВиконатиШаблон>;
      вернути скомпілювати_виконати_шаблон(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як адреса<АСДДаніОтримати>;
      вернути скомпілювати_отримати(К, інформація_середовища, асд_значення.місцезнаходження, дані, очікуваний_тип);
    } інакше якщо асд_значення.вид == АСДВидОтриматиЗіСекції {
      ціль дані = асд_значення.дані як адреса<АСДДаніОтриматиЗіСекції>;
      вернути скомпілювати_отримати_зі_секції(К, інформація_середовища, асд_значення.місцезнаходження, дані, очікуваний_тип);
    } інакше якщо асд_значення.вид == АСДВидОтриматиЗаПозицією {
      ціль дані = асд_значення.дані як адреса<АСДДаніОтриматиЗаПозицією>;
      вернути скомпілювати_отримати_за_позицією(К, інформація_середовища, асд_значення.місцезнаходження, дані, очікуваний_тип);
    } інакше якщо асд_значення.вид == АСДВидЯк {
      ціль дані = асд_значення.дані як адреса<АСДДаніЯк>;
      вернути скомпілювати_як(К, інформація_середовища, асд_значення.місцезнаходження, дані, очікуваний_тип);
    } інакше якщо асд_значення.вид == АСДВидДія {
      ціль дані = асд_значення.дані як адреса<АСДДаніДія>;
      вернути скомпілювати_дію(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидСтруктура {
      ціль дані = асд_значення.дані як адреса<АСДДаніСтруктура>;
      вернути скомпілювати_структуру(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидПерелік {
      ціль дані = асд_значення.дані як адреса<АСДДаніПерелік>;
      вернути скомпілювати_перелік(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидСинонім {
      ціль дані = асд_значення.дані як адреса<АСДДаніСинонім>;
      вернути скомпілювати_синонім(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидТипВаріація {
      ціль дані = асд_значення.дані як адреса<АСДДаніТипВаріація>;
      ціль результат_як_тип = скомпілювати_тип_варіація(К, інформація_середовища, асд_значення.місцезнаходження, дані);
      якщо результат_як_тип.помилка != пусто {
        вернути результат_помилка(результат_як_тип.помилка);
      }
      вернути Результат { Обʼєкт { ВидОбʼєктаТип, дані = результат_як_тип.обʼєкт_типу }, помилка = пусто };
    } інакше якщо асд_значення.вид == АСДВидТипДії {
      ціль дані = асд_значення.дані як адреса<АСДДаніТипДії>;
      ціль результат_як_тип = скомпілювати_тип_дії(К, інформація_середовища, асд_значення.місцезнаходження, дані);
      якщо результат_як_тип.помилка != пусто {
        вернути результат_помилка(результат_як_тип.помилка);
      }
      вернути Результат { Обʼєкт { ВидОбʼєктаТип, дані = результат_як_тип.обʼєкт_типу }, помилка = пусто };
    }
    біб::друк_позитивне(асд_значення.вид);
    ціль помилка_компіляції = виділити_помилку_компіляції(асд_значення.місцезнаходження, ю8сі"Не вдалося скомпілювати значення");
    вернути результат_помилка(помилка_компіляції);
  }

  місцева дія отримати_як_тип(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: адреса<Місцезнаходження>, обʼєкт: Обʼєкт, перевірка_на_повність: логічне): РезультатЯкТип {
    якщо обʼєкт.вид != ВидОбʼєктаТип {
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8сі"Значення не є типом");
      вернути РезультатЯкТип { ..., помилка = помилка_компіляції };
    }
    ціль обʼєкт_типу = обʼєкт.дані як адреса<ОбʼєктТипу>;
    якщо перевірка_на_повність == так {
      якщо перевірити_чи_тип_повний(К, обʼєкт_типу) == ні {
        ціль помилка_компіляції = виділити_помилку_компіляції_тип_не_є_повним(місцезнаходження, обʼєкт_типу);
        вернути РезультатЯкТип { ..., помилка = помилка_компіляції };
      }
    }
    вернути РезультатЯкТип { обʼєкт_типу, помилка = пусто };
  }

  місцева дія скомпілювати_значення_як_тип(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, асд_значення: адреса<АСДЗначення>, перевірка_на_повність: логічне): РезультатЯкТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, інформація_середовища, асд_значення, пусто);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЯкТип { ..., помилка = результат_компіляції_значення.помилка };
    }
    вернути отримати_як_тип(К, інформація_середовища, асд_значення.місцезнаходження, результат_компіляції_значення.обʼєкт, перевірка_на_повність);
  }

  місцева дія отримати_як_значення(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, місцезнаходження: адреса<Місцезнаходження>, обʼєкт: Обʼєкт, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатЯкЗначення {
    якщо обʼєкт.вид == ВидОбʼєктаСиреЗначення {
      ціль обʼєкт_сирого_значення = обʼєкт.дані як ОбʼєктСирогоЗначення;
      якщо обʼєкт_сирого_значення є ОбʼєктСирогоЗначення::ЧислоЮ8 {
        ціль обʼєкт_сирого_значення_число_Ю8 = обʼєкт_сирого_значення як ОбʼєктСирогоЗначення::ЧислоЮ8;
        ціль результат_розбору_числа = розібрати_число(К, обʼєкт_сирого_значення_число_Ю8.значення, місцезнаходження, очікуваний_тип);
        якщо результат_розбору_числа.помилка != пусто {
          вернути РезультатЯкЗначення { помилка = результат_розбору_числа.помилка, ... };
        }
        обʼєкт = результат_розбору_числа.обʼєкт;
      } інакше {
        ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8сі"Не втілено");
        вернути РезультатЯкЗначення { помилка = помилка_компіляції, ... };
      }
    }
    якщо обʼєкт.вид == ВидОбʼєктаНезавантаженеЗначення {
      ціль обʼєкт_незавантаженого_значення = обʼєкт.дані як ОбʼєктНезавантаженогоЗначення;
      ціль тип = обʼєкт_незавантаженого_значення.тип;
      ціль loaded_llvm_value = LLVM::load(К.L, інформація_середовища.llvm_block, тип.llvm_type, обʼєкт_незавантаженого_значення.llvm_value);
      ціль обʼєкт_значення = ОбʼєктЗначення { тип, loaded_llvm_value };
      вернути РезультатЯкЗначення { обʼєкт_значення, помилка = пусто };
    }
    якщо обʼєкт.вид == ВидОбʼєктаДія {
      ціль обʼєкт_дії = обʼєкт.дані як адреса<ОбʼєктДії>;
      ціль обʼєкт_значення = ОбʼєктЗначення { обʼєкт_дії.тип, обʼєкт_дії.llvm_function як адреса<LLVM::Value> };
      вернути РезультатЯкЗначення { обʼєкт_значення, помилка = пусто };
    }
    якщо обʼєкт.вид == ВидОбʼєктаТип {
      ціль обʼєкт_типу = обʼєкт.дані як адреса<ОбʼєктТипу>;
      якщо обʼєкт_типу.вид == ВидТипуЕлементПереліку {
        якщо обʼєкт_типу.обʼєкт_типу_структури_елемента_переліку == пусто {
          ціль позиція_елемента = обʼєкт_типу.позиція_елемента_переліку;
          ціль позиція_елемента_як_ю8 = різне::числа::перетворити_позитивне_на_ю8(позиція_елемента);
          ціль обʼєкт_сирого_значення = ОбʼєктСирогоЗначення::ЧислоЮ8 { позиція_елемента_як_ю8 };
          вернути отримати_як_значення(К, інформація_середовища, місцезнаходження, Обʼєкт { ВидОбʼєктаСиреЗначення, дані = обʼєкт_сирого_значення як ОбʼєктСирогоЗначення }, очікуваний_тип);
        }
      }
    }
    якщо обʼєкт.вид != ВидОбʼєктаЗначення {
      ціль помилка_компіляції = виділити_помилку_компіляції(місцезнаходження, ю8сі"Значення не є значенням");
      вернути РезультатЯкЗначення { помилка = помилка_компіляції, ... };
    }
    вернути РезультатЯкЗначення { обʼєкт.дані як ОбʼєктЗначення, помилка = пусто };
  }

  місцева дія скомпілювати_значення_як_значення(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, асд_значення: адреса<АСДЗначення>, очікуваний_тип: адреса<ОбʼєктТипу>): РезультатЯкЗначення {
    змінна ціль результат_компіляції_значення = скомпілювати_значення(К, інформація_середовища, асд_значення, очікуваний_тип);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЯкЗначення { помилка = результат_компіляції_значення.помилка, ... };
    }
    вернути отримати_як_значення(К, інформація_середовища, асд_значення.місцезнаходження, результат_компіляції_значення.обʼєкт, очікуваний_тип);
  }

  місцева дія скомпілювати_блок(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, llvm_exit_block: адреса<LLVM::BasicBlock>, тіло: адреса<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна ціль х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
      якщо асд_значення.вид == АСДВидЦіль {
        ціль дані = асд_значення.дані як адреса<АСДДаніЦіль>;
        якщо дані.видимість != АСДВидимістьВнутрішня {
          ціль помилка_компіляції = виділити_помилку_компіляції(асд_значення.місцезнаходження, ю8сі"Ціль в тілі дії може мати лише внутрішню видимість");
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
        ціль помилка_компіляції = скомпілювати_визначити_ціль_в_тілі_дії(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як адреса<АСДДаніЗмінити>;
        ціль помилка_компіляції = скомпілювати_змінити(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінитиЗаПозицією {
        ціль дані = асд_значення.дані як адреса<АСДДаніЗмінитиЗаПозицією>;
        ціль помилка_компіляції = скомпілювати_змінити_за_позицією(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінитиВСекції {
        ціль дані = асд_значення.дані як адреса<АСДДаніЗмінитиВСекції>;
        ціль помилка_компіляції = скомпілювати_змінити_в_секції(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль результат_компіляції_виконання = скомпілювати_значення_як_значення(К, інформація_середовища, асд_значення, пусто);
        якщо результат_компіляції_виконання.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_виконання.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПерезаписати {
        ціль дані = асд_значення.дані як адреса<АСДДаніПерезаписати>;
        ціль помилка_компіляції = скомпілювати_перезаписати(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидПоки {
        ціль дані = асд_значення.дані як адреса<АСДДаніПоки>;
        ціль результат_компіляції_поки = скомпілювати_поки(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо результат_компіляції_поки.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { помилка = результат_компіляції_поки.помилка };
        }
        інформація_середовища.llvm_block = результат_компіляції_поки.new_llvm_block;
      } інакше якщо асд_значення.вид == АСДВидЯкщо {
        ціль дані = асд_значення.дані як адреса<АСДДаніЯкщо>;
        ціль результат_компіляції_якщо = скомпілювати_якщо(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо результат_компіляції_якщо.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { помилка = результат_компіляції_якщо.помилка };
        }
        інформація_середовища.llvm_block = результат_компіляції_якщо.new_llvm_block;
      } інакше якщо асд_значення.вид == АСДВидСинонім {
        ціль дані = асд_значення.дані як адреса<АСДДаніСинонім>;
        ціль помилка_компіляції = скомпілювати_визначити_синонім(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидВернути {
        ціль дані = асд_значення.дані як адреса<АСДДаніВернути>;
        ціль помилка_компіляції = скомпілювати_вернути(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидМітка {
        ціль дані = асд_значення.дані як адреса<АСДДаніМітка>;
        якщо інформація_середовища.обʼєкт_дії == пусто {
          ціль помилка_компіляції = виділити_помилку_компіляції(асд_значення.місцезнаходження, ю8сі"Визначити мітку можна лише в тілі дії");
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
        змінна ціль п: позитивне = 0;
        поки п < інформація_середовища.обʼєкт_дії.мітки.розмір {
          якщо strcmp(інформація_середовища.обʼєкт_дії.мітки.дані[п].назва, дані.ідентифікатор.значення) == 0 {
            ціль помилка_компіляції = виділити_помилку_компіляції(асд_значення.місцезнаходження, ю8сі"Мітка з такою назвою вже існує");
            вернути РезультатКомпіляціїБлоку { помилка_компіляції };
          }
          п += 1;
        }
        ціль tag_llvm_block = LLVM::block(К.L, інформація_середовища.обʼєкт_дії.llvm_function, дані.ідентифікатор.значення);
        покласти_в_накопичувач<Мітка>(інформація_середовища.обʼєкт_дії.мітки::адреса, Мітка {
          назва = дані.ідентифікатор.значення,
          llvm_block = tag_llvm_block,
          місцезнаходження = асд_значення.місцезнаходження
        });
        LLVM::br(К.L, інформація_середовища.llvm_block, tag_llvm_block);
        інформація_середовища.llvm_block = tag_llvm_block;
      } інакше якщо асд_значення.вид == АСДВидСтрибнути {
        ціль дані = асд_значення.дані як адреса<АСДДаніСтрибнути>;
        якщо інформація_середовища.обʼєкт_дії == пусто {
          ціль помилка_компіляції = виділити_помилку_компіляції(асд_значення.місцезнаходження, ю8сі"Виконати стрибнути можна лише в тілі дії");
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
        ціль llvm_branch_inst = LLVM::br(К.L, інформація_середовища.llvm_block, інформація_середовища.llvm_block);
        покласти_в_накопичувач<Стрибок>(інформація_середовища.обʼєкт_дії.стрибки::адреса, Стрибок {
          назва = дані.ідентифікатор.значення,
          llvm_branch_inst = llvm_branch_inst,
          місцезнаходження = асд_значення.місцезнаходження
        });
      } інакше {
        ціль помилка_компіляції = виділити_помилку_компіляції(асд_значення.місцезнаходження, ю8сі"Не вдалося скомпілювати елемент блоку");
        вернути РезультатКомпіляціїБлоку { помилка_компіляції };
      }
      х = х + 1;
    }
    LLVM::br(К.L, інформація_середовища.llvm_block, llvm_exit_block);
    вернути РезультатКомпіляціїБлоку { помилка = пусто };
  }

  місцева дія скомпілювати_тіло_секції(К: адреса<Компілятор>, інформація_середовища: ІнформаціяСередовища, тіло: адреса<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна ціль х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
      якщо асд_значення.вид == АСДВидЦіль {
        ціль дані = асд_значення.дані як адреса<АСДДаніЦіль>;
        ціль помилка_компіляції = скомпілювати_визначити_ціль_в_тілі_секції(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидДія {
        ціль дані = асд_значення.дані як адреса<АСДДаніДія>;
        ціль помилка_компіляції = скомпілювати_визначити_дію(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСтруктура {
        ціль дані = асд_значення.дані як адреса<АСДДаніСтруктура>;
        ціль помилка_компіляції = скомпілювати_визначити_структуру(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидПерелік {
        ціль дані = асд_значення.дані як адреса<АСДДаніПерелік>;
        ціль помилка_компіляції = скомпілювати_визначити_перелік(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидШаблон {
        ціль дані = асд_значення.дані як адреса<АСДДаніШаблон>;
        ціль помилка_компіляції = скомпілювати_визначити_шаблон(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСинонім {
        ціль дані = асд_значення.дані як адреса<АСДДаніСинонім>;
        ціль помилка_компіляції = скомпілювати_визначити_синонім(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСекція {
        ціль дані = асд_значення.дані як адреса<АСДДаніСекція>;
        ціль помилка_компіляції = скомпілювати_визначити_секцію(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидВзяти {
        ціль дані = асд_значення.дані як адреса<АСДДаніВзяти>;
        ціль помилка_компіляції = скомпілювати_взяти(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше {
        ціль помилка_компіляції = виділити_помилку_компіляції(асд_значення.місцезнаходження, ю8сі"Не вдалося скомпілювати елемент тіла секції");
        вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
      }
      х = х + 1;
    }
    вернути РезультатКомпіляціїТілаСекції { помилка = пусто };
  }
}