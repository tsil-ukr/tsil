взяти визначення К;

секція цк {
  місцева дія скомпілювати_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначення {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      вернути скомпілювати_значення_звернутись(К, блок, інформація_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      вернути скомпілювати_значення_отримати(К, блок, інформація_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      вернути скомпілювати_значення_виконати(К, блок, інформація_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконатиШаблон {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконатиШаблон>;
      вернути скомпілювати_значення_виконати_шаблон(К, блок, інформація_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидСтворитиСтруктуру {
      ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСтруктуру>;
      вернути скомпілювати_створити_структуру(К, блок, інформація_шаблону, середовище, асд_значення.місцезнаходження, дані);
    }

    ціль помилка = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення");
    вернути РезультатЗначення { Значення {}, помилка };
  }

  місцева дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначенняТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняТип { Тип {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОВ {
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням типу");
      вернути РезультатЗначенняТип { Тип {}, створити_помилку_компіляції };
    }
    ціль обʼєкт_компіляції = значення.к;
    якщо обʼєкт_компіляції.вид != ВидОКТип {
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є типом");
      вернути РезультатЗначенняТип { Тип {}, створити_помилку_компіляції };
    }
    ціль комірка_типу = обʼєкт_компіляції.дані як комірка<Тип>;
    ціль тип = вміст(комірка_типу);
    вернути РезультатЗначенняТип { тип, пусто };
  }

  місцева дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, load: логічне): РезультатЗначенняЗначення {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОК {
      ціль ок = значення.к;
      якщо ок.вид == ВидОКЦіль {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль ц = ок.дані як комірка<Ціль>;
        якщо load == так {
          ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, ц.тип), ц.л_значення_alloca);
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, л_значення }, пусто };
        } інакше {
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, ц.л_значення_alloca }, пусто };
        }
      } інакше якщо ок.вид == ВидОКДія {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль д = ок.дані як комірка<Дія>;
        ціль тип = зробити_тип_з_дії(К, д);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { тип, д.л_функція як комірка<ЛЗначення> }, пусто };
      }
      біб::друк_позитивне(ок.вид);
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням");
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
    }
    якщо load == так {
      якщо значення.в.unloaded == так {
        ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, значення.в.тип), значення.в.л_значення);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { значення.в.тип, л_значення, unloaded = ні }, пусто };
      }
    }
    вернути РезультатЗначенняЗначення { значення.в, пусто };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидСтворитиЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиЦіль>;
        ціль помилка_компіляції = скомпілювати_створити_ціль(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
        ціль помилка_компіляції = скомпілювати_змінити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль результат_компіляції_виконання = скомпілювати_значення_як_значення(К, блок, середовище, асд_значення, так);
        якщо результат_компіляції_виконання.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_виконання.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль помилка_компіляції = скомпілювати_перевизначити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      }

      х = х + 1;
    }
    LLVM::br(К.Л, блок.block, блок.exit_block);
    вернути РезультатКомпіляціїБлоку { пусто };
  }

  дія порівняти_ов(ов1: ОбʼєктВиконання, ов2: ОбʼєктВиконання): логічне {
    біб::друк_ю8(ю8"СТОП порівняти_ов");
    вернути ні;
  }

  дія порівняти_тип(тип1: комірка<Тип>, тип2: комірка<Тип>): логічне {
    якщо тип1.вид != тип2.вид {
      вернути ні;
    }
    якщо тип1.вид == ВидТипуНативний {
      ціль тип_тип1 = тип1.дані як комірка<ДаніТипуНативний>;
      ціль тип_тип2 = тип2.дані як комірка<ДаніТипуНативний>;
      якщо тип_тип1 == тип_тип2 {
        вернути так;
      }
    }
    біб::друк_ю8(ю8"СТОП порівняти_ок");
    вернути ні;
  }

  дія порівняти_ок(ок1: ОбʼєктКомпіляції, ок2: ОбʼєктКомпіляції): логічне {
    якщо ок1.вид != ок2.вид {
      вернути ні;
    }
    якщо ок1.вид == ВидОКТип {
      ціль тип_ок1 = ок1.дані як комірка<Тип>;
      ціль тип_ок2 = ок2.дані як комірка<Тип>;
      вернути порівняти_тип(тип_ок1, тип_ок2);
    }
    біб::друк_ю8(ю8"СТОП порівняти_ок");
    вернути ні;
  }

  дія порівняти_значення(з1: Значення, з2: Значення): логічне {
    якщо з1.вид != з2.вид {
      вернути ні;
    }
    якщо з1.вид == ВидЗначенняОВ {
      вернути порівняти_ов(з1.в, з2.в);
    }
    якщо з1.вид == ВидЗначенняОК {
      вернути порівняти_ок(з1.к, з2.к);
    }
    біб::друк_ю8(ю8"СТОП порівняти_значення");
    вернути ні;
  }

  дія порівняти_списки_значень(с1: комірка<список<Значення>>, с2: комірка<список<Значення>>): логічне {
    якщо с1.довжина != с2.довжина {
      вернути ні;
    }
    змінна х: позитивне = 0;
    поки х < с1.довжина {
      якщо порівняти_значення(с1.дані[х], с2.дані[х]) == ні {
        вернути ні;
      }
      х = х + 1;
    }
    вернути так;
  }

  місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидСтворитиДію {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиДію>;
        ціль результат_створення_дії = скомпілювати_створити_дію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо результат_створення_дії.помилка != пусто {
          вернути РезультатКомпіляціїТілаСекції { результат_створення_дії.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидСтворитиСтруктуру {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСтруктуру>;
        ціль результат_створення_структури = скомпілювати_створити_структуру(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
        якщо результат_створення_структури.помилка != пусто {
          вернути РезультатКомпіляціїТілаСекції { результат_створення_структури.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидСтворитиШаблон {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиШаблон>;

        ціль назва = дані.ідентифікатор.значення;

        ціль ш = виділити<Шаблон>();
        ш.зовнішнє_середовище = середовище_секції;
        ш.параметри = виділити_список<памʼять<п8>>();
        ш.асд_значення = дані.значення;
        ш.карта_готових_значень = виділити_карту<комірка<список<Значення>>, Значення>(порівняти_списки_значень);

        змінна пх: позитивне = 0;
        поки пх < дані.кількість_параметрів {
          ціль асд_ідентифікатор = дані.параметри[пх];
          додати_до_списку<памʼять<п8>>(ш.параметри, асд_ідентифікатор.значення);
          пх = пх + 1;
        }

        змінити_в_середовищі(середовище_секції, назва, ОбʼєктКомпіляції { ВидОКШаблон, ш });
      }

      х = х + 1;
    }
    вернути РезультатКомпіляціїТілаСекції { пусто };
  }
}