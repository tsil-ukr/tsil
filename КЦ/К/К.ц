взяти визначення К;

секція цк {
  місцева дія скомпілювати_значення(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначення {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      вернути скомпілювати_значення_звернутись(К, блок, інформація_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      вернути скомпілювати_значення_отримати(К, блок, інформація_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      вернути скомпілювати_значення_виконати(К, блок, інформація_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконатиШаблон {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконатиШаблон>;
      вернути скомпілювати_значення_виконати_шаблон(К, блок, інформація_шаблону, середовище, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидСтворитиСтруктуру {
      ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСтруктуру>;
      вернути скомпілювати_створити_структуру(К, блок, інформація_шаблону, середовище, асд_значення.місцезнаходження, дані);
    }

    ціль помилка = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення");
    вернути РезультатЗначення { Значення {}, помилка };
  }

  місцева дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>): РезультатЗначенняТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняТип { Тип {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОВ {
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням типу");
      вернути РезультатЗначенняТип { Тип {}, створити_помилку_компіляції };
    }
    ціль обʼєкт_компіляції = значення.к;
    якщо обʼєкт_компіляції.вид != ВидОКТип {
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є типом");
      вернути РезультатЗначенняТип { Тип {}, створити_помилку_компіляції };
    }
    ціль комірка_типу = обʼєкт_компіляції.дані як комірка<Тип>;
    ціль тип = вміст(комірка_типу);
    вернути РезультатЗначенняТип { тип, пусто };
  }

  місцева дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, асд_значення: комірка<АСДЗначення>, load: логічне): РезультатЗначенняЗначення {
    ціль результат_компіляції_значення = скомпілювати_значення(К, блок, пусто, середовище, асд_значення);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, результат_компіляції_значення.помилка };
    }
    ціль значення = результат_компіляції_значення.значення;
    якщо значення.вид == ВидЗначенняОК {
      ціль ок = значення.к;
      якщо ок.вид == ВидОКЦіль {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль ц = ок.дані як комірка<Ціль>;
        якщо load == так {
          ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, ц.тип), ц.л_значення_alloca);
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, л_значення }, пусто };
        } інакше {
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання { ц.тип, ц.л_значення_alloca }, пусто };
        }
      } інакше якщо ок.вид == ВидОКДія {
        якщо блок == пусто {
          ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Не вдалося скомпілювати значення 1");
          вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
        }
        ціль д = ок.дані як комірка<Дія>;
        ціль тип = зробити_тип_з_дії(К, д);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { тип, д.л_функція як комірка<ЛЗначення> }, пусто };
      }
      біб::друк_позитивне(ок.вид);
      ціль створити_помилку_компіляції = створити_помилку_компіляції(асд_значення.місцезнаходження, ю8"Значення не є значенням");
      вернути РезультатЗначенняЗначення { ОбʼєктВиконання {}, створити_помилку_компіляції };
    }
    якщо load == так {
      якщо значення.в.unloaded == так {
        ціль л_значення = LLVM::load(К.Л, блок.block, отримати_ЛТип(К, значення.в.тип), значення.в.л_значення);
        вернути РезультатЗначенняЗначення { ОбʼєктВиконання { значення.в.тип, л_значення, unloaded = ні }, пусто };
      }
    }
    вернути РезультатЗначенняЗначення { значення.в, пусто };
  }

  місцева дія скомпілювати_створити_дію(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСтворитиДію>): РезультатЗначення {
    якщо інформація_шаблону != пусто {
      якщо дані.тіло == пусто {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Тіло дії не вказано");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }
    }

    ціль назва = дані.ідентифікатор.значення;
    ціль параметри = виділити_список<Параметр>();
    ціль тип_результату = К.тип_ніщо;

    ціль л_типи_параметрів = виділити<комірка<ЛТип>>(дані.кількість_параметрів);

    змінна пх: позитивне = 0;
    поки пх < дані.кількість_параметрів {
      ціль асд_параметр = дані.параметри[пх];
      ціль параметр = Параметр {};
      параметр.назва = асд_параметр.ідентифікатор.значення;
      ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, пусто, середовище, асд_параметр.тип);
      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_типу.помилка };
      }
      параметр.тип = результат_компіляції_типу.тип;
      додати_до_списку<Параметр>(параметри, параметр);
      л_типи_параметрів[пх] = отримати_ЛТип(К, результат_компіляції_типу.тип);
      пх = пх + 1;
    }

    якщо дані.тип_результату != пусто {
      ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, пусто, середовище, дані.тип_результату);
      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_типу.помилка };
      }
      тип_результату = результат_компіляції_типу.тип;
    }

    змінна лінкування: позитивне = 0;
    якщо дані.видимість == АСДВидимістьЗовнішня {
      лінкування = LLVM::LINKAGE_EXTERNAL;
    } інакше якщо дані.видимість == АСДВидимістьМісцева {
      лінкування = LLVM::LINKAGE_DSO_LOCAL;
    } інакше {
      лінкування = LLVM::LINKAGE_INTERNAL;
    }

    якщо strcmp(назва, ю8"main") == 0 {
      лінкування = LLVM::LINKAGE_EXTERNAL;
    }

    ціль д = виділити<Дія>();
    д.назва = назва;
    д.параметри = параметри;
    д.тип_результату = тип_результату;
    д.л_функція = LLVM::function(К.Л, лінкування, назва, отримати_ЛТип(К, тип_результату), параметри.довжина, л_типи_параметрів, ні);

    ціль дтд = виділити<ДаніТипуДія>();
    дтд.л_тип_функції = LLVM::type_of_function(К.Л, д.л_функція);
    дтд.параметри = параметри;
    дтд.тип_результату = тип_результату;

    ціль дт = Тип {};
    дт.вид = ВидТипуДія;
    дт.дані = дтд;

    ціль значення = Значення {};
    значення.вид = ВидЗначенняОВ;
    значення.в = ОбʼєктВиконання { дт, д.л_функція як комірка<ЛЗначення> };

    змінити_в_середовищі(середовище, назва, ОбʼєктКомпіляції { ВидОКДія, д });

    якщо інформація_шаблону != пусто {
      // потім: обробляти шаблон
    }

    якщо дані.тіло != пусто {
      ціль середовище_дії = створити_середовище(середовище);

      ціль блок = виділити<Блок>();
      блок.ret_value = пусто;
      блок.alloca_block = LLVM::block(К.Л, д.л_функція, ю8"alloca");
      блок.block = LLVM::block(К.Л, д.л_функція, ю8"entry");
      блок.exit_block = LLVM::block(К.Л, д.л_функція, ю8"exit");
      блок.function_exit_block = блок.exit_block;

      якщо перевірити_тип(К, д.тип_результату, К.тип_ніщо) == ні {
        блок.ret_value = LLVM::alloca(К.Л, блок.alloca_block, ю8"return", отримати_ЛТип(К, д.тип_результату));
      }

      змінна пх: позитивне = 0;
      поки пх < д.параметри.довжина {
        ціль параметр = д.параметри.дані[пх];
        ціль arg = LLVM::function_arg(К.Л, д.л_функція, пх);
        ціль л_значення = LLVM::alloca(К.Л, блок.alloca_block, параметр.назва, отримати_ЛТип(К, параметр.тип));
        LLVM::store(К.Л, блок.alloca_block, arg, л_значення);
        ціль ц = виділити<Ціль>();
        ц.тип = параметр.тип;
        ц.л_значення_alloca = л_значення;
        змінити_в_середовищі(середовище_дії, параметр.назва, ОбʼєктКомпіляції { ВидОКЦіль, ц });
        пх = пх + 1;
      }

      ціль результат_компіляції_блоку = скомпілювати_блок(К, блок, середовище_дії, дані.тіло);
      якщо результат_компіляції_блоку.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_блоку.помилка };
      }

      LLVM::br(К.Л, блок.alloca_block, блок.block);
      якщо блок.ret_value == пусто {
        LLVM::ret(К.Л, блок.exit_block, пусто);
      } інакше {
        ціль л_значення = LLVM::load(К.Л, блок.exit_block, отримати_ЛТип(К, д.тип_результату), блок.ret_value);
        LLVM::ret(К.Л, блок.exit_block, л_значення);
      }
    }

    вернути РезультатЗначення { значення, пусто };
  }

  місцева дія скомпілювати_створити_структуру(К: комірка<Компілятор>, блок: комірка<Блок>, інформація_шаблону: комірка<ІнформаціяШаблону>, середовище: комірка<Середовище>, місцезнаходження: комірка<Місцезнаходження>, дані: комірка<АСДДаніСтворитиСтруктуру>): РезультатЗначення {
    якщо інформація_шаблону != пусто {
      якщо дані.кількість_параметрів == 0 {
        ціль помилка_компіляції = створити_помилку_компіляції(місцезнаходження, ю8"Кількість параметрів не вказано");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }
    }

    ціль назва = дані.ідентифікатор.значення;

    змінна дані_типу_структури: комірка<ДаніТипуСтруктура> = пусто;

    ціль результат_отримання_з_середовища = отримати_з_локального_середовища(середовище, назва);
    якщо результат_отримання_з_середовища.знайдено == так {
      ціль субʼєкт = результат_отримання_з_середовища.субʼєкт;
      якщо субʼєкт.вид == ВидОКТип {
        ціль тип = субʼєкт.дані як комірка<Тип>;
        якщо тип.вид == ВидТипуСтруктура {
          дані_типу_структури = тип.дані як комірка<ДаніТипуСтруктура>;
          якщо дані_типу_структури.параметри.довжина != 0 {
            ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Структура вже визначена");
            вернути РезультатЗначення { Значення {}, помилка_компіляції };
          }
        } інакше {
          ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт вже визначено");
          вернути РезультатЗначення { Значення {}, помилка_компіляції };
        }
      } інакше {
        ціль помилка_компіляції = створити_помилку_компіляції(пусто, ю8"Субʼєкт вже визначено");
        вернути РезультатЗначення { Значення {}, помилка_компіляції };
      }
    } інакше {
      дані_типу_структури = виділити<ДаніТипуСтруктура>();
      дані_типу_структури.л_тип = LLVM::struct(К.Л, назва);
      дані_типу_структури.параметри = виділити_список<Параметр>();

      ціль тип = виділити<Тип>();
      тип.вид = ВидТипуСтруктура;
      тип.дані = дані_типу_структури;

      змінити_в_середовищі(середовище, назва, ОбʼєктКомпіляції { ВидОКТип, тип });

      якщо інформація_шаблону != пусто {
        ціль значення = Значення {};
        значення.вид = ВидЗначенняОК;
        значення.к = ОбʼєктКомпіляції { ВидОКТип, тип };

        ціль шаблон = інформація_шаблону.шаблон;
        ціль аргументи = інформація_шаблону.аргументи;
        ціль карта_готових_значень = шаблон.карта_готових_значень;

        змінити_значення_карти<комірка<список<Значення>>, Значення>(карта_готових_значень, аргументи, значення);
      }
    }

    ціль л_типи_параметрів = виділити<комірка<ЛТип>>(дані.кількість_параметрів);

    змінна пх: позитивне = 0;
    поки пх < дані.кількість_параметрів {
      ціль асд_параметр = дані.параметри[пх];
      ціль параметр = Параметр {};
      параметр.назва = асд_параметр.ідентифікатор.значення;
      ціль результат_компіляції_типу = скомпілювати_значення_як_тип(К, пусто, середовище, асд_параметр.тип);
      якщо результат_компіляції_типу.помилка != пусто {
        вернути РезультатЗначення { Значення {}, результат_компіляції_типу.помилка };
      }
      параметр.тип = результат_компіляції_типу.тип;
      додати_до_списку<Параметр>(дані_типу_структури.параметри, параметр);
      л_типи_параметрів[пх] = отримати_ЛТип(К, результат_компіляції_типу.тип);
      пх = пх + 1;
    }

    якщо дані.кількість_параметрів != 0 {
      LLVM::struct_set_fields(К.Л, дані_типу_структури.л_тип, дані.кількість_параметрів, л_типи_параметрів);
    }

    ціль тип = виділити<Тип>();
    тип.вид = ВидТипуСтруктура;
    тип.дані = дані_типу_структури;
    ціль обʼєкт_компіляції = ОбʼєктКомпіляції { ВидОКТип, тип };

    вернути РезультатЗначення { Значення { ВидЗначенняОК, к = обʼєкт_компіляції }, пусто };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, блок: комірка<Блок>, середовище: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];

      якщо асд_значення.вид == АСДВидСтворитиЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиЦіль>;
        ціль помилка_компіляції = скомпілювати_створити_ціль(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
        ціль помилка_компіляції = скомпілювати_змінити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль результат_компіляції_виконання = скомпілювати_значення_як_значення(К, блок, середовище, асд_значення, так);
        якщо результат_компіляції_виконання.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_виконання.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль помилка_компіляції = скомпілювати_перевизначити(К, блок, середовище, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      }

      х = х + 1;
    }
    LLVM::br(К.Л, блок.block, блок.exit_block);
    вернути РезультатКомпіляціїБлоку { пусто };
  }

    дія порівняти_ов(ов1: ОбʼєктВиконання, ов2: ОбʼєктВиконання): логічне {
      біб::друк_ю8(ю8"СТОП порівняти_ов");
      вернути ні;
    }

    дія порівняти_тип(тип1: комірка<Тип>, тип2: комірка<Тип>): логічне {
      якщо тип1.вид != тип2.вид {
        вернути ні;
      }
      якщо тип1.вид == ВидТипуНативний {
        ціль тип_тип1 = тип1.дані як комірка<ДаніТипуНативний>;
        ціль тип_тип2 = тип2.дані як комірка<ДаніТипуНативний>;
        якщо тип_тип1 == тип_тип2 {
          вернути так;
        }
      }
      біб::друк_ю8(ю8"СТОП порівняти_ок");
      вернути ні;
    }

    дія порівняти_ок(ок1: ОбʼєктКомпіляції, ок2: ОбʼєктКомпіляції): логічне {
      якщо ок1.вид != ок2.вид {
        вернути ні;
      }
      якщо ок1.вид == ВидОКТип {
        ціль тип_ок1 = ок1.дані як комірка<Тип>;
        ціль тип_ок2 = ок2.дані як комірка<Тип>;
        вернути порівняти_тип(тип_ок1, тип_ок2);
      }
      біб::друк_ю8(ю8"СТОП порівняти_ок");
      вернути ні;
    }

    дія порівняти_значення(з1: Значення, з2: Значення): логічне {
      якщо з1.вид != з2.вид {
        вернути ні;
      }
      якщо з1.вид == ВидЗначенняОВ {
        вернути порівняти_ов(з1.в, з2.в);
      }
      якщо з1.вид == ВидЗначенняОК {
        вернути порівняти_ок(з1.к, з2.к);
      }
      біб::друк_ю8(ю8"СТОП порівняти_значення");
      вернути ні;
    }

    дія порівняти_списки_значень(с1: комірка<список<Значення>>, с2: комірка<список<Значення>>): логічне {
      якщо с1.довжина != с2.довжина {
        вернути ні;
      }
      змінна х: позитивне = 0;
      поки х < с1.довжина {
        якщо порівняти_значення(с1.дані[х], с2.дані[х]) == ні {
          вернути ні;
        }
        х = х + 1;
      }
      вернути так;
    }

    місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, середовище_секції: комірка<Середовище>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
      змінна х: позитивне = 0;
      поки х < тіло.довжина {
        ціль асд_значення = тіло.елементи[х];

        якщо асд_значення.вид == АСДВидСтворитиДію {
          ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиДію>;
          ціль результат_створення_дії = скомпілювати_створити_дію(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
          якщо результат_створення_дії.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { результат_створення_дії.помилка };
          }
        } інакше якщо асд_значення.вид == АСДВидСтворитиСтруктуру {
          ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиСтруктуру>;
          ціль результат_створення_структури = скомпілювати_створити_структуру(К, пусто, пусто, середовище_секції, асд_значення.місцезнаходження, дані);
          якщо результат_створення_структури.помилка != пусто {
            вернути РезультатКомпіляціїТілаСекції { результат_створення_структури.помилка };
          }
        } інакше якщо асд_значення.вид == АСДВидСтворитиШаблон {
          ціль дані = асд_значення.дані як комірка<АСДДаніСтворитиШаблон>;

          ціль назва = дані.ідентифікатор.значення;

          ціль ш = виділити<Шаблон>();
          ш.зовнішнє_середовище = середовище_секції;
          ш.параметри = виділити_список<памʼять<п8>>();
          ш.асд_значення = дані.значення;
          ш.карта_готових_значень = виділити_карту<комірка<список<Значення>>, Значення>(порівняти_списки_значень);

          змінна пх: позитивне = 0;
          поки пх < дані.кількість_параметрів {
            ціль асд_ідентифікатор = дані.параметри[пх];
            додати_до_списку<памʼять<п8>>(ш.параметри, асд_ідентифікатор.значення);
            пх = пх + 1;
          }

          змінити_в_середовищі(середовище_секції, назва, ОбʼєктКомпіляції { ВидОКШаблон, ш });
        }

        х = х + 1;
      }
      вернути РезультатКомпіляціїТілаСекції { пусто };
    }
}