взяти визначення К;

секція ц {
  місцева дія скомпілювати_значення(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, асд_значення: комірка<АСДЗначення>, очікуваний_тип: комірка<ОбʼєктТипу>, завантажити: логічне): Результат {
    якщо асд_значення.вид == АСДВидЗвернутись {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗвернутись>;
      вернути скомпілювати_звернутись(К, інформація_середовища, асд_значення.місцезнаходження, дані, завантажити);
    } інакше якщо асд_значення.вид == АСДВидЗначенняЧисло {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняЧисло>;
      вернути скомпілювати_число(К, інформація_середовища, асд_значення.місцезнаходження, дані, очікуваний_тип);
    } інакше якщо асд_значення.вид == АСДВидЗначенняОбʼєкт {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняОбʼєкт>;
      вернути скомпілювати_обʼєкт(К, інформація_середовища, асд_значення.місцезнаходження, дані, завантажити);
    } інакше якщо асд_значення.вид == АСДВидЗначенняБезтиповийОбʼєкт {
      ціль дані = асд_значення.дані як комірка<АСДДаніЗначенняБезтиповийОбʼєкт>;
      вернути скомпілювати_безтиповий_обʼєкт(К, інформація_середовища, асд_значення.місцезнаходження, дані, очікуваний_тип, завантажити);
    } інакше якщо асд_значення.вид == АСДВидОперація {
      ціль дані = асд_значення.дані як комірка<АСДДаніОперація>;
      вернути скомпілювати_операцію(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидВиконати {
      ціль дані = асд_значення.дані як комірка<АСДДаніВиконати>;
      вернути скомпілювати_виконати(К, інформація_середовища, асд_значення.місцезнаходження, дані);
    } інакше якщо асд_значення.вид == АСДВидОтримати {
      ціль дані = асд_значення.дані як комірка<АСДДаніОтримати>;
      вернути скомпілювати_отримати(К, інформація_середовища, асд_значення.місцезнаходження, дані, завантажити);
    }

    ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Не вдалося скомпілювати значення");
    вернути Результат { помилка = помилка_компіляції };
  }

  місцева дія скомпілювати_значення_як_тип(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, асд_значення: комірка<АСДЗначення>): РезультатЯкТип {
    ціль результат_компіляції_значення = скомпілювати_значення(К, інформація_середовища, асд_значення, пусто, так);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЯкТип { помилка = результат_компіляції_значення.помилка };
    }
    якщо результат_компіляції_значення.обʼєкт.вид != ВидОбʼєктаТипу {
      ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Значення не є типом");
      вернути РезультатЯкТип { помилка = помилка_компіляції };
    }
    ціль обʼєкт = результат_компіляції_значення.обʼєкт;
    вернути РезультатЯкТип { обʼєкт_типу = обʼєкт.дані як комірка<ОбʼєктТипу>, помилка = пусто };
  }

  місцева дія скомпілювати_значення_як_значення(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, асд_значення: комірка<АСДЗначення>, очікуваний_тип: комірка<ОбʼєктТипу>): РезультатЯкЗначення {
    ціль результат_компіляції_значення = скомпілювати_значення(К, інформація_середовища, асд_значення, очікуваний_тип, так);
    якщо результат_компіляції_значення.помилка != пусто {
      вернути РезультатЯкЗначення { помилка = результат_компіляції_значення.помилка };
    }
    якщо результат_компіляції_значення.обʼєкт.вид != ВидОбʼєктаЗначення {
      ціль помилка_компіляції = виділити_помилку_компіляції(пусто, ю8"Значення не є значенням");
      вернути РезультатЯкЗначення { помилка = помилка_компіляції };
    }
    ціль обʼєкт = результат_компіляції_значення.обʼєкт;
    вернути РезультатЯкЗначення { обʼєкт_значення = обʼєкт.дані як ОбʼєктЗначення, помилка = пусто };
  }

  місцева дія скомпілювати_блок(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, llvm_exit_block: комірка<LLVM::BasicBlock>, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїБлоку {
    змінна llvm_block = інформація_середовища.llvm_block;
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
      якщо асд_значення.вид == АСДВидЦіль {
        ціль дані = асд_значення.дані як комірка<АСДДаніЦіль>;
        ціль помилка_компіляції = скомпілювати_визначити_ціль(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидЗмінити {
        ціль дані = асд_значення.дані як комірка<АСДДаніЗмінити>;
        ціль помилка_компіляції = скомпілювати_змінити(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидВиконати {
        ціль результат_компіляції_виконання = скомпілювати_значення_як_значення(К, інформація_середовища, асд_значення, пусто);
        якщо результат_компіляції_виконання.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { результат_компіляції_виконання.помилка };
        }
      } інакше якщо асд_значення.вид == АСДВидПеревизначити {
        ціль дані = асд_значення.дані як комірка<АСДДаніПеревизначити>;
        ціль помилка_компіляції = скомпілювати_перевизначити(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїБлоку { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидПоки {
        ціль дані = асд_значення.дані як комірка<АСДДаніПоки>;
        ціль while_cond_llvm_block = LLVM::block(К.L, інформація_середовища.обʼєкт_дії.llvm_function, ю8"while_cond");
        LLVM::br(К.L, llvm_block, while_cond_llvm_block);
        ціль результат_компіляції_умови = скомпілювати_значення_як_значення(
          К,
          ІнформаціяСередовища {
            середовище = інформація_середовища.середовище,
            обʼєкт_дії = інформація_середовища.обʼєкт_дії,
            llvm_block = while_cond_llvm_block,
            інформація_виконання_шаблону = інформація_середовища.інформація_виконання_шаблону
          },
          дані.умова,
          К.тип_логічне
        );
        якщо результат_компіляції_умови.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { помилка = результат_компіляції_умови.помилка };
        }
        ціль обʼєкт_значення_умови = результат_компіляції_умови.обʼєкт_значення;
        якщо обʼєкт_значення_умови.тип != К.тип_логічне {
          ціль помилка_компіляції = виділити_помилку_компіляції(дані.умова.місцезнаходження, ю8"Тип умови повинен бути логічним");
          вернути РезультатКомпіляціїБлоку { помилка = помилка_компіляції };
        }
        ціль while_body_llvm_block = LLVM::block(К.L, інформація_середовища.обʼєкт_дії.llvm_function, ю8"while_body");
        ціль while_body_llvm_exit_block = LLVM::block(К.L, інформація_середовища.обʼєкт_дії.llvm_function, ю8"while_body_exit");
        LLVM::brif(К.L, while_cond_llvm_block, обʼєкт_значення_умови.llvm_value, while_body_llvm_block, while_body_llvm_exit_block);
        ціль середовище_поки = створити_середовище(інформація_середовища.середовище);
        ціль результат_компіляції_тіла = скомпілювати_блок(
          К,
          ІнформаціяСередовища {
            середовище = середовище_поки,
            обʼєкт_дії = інформація_середовища.обʼєкт_дії,
            llvm_block = while_body_llvm_block,
            інформація_виконання_шаблону = інформація_середовища.інформація_виконання_шаблону
          },
          while_body_llvm_exit_block,
          дані.тіло
        );
        якщо результат_компіляції_тіла.помилка != пусто {
          вернути РезультатКомпіляціїБлоку { помилка = результат_компіляції_тіла.помилка };
        }
        llvm_block = while_body_llvm_exit_block;
      }
      х = х + 1;
    }
    LLVM::br(К.L, llvm_block, llvm_exit_block);
    вернути РезультатКомпіляціїБлоку { помилка = пусто };
  }

  місцева дія скомпілювати_тіло_секції(К: комірка<Компілятор>, інформація_середовища: ІнформаціяСередовища, тіло: комірка<СписокАСДЗначень>): РезультатКомпіляціїТілаСекції {
    змінна х: позитивне = 0;
    поки х < тіло.довжина {
      ціль асд_значення = тіло.елементи[х];
      якщо асд_значення.вид == АСДВидДія {
        ціль дані = асд_значення.дані як комірка<АСДДаніДія>;
        ціль помилка_компіляції = скомпілювати_визначити_дію(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСтруктура {
        ціль дані = асд_значення.дані як комірка<АСДДаніСтруктура>;
        ціль помилка_компіляції = скомпілювати_визначити_структуру(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидШаблон {
        ціль дані = асд_значення.дані як комірка<АСДДаніШаблон>;
        ціль помилка_компіляції = скомпілювати_визначити_шаблон(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСинонім {
        ціль дані = асд_значення.дані як комірка<АСДДаніСинонім>;
        ціль помилка_компіляції = скомпілювати_визначити_синонім(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      } інакше якщо асд_значення.вид == АСДВидСекція {
        ціль дані = асд_значення.дані як комірка<АСДДаніСекція>;
        ціль помилка_компіляції = скомпілювати_визначити_секцію(К, інформація_середовища, асд_значення.місцезнаходження, дані);
        якщо помилка_компіляції != пусто {
          вернути РезультатКомпіляціїТілаСекції { помилка_компіляції };
        }
      }
      х = х + 1;
    }
    вернути РезультатКомпіляціїТілаСекції { помилка = пусто };
  }
}