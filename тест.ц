синонім невідома_комірка = адреса;
синонім невідома_памʼять = адреса;
синонім комірка<Т> = адреса<Т>;
синонім памʼять<Т> = адреса<Т>;

зовнішня дія malloc(size: ц32): невідома_памʼять;
зовнішня дія free(ptr: адреса);
зовнішня дія realloc(ptr: адреса, size: ц32): невідома_памʼять;
зовнішня дія putchar(value: ц8): ц32;

дія виділити<Т>(): комірка<Т>;
дія виділити<Т>(кількість: ц32): памʼять<Т>;
дія перевиділити<Т>(значення: адреса<Т>, кількість: ц32): памʼять<Т>;

дія виділити<Т>(): комірка<Т> {
  вернути malloc(Т::розмір) як комірка<Т>;
}

дія виділити<Т>(кількість: ц32): памʼять<Т> {
  вернути malloc(кількість * Т::розмір) як памʼять<Т>;
}

дія перевиділити<Т>(значення: адреса<Т>, кількість: ц32): памʼять<Т> {
  вернути realloc(значення, кількість * Т::розмір) як памʼять<Т>;
}

структура список<Т> {
  дані: памʼять<Т>;
  довжина: ц32;
  вмісткість: ц32;
}

дія виділити_список<Т>(): комірка<список<Т>> {
  ціль с = виділити<список<Т>>();
  с.дані = пусто як адреса<Т>;
  с.довжина = 0;
  с.вмісткість = 0;
  вернути с;
}

дія додати_до_списку<Т>(с: комірка<список<Т>>, значення: Т) {
  якщо с.довжина == с.вмісткість {
    якщо с.вмісткість == 0 {
      с.дані = виділити<Т>(1);
    } інакше {
      с.дані = перевиділити<Т>(с.дані, с.вмісткість + 1);
    }
    с.вмісткість = с.вмісткість + 1;
  }
  с.дані[с.довжина] = значення;
  с.довжина = с.довжина + 1;
}

дія звільнити_список<Т>(с: комірка<список<Т>>) {
  звільнити(с.дані);
  звільнити(с);
}


зовнішня дія main() {
  ціль символи = виділити_список<п8>();
  додати_до_списку<п8>(символи, 42);
  додати_до_списку<п8>(символи, 43);
  додати_до_списку<п8>(символи, 44);
  змінна ціль х: ц32 = 0;
  поки х < символи.довжина {
    putchar(символи.дані[х]);
    х = х + 1;
  }
}