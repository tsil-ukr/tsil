взяти визначення ./ПМ;
взяти визначення ./КЦ;
взяти визначення біб/цілеспрямовано;

дія надрукувати_допомогу() {
  біб::надрукувати("Ціль 0.38.0");
  біб::надрукувати("");
  біб::надрукувати("Використання:");
  біб::надрукувати("  ціль [--опції-програми]...");
  біб::надрукувати("       [");
  біб::надрукувати("         [вихід [--опції-виходу]...]...");
  біб::надрукувати("         команда [--опції-команди]...");
  біб::надрукувати("         [вхід [--опції-входу]...]...");
  біб::надрукувати("       ]");
  біб::надрукувати("");
  біб::надрукувати("Опції програми:");
  біб::надрукувати("  немає");
  біб::надрукувати("");
  біб::надрукувати("Команди:");
  біб::надрукувати("  допомога");
  біб::надрукувати("    Опис: надрукувати допомогу");
  біб::надрукувати("  версія");
  біб::надрукувати("    Опис: надрукувати версію Цілі");
  біб::надрукувати("  скомпілювати");
  біб::надрукувати("    Опис: скомпілювати файл(-и)");
  біб::надрукувати("    Вихід:");
  біб::надрукувати("      Формат: .ллвмір .ллвмобдж");
  біб::надрукувати("      Опції:");
  біб::надрукувати("        --формат=<ллвмір|ллвмобдж>");
  біб::надрукувати("    Вхід:");
  біб::надрукувати("      Формат: .ц");
}

дія очікується_ЛЛВМІР(виділяч: адреса<біб::Виділяч>, вихід: ю8): логічне {
  змінна результат = біб::перевірити_чи_ю8_закінчується_на(вихід, ю8".ллвмір");
  якщо результат {
    вернути результат;
  }
  змінна ю8_лл = ю8 { 3, біб::виділити_памʼять<п8>(виділяч, 3) };
  ю8_лл.дані[0] = 46;
  ю8_лл.дані[1] = 108;
  ю8_лл.дані[2] = 108;
  результат = біб::перевірити_чи_ю8_закінчується_на(вихід, ю8_лл);
  біб::звільнити_памʼять(виділяч, ю8_лл.дані);
  вернути результат;
}

дія очікується_ОБДЖЕКТ(виділяч: адреса<біб::Виділяч>, вихід: ю8): логічне {
  змінна результат = біб::перевірити_чи_ю8_закінчується_на(вихід, ю8".ллвмобдж");
  якщо результат {
    вернути результат;
  }
  змінна ю8_обдж = ю8 { 2, біб::виділити_памʼять<п8>(виділяч, 2) };
  ю8_обдж.дані[0] = 46;
  ю8_обдж.дані[1] = 111;
  результат = біб::перевірити_чи_ю8_закінчується_на(вихід, ю8_обдж);
  біб::звільнити_памʼять(виділяч, ю8_обдж.дані);
  вернути результат;
}

дія скомпілювати(виділяч: адреса<біб::Виділяч>,
                 опції_програми: цілеспрямовано::Опції<ю8>,
                 опції_команди: цілеспрямовано::Опції<ю8>,
                 вхід: ю8,
                 опції_входу: цілеспрямовано::Опції<ю8>,
                 вихід: ю8,
                 опції_виходу: цілеспрямовано::Опції<ю8>,
                 знищити_залишки: логічне): ц32 {
  синонім ФОРМАТ_ВИХОДУ_ЛЛВМОБДЖ = 1;
  синонім ФОРМАТ_ВИХОДУ_ЛЛВМІР = 2;

  змінна формат_виходу: позитивне = ФОРМАТ_ВИХОДУ_ЛЛВМІР;
  змінна формат_виходу_визначено = ні;

  змінна п: позитивне = 0;

  поки п < опції_команди.розмір {
    змінна опція = опції_команди.дані[п];

    якщо біб::перевірити_чи_ю8_рівні(опція.ключ, ю8"формат-виходу") {
      якщо опція.значення.заповнено == позитивне(так) {
        якщо біб::перевірити_чи_ю8_рівні(опція.значення.значення, ю8"ллвмір") {
          формат_виходу = ФОРМАТ_ВИХОДУ_ЛЛВМІР;
          формат_виходу_визначено = так;
        } інакше якщо біб::перевірити_чи_ю8_рівні(опція.значення.значення, ю8"ллвмобдж") {
          формат_виходу = ФОРМАТ_ВИХОДУ_ЛЛВМОБДЖ;
          формат_виходу_визначено = так;
        } інакше {
          біб::надрукувати("Неочікуване значення опції команди --формат-виходу.");
          вернути 1;
        }
      } інакше {
       біб::надрукувати("Опція команди --формат-виходу має мати значення.");
       вернути 1;
     }
    }

    п += 1;
  }

  п = 0;

  поки п < опції_виходу.розмір {
    змінна опція = опції_виходу.дані[п];

    якщо біб::перевірити_чи_ю8_рівні(опція.ключ, ю8"формат") {
      якщо опція.значення.заповнено == позитивне(так) {
        якщо біб::перевірити_чи_ю8_рівні(опція.значення.значення, ю8"ллвмір") {
          формат_виходу = ФОРМАТ_ВИХОДУ_ЛЛВМІР;
          формат_виходу_визначено = так;
        } інакше якщо біб::перевірити_чи_ю8_рівні(опція.значення.значення, ю8"ллвмобдж") {
          формат_виходу = ФОРМАТ_ВИХОДУ_ЛЛВМОБДЖ;
          формат_виходу_визначено = так;
        } інакше {
          біб::надрукувати("Неочікуване значення опції виходу --формат.");
          вернути 1;
        }
      } інакше {
       біб::надрукувати("Опція виходу --формат має мати значення.");
       вернути 1;
     }
    }

    п += 1;
  }

  якщо формат_виходу_визначено == ні {
    якщо очікується_ЛЛВМІР(виділяч, вихід) {
      формат_виходу = ФОРМАТ_ВИХОДУ_ЛЛВМІР;
    } інакше якщо очікується_ОБДЖЕКТ(виділяч, вихід) {
      формат_виходу = ФОРМАТ_ВИХОДУ_ЛЛВМОБДЖ;
    }
  }

  змінна вихід_треба_звільнити = ні;

  якщо вихід.розмір == 0 {
    змінна ю8_закінчення = ю8 { 0, пусто };
    якщо формат_виходу == ФОРМАТ_ВИХОДУ_ЛЛВМІР {
      ю8_закінчення = ю8".ллвмір";
    } інакше якщо формат_виходу == ФОРМАТ_ВИХОДУ_ЛЛВМОБДЖ {
      ю8_закінчення = ю8".ллвмобдж";
    }
    вихід = біб::обʼєднати_ю8(виділяч, вхід, ю8_закінчення);
    вихід_треба_звільнити = так;
  }

  змінна пм_модуль = ПМ::створити_модуль("а1", ПМ::ПРОЦЕСОР_Х86_64, ПМ::СИСТЕМА_ЛІНУКС_ГНУ);

  змінна компілятор = КЦ::створити_компілятор(виділяч, пм_модуль);

  якщо КЦ::отримати_поточну_директорію_процесу(компілятор, компілятор.кореневий_шлях::адреса) == ні {
    // потім: помилка
  }

  змінна помилка: адреса<КЦ::Помилка> = пусто;

  змінна успіх_взяття = КЦ::взяти_файл_ю8(
    компілятор,
    компілятор.глобальне_середовище,
    КЦ::Шлях { вхід.розмір, вхід.дані },
    помилка::адреса
  );

  якщо успіх_взяття == ні {
    змінна текст_коду = помилка.місцезнаходження.текст_коду;

    якщо помилка.місцезнаходження != пусто {
      біб::вивести_ю8(ю8 { текст_коду.шлях.розмір, текст_коду.шлях.дані });
      біб::вивести(":");
      біб::вивести_позитивне(помилка.місцезнаходження.рядок);
      біб::вивести(":");
      біб::вивести_позитивне(помилка.місцезнаходження.стовпець);
      біб::вивести(" помилка: ");
    }

    змінна повідомлення_ю8 = КЦ::отримати_ю8_з_т8(компілятор, помилка.повідомлення);
    біб::надрукувати_ю8(повідомлення_ю8);
    КЦ::звільнити_памʼять(компілятор, повідомлення_ю8.дані);

    якщо помилка.місцезнаходження != пусто {
      змінна витнутний_текст = КЦ::розбирач::витнути_значення_ю8(
        ю8 { помилка.місцезнаходження.текст_коду.оригінальне_значення.розмір, помилка.місцезнаходження.текст_коду.оригінальне_значення.дані },
        текст_коду.місцезнаходження_оригінального_значення.дані[помилка.місцезнаходження.позиція_в_тексті],
        100
      );

      змінна позитивне_ю8 = біб::перетворити_позитивне_на_ю8(компілятор.виділяч, помилка.місцезнаходження.рядок);
      біб::вивести_ю8(позитивне_ю8);
      біб::вивести("| ");
      біб::надрукувати_ю8(витнутний_текст.витнуте_значення);
      змінна п: позитивне = 0;
      поки п < (витнутний_текст.початок_підкреслення + позитивне_ю8.розмір + 2) {
        біб::вивести(" ");
        п += 1;
      }
      біб::надрукувати("∧");
      біб::звільнити_памʼять(виділяч, позитивне_ю8.дані);
    }

    якщо знищити_залишки {
      КЦ::знищити_помилку(компілятор, помилка);
      КЦ::знищити_компілятор(компілятор);
    }

    вернути 1;
  }

  змінна значення_запису = КЦ::Байти { 0, пусто };

  якщо формат_виходу == ФОРМАТ_ВИХОДУ_ЛЛВМІР {
    ПМ::отримати_лл(пм_модуль, значення_запису.розмір::адреса, значення_запису.дані::адреса);
  } інакше якщо формат_виходу == ФОРМАТ_ВИХОДУ_ЛЛВМОБДЖ {
    ПМ::отримати_обджект(пм_модуль, значення_запису.розмір::адреса, значення_запису.дані::адреса);
  }

  якщо КЦ::записати_файл(компілятор, КЦ::Шлях { вихід.розмір, вихід.дані }, значення_запису) {
  } інакше {
    біб::вивести("Не вдалось записати у файл ");
    біб::надрукувати_ю8(вхід);
  }

  якщо знищити_залишки {
    якщо вихід_треба_звільнити {
      біб::звільнити_памʼять(виділяч, вихід.дані);
    }
    біб::звільнити_памʼять(виділяч, значення_запису.дані);
    КЦ::знищити_компілятор(компілятор);
    ПМ::знищити_модуль(пм_модуль);
  }

  вернути 0;
}

зовнішня дія розпочати(кількість_аргументів: позитивне, аргументи: памʼять<КЦ::Байти>): ц32 {
  змінна статус_виходу: ц32 = 0;
  змінна виділяч = біб::отримати_системний_виділяч();

  змінна доступні_команди = цілеспрямовано::ДоступніКомандиДляРозбору<ю8> { 2, біб::виділити_памʼять<ю8>(виділяч, 2) };
  доступні_команди.дані[0] = ю8"скомпілювати";
  доступні_команди.дані[1] = ю8"допомога";

  змінна розібрана_команда = цілеспрямовано::зробити_розібрану_команду<ю8>();

  змінна успіх_розбору_команди = цілеспрямовано::розібрати_команду<ю8>(
    виділяч,
    цілеспрямовано::АргументиДляРозбору<ю8> { кількість_аргументів - 1, аргументи[1]::адреса як памʼять<ю8> },
    доступні_команди,
    ю8"--",
    ю8"=",
    розібрана_команда::адреса
  );

  якщо успіх_розбору_команди == ні {
    біб::надрукувати("Не вдалось розібрати команду!");
    вернути 1;
  }

  якщо біб::перевірити_чи_ю8_рівні(розібрана_команда.команда, ю8"") {
    надрукувати_допомогу();
    стрибнути вихід;
  }

  якщо біб::перевірити_чи_ю8_рівні(розібрана_команда.команда, ю8"допомога") {
    надрукувати_допомогу();
    стрибнути вихід;
  }

  якщо біб::перевірити_чи_ю8_рівні(розібрана_команда.команда, ю8"скомпілювати") {
    якщо розібрана_команда.входи.розмір < 1 {
      біб::надрукувати("Недостатньо вхідних!");
      статус_виходу = 1;
      стрибнути вихід;
    }

    якщо розібрана_команда.виходи.розмір == 0 {
      змінна п: позитивне = 0;
      поки п < розібрана_команда.входи.розмір {
        змінна вхід = розібрана_команда.входи.дані[п];

        змінна статус_компіляції = скомпілювати(
          виділяч,
          розібрана_команда.опції_програми,
          розібрана_команда.опції_команди,
          вхід.значення,
          вхід.опції,
          ю8 { 0, пусто },
          цілеспрямовано::Опції<ю8> { 0, пусто },
          розібрана_команда.входи.розмір == 1
        );

        якщо статус_компіляції != 0 {
          статус_виходу = статус_компіляції;
          стрибнути вихід;
        }

        п += 1;
      }

      стрибнути вихід;
    } інакше {
      якщо розібрана_команда.входи.розмір > 1 {
        біб::надрукувати("Команда скомпілювати з вказаними виходами може мати лише один вхід!");
        статус_виходу = 1;
        стрибнути вихід;
      }

      змінна вхід = розібрана_команда.входи.дані[0];

      змінна п: позитивне = 0;
      поки п < розібрана_команда.виходи.розмір {
        змінна вихід = розібрана_команда.виходи.дані[п];

        змінна статус_компіляції = скомпілювати(
          виділяч,
          розібрана_команда.опції_програми,
          розібрана_команда.опції_команди,
          вхід.значення,
          вхід.опції,
          вихід.значення,
          вихід.опції,
          розібрана_команда.виходи.розмір == 1
        );

        якщо статус_компіляції != 0 {
          статус_виходу = статус_компіляції;
          стрибнути вихід;
        }

        п += 1;
      }

      стрибнути вихід;
    }
  } інакше {
    біб::надрукувати("Невідома команда!");
    статус_виходу = 1;
    стрибнути вихід;
  }

вихід:
  цілеспрямовано::знищити_розібрану_команду<ю8>(виділяч, розібрана_команда);
  біб::звільнити_памʼять(виділяч, доступні_команди.дані);
  вернути статус_виходу;
}