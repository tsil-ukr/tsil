////
// Захищено Правом Автора
// Богданович Давид Когут Прихожденко, 2024
//
// Цей файл є частиною Бібліотеки Цілі і відповідає за роботу з кодуванням Unicode.
////

взяти біб юнікод;

секція біб {
  секція юнікод {
    місцева дія дізнатись_розмір_символа_юнікоду(перший_байт: п8): п8 {
      якщо (перший_байт & 0ш80) == 0ш00 {
        вернути 1;
      }
      якщо (перший_байт & 0шҐ0) == 0шВ0 {
        вернути 2;
      }
      якщо (перший_байт & 0шД0) == 0шҐ0 {
        вернути 3;
      }
      якщо (перший_байт & 0шД8) == 0шД0 {
        вернути 4;
      }
      вернути 0;
    }

    місцева дія дізнатись_розмір_ю8_сі(значення: памʼять<п8>): позитивне {
      змінна розмір = 0;
      поки значення[розмір] != 0 {
        розмір = розмір + 1;
      }
      вернути розмір;
    }

    місцева дія дізнатись_розмір_ю16_сі(значення: памʼять<п16>): позитивне {
      змінна розмір = 0;
      поки значення[розмір] != 0 {
        розмір = розмір + 1;
      }
      вернути розмір;
    }

    місцева дія дізнатись_розмір_ю32_сі(значення: памʼять<п32>): позитивне {
      змінна розмір = 0;
      поки значення[розмір] != 0 {
        розмір = розмір + 1;
      }
      вернути розмір;
    }

    місцева дія дізнатись_довжину_ю8(значення: памʼять<п8>, розмір: позитивне): позитивне {
      змінна х = 0;
      змінна довжина = 0;
      поки х < розмір {
        ціль перший_байт = значення[х];
        ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
        якщо розмір_символа == 0 {
          х = х + 1;
        } інакше {
          довжина = довжина + 1;
          х = х + розмір_символа;
        }
      }
      вернути довжина;
    }

    місцева дія дізнатись_довжину_ю16(значення: памʼять<п16>, розмір: позитивне): позитивне {
      змінна х = 0;
      змінна довжина = 0;
      поки х < розмір {
        ціль перший_байт = значення[х] & п16(0ш3Д);
        ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
        якщо розмір_символа == 0 {
          х = х + 1;
        } інакше {
          довжина = довжина + 1;
          х = х + розмір_символа;
        }
      }
      вернути довжина;
    }

    місцева дія дізнатись_довжину_ю8_сі(значення: памʼять<п8>): позитивне {
      ціль розмір = дізнатись_розмір_ю8_сі(значення);
      змінна х = 0;
      змінна довжина = 0;
      поки х < розмір {
        ціль перший_байт = значення[х];
        ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
        якщо розмір_символа == 0 {
          х = х + 1;
        } інакше {
          довжина = довжина + 1;
          х = х + розмір_символа;
        }
      }
      вернути довжина;
    }

    місцева дія дізнатись_довжину_ю16_сі(значення: памʼять<п16>): позитивне {
      ціль розмір = дізнатись_розмір_ю16_сі(значення);
      змінна х = 0;
      змінна довжина = 0;
      поки х < розмір {
        ціль перший_байт = значення[х] & п16(0ш3Д);
        ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
        якщо розмір_символа == 0 {
          х = х + 1;
        } інакше {
          довжина = довжина + 1;
          х = х + розмір_символа;
        }
      }
      вернути довжина;
    }

    місцева дія ю8_в_ю16(ю8: памʼять<п8>, розмір: позитивне): памʼять<п16> {
      змінна буфер = виділити<п16>(розмір + 1);
      змінна розмір_буфера = 0;
      змінна х = 0;
      поки х < розмір {
        ціль перший_байт = ю8[х];
        ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
        якщо розмір_символа == 1 {
          буфер[розмір_буфера] = п16(перший_байт & п8(0ш7Д));
          розмір_буфера = розмір_буфера + 1;
        }
        якщо розмір_символа == 2 {
          ціль другий_байт = ю8[х + 1];
          буфер[розмір_буфера] = (п16(перший_байт & п8(0ш1Д)) << п16(6)) | п16(другий_байт & п8(0ш3Д));
          розмір_буфера = розмір_буфера + 1;
          х = х + 1;
        }
        якщо розмір_символа == 3 {
          ціль другий_байт = ю8[х + 1];
          ціль третій_байт = ю8[х + 2];
          буфер[розмір_буфера] = (п16(перший_байт & п8(0ш0Д)) << п16(12)) | (п16(другий_байт & п8(0ш3Д)) << п16(6)) | п16(третій_байт & п8(0ш3Д));
          розмір_буфера = розмір_буфера + 1;
          х = х + 2;
        }
        якщо розмір_символа == 4 {
          ціль другий_байт = ю8[х + 1];
          ціль третій_байт = ю8[х + 2];
          ціль четвертий_байт = ю8[х + 3];
          змінна код_першої_частини = (ц32(перший_байт & п8(0ш0Д)) << ц32(18)) | (ц32(другий_байт & п8(0ш3Д)) << ц32(12)) | (ц32(третій_байт & п8(0ш3Д)) << ц32(6)) | ц32(четвертий_байт & п8(0ш3Д));
          код_першої_частини = код_першої_частини - 0ш10000;
          буфер[розмір_буфера] = 0шГ800 + ((код_першої_частини >> 10) & 0ш3ДД);
          буфер[розмір_буфера + 1] = 0шГВ00 + (код_першої_частини & 0ш3ДД);
          розмір_буфера = розмір_буфера + 2;
          х = х + 3;
        }
        х = х + 1;
      }
      буфер[розмір_буфера] = 0;
      ціль новий_буфер = виділити<п16>(розмір_буфера + 1);
      змінна нх = 0;
      поки нх < розмір_буфера {
        новий_буфер[нх] = буфер[нх];
        нх = нх + 1;
      }
      новий_буфер[розмір_буфера] = 0;
      звільнити(буфер);
      вернути новий_буфер;
    }

    місцева дія ю8_в_ю32(ю8: памʼять<п8>, розмір: позитивне): памʼять<п32> {
      змінна буфер = виділити<п32>(розмір + 1);
      змінна розмір_буфера = 0;
      змінна х = 0;
      поки х < розмір {
        ціль перший_байт = ю8[х];
        ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
        якщо розмір_символа == 1 {
          буфер[розмір_буфера] = п32(перший_байт & п8(0ш7Д));
          розмір_буфера = розмір_буфера + 1;
        }
        якщо розмір_символа == 2 {
          ціль другий_байт = ю8[х + 1];
          буфер[розмір_буфера] = (п32(перший_байт & п8(0ш1Д)) << п32(6)) | п32(другий_байт & п8(0ш3Д));
          розмір_буфера = розмір_буфера + 1;
          х = х + 1;
        }
        якщо розмір_символа == 3 {
          ціль другий_байт = ю8[х + 1];
          ціль третій_байт = ю8[х + 2];
          буфер[розмір_буфера] = (п32(перший_байт & п8(0ш0Д)) << п32(12)) | (п32(другий_байт & п8(0ш3Д)) << п32(6)) | п32(третій_байт & п8(0ш3Д));
          розмір_буфера = розмір_буфера + 1;
          х = х + 2;
        }
        якщо розмір_символа == 4 {
          ціль другий_байт = ю8[х + 1];
          ціль третій_байт = ю8[х + 2];
          ціль четвертий_байт = ю8[х + 3];
          буфер[розмір_буфера] = (п32(перший_байт & п8(0ш0Д)) << п32(18)) | (п32(другий_байт & п8(0ш3Д)) << п32(12)) | (п32(третій_байт & п8(0ш3Д)) << п32(6)) | п32(четвертий_байт & п8(0ш3Д));
          розмір_буфера = розмір_буфера + 1;
          х = х + 3;
        }
        х = х + 1;
      }
      буфер[розмір_буфера] = 0;
      ціль новий_буфер = виділити<п32>(розмір_буфера + 1);
      змінна нх = 0;
      поки нх < розмір_буфера {
        новий_буфер[нх] = буфер[нх];
        нх = нх + 1;
      }
      новий_буфер[розмір_буфера] = 0;
      звільнити(буфер);
      вернути новий_буфер;
    }

    // ...
  }
}

зовнішня дія ___біб__юнікод__ю8_в_ю16___(ю8: памʼять<п8>, розмір: позитивне): памʼять<п16> {
  вернути біб::юнікод::ю8_в_ю16(ю8, розмір);
}