взяти визначення ./ПМ;
взяти визначення ./ПМЛЛВМ;
взяти визначення ./КЦ;
взяти біб цілеспрямовано;

зовнішня дія __КЦ__отримати_версію_цілі_як_ю8(вихід: адреса<ю8>);
зовнішня дія __КЦ__прочитати_файл(виділяч: адреса<біб::Виділяч>, шлях: адреса<КЦ::Шлях>, вихід: адреса<КЦ::Байти>, вихід_успіху: адреса<логічне>);
зовнішня дія __КЦ__записати_файл(виділяч: адреса<біб::Виділяч>, шлях: адреса<КЦ::Шлях>, значення: адреса<КЦ::Байти>, вихід_успіху: адреса<логічне>);

дія отримати_версію_цілі_як_ю8() -> ю8 {
  змінна результат = ю8 { 0, пусто };
  __КЦ__отримати_версію_цілі_як_ю8(результат::адреса);
  вернути результат;
}

дія надрукувати_версію() {
  біб::надрукувати_ю8(отримати_версію_цілі_як_ю8());
}

дія надрукувати_допомогу() {
  біб::вивести("Ціль ");
  біб::надрукувати_ю8(отримати_версію_цілі_як_ю8());
  біб::надрукувати("");
  біб::надрукувати("Використання:");
  біб::надрукувати("  ціль [--опції-програми]");
  біб::надрукувати("       [вихід [--опції-виходу]]");
  біб::надрукувати("       команда [--опції-команди]");
  біб::надрукувати("       [вхід [--опції-входу]]");
  біб::надрукувати("");
  біб::надрукувати("Опції програми:");
  біб::надрукувати("  немає");
  біб::надрукувати("");
  біб::надрукувати("Команди:");
  біб::надрукувати("  допомога");
  біб::надрукувати("    Опис: надрукувати допомогу");
  біб::надрукувати("  версія");
  біб::надрукувати("    Опис: надрукувати версію Цілі");
  біб::надрукувати("  скомпілювати");
  біб::надрукувати("    Опис: скомпілювати файл(-и)");
  біб::надрукувати("    Опції:");
  біб::надрукувати("      ... опції виходу з закінченням -виходів (приклад: --формат-виходів)");
  біб::надрукувати("      ... опції входу з закінченням -входів (приклад: --біб-входів)");
  біб::надрукувати("    Вихід:");
  біб::надрукувати("      Формат: .ллвмо .ллвмір");
  біб::надрукувати("      Опції:");
  біб::надрукувати("        --формат=<ллвмо|ллвмір>");
  біб::надрукувати("        --архітектура=<ікс86_64>");
  біб::надрукувати("        --постачальник=<загальний>");
  біб::надрукувати("        --система=<лінукс>");
  біб::надрукувати("    Вхід:");
  біб::надрукувати("      Формат: .ц");
  біб::надрукувати("      Опції:");
  біб::надрукувати("        --біб=\"шлях до бібліотеки\"");
  біб::надрукувати("  кдвю");
  біб::надрукувати("    Опис: перекодувати файл(-и) з дієкоду в юнікод");
  біб::надрукувати("  ювкд");
  біб::надрукувати("    Опис: перекодувати файл(-и) з юнікоду в дієкод");
  біб::надрукувати("");
  біб::надрукувати("Приклад:");
  біб::надрукувати("  ціль привіт.ллвмір скомпілювати привіт.ц");
}

дія очікується_ЛЛВМІР(виділяч: адреса<біб::Виділяч>, вихід: ю8) -> логічне {
  змінна результат = біб::перевірити_чи_ю8_закінчується_на(вихід, ю8".ллвмір");
  якщо результат {
    вернути результат;
  }
  змінна ю8_лл = ю8 { 3, біб::виділити_памʼять<п8>(виділяч, 3) };
  ю8_лл.дані[0] = 46;
  ю8_лл.дані[1] = 108;
  ю8_лл.дані[2] = 108;
  результат = біб::перевірити_чи_ю8_закінчується_на(вихід, ю8_лл);
  біб::звільнити_памʼять(виділяч, ю8_лл.дані);
  вернути результат;
}

дія очікується_ОБДЖЕКТ(виділяч: адреса<біб::Виділяч>, вихід: ю8) -> логічне {
  змінна результат = біб::перевірити_чи_ю8_закінчується_на(вихід, ю8".ллвмо");
  якщо результат {
    вернути результат;
  }
  змінна ю8_обдж = ю8 { 2, біб::виділити_памʼять<п8>(виділяч, 2) };
  ю8_обдж.дані[0] = 46;
  ю8_обдж.дані[1] = 111;
  результат = біб::перевірити_чи_ю8_закінчується_на(вихід, ю8_обдж);
  біб::звільнити_памʼять(виділяч, ю8_обдж.дані);
  вернути результат;
}

дія скомпілювати(виділяч: адреса<біб::Виділяч>,
                 опції_програми: цілеспрямовано::Опції<ю8>,
                 опції_команди: цілеспрямовано::Опції<ю8>,
                 вхід: ю8,
                 опції_входу: цілеспрямовано::Опції<ю8>,
                 вихід: ю8,
                 опції_виходу: цілеспрямовано::Опції<ю8>,
                 треба_знищити_залишки: логічне) -> ц32 {
  синонім ФОРМАТ_ВИХОДУ_ЛЛВМО = 1;
  синонім ФОРМАТ_ВИХОДУ_ЛЛВМІР = 2;

  змінна формат_виходу: натуральне = ФОРМАТ_ВИХОДУ_ЛЛВМО;
  змінна формат_виходу_визначено = ні;

  змінна пм_архітектура_виходу: натуральне = ПМ::АРХІТЕКТУРА_ІКС86_64;
  змінна пм_система_виходу: натуральне = ПМ::СИСТЕМА_ЛІНУКС;

  змінна шлях_до_біб = ю8 { 0, пусто };
  
  змінна п: натуральне = 0;

  поки п < опції_команди.розмір {
    змінна опція = опції_команди.дані[п];

    якщо біб::перевірити_чи_ю8_рівні(опція.ключ, ю8"формат-виходів") {
      якщо опція.значення.заповнено == натуральне(так) {
        якщо біб::перевірити_чи_ю8_рівні(опція.значення.значення, ю8"ллвмір") {
          формат_виходу = ФОРМАТ_ВИХОДУ_ЛЛВМІР;
          формат_виходу_визначено = так;
        } інакше якщо біб::перевірити_чи_ю8_рівні(опція.значення.значення, ю8"ллвмо") {
          формат_виходу = ФОРМАТ_ВИХОДУ_ЛЛВМО;
          формат_виходу_визначено = так;
        } інакше {
          біб::надрукувати("Неочікуване значення опції команди --формат-виходів.");
          вернути 1;
        }
      } інакше {
       біб::надрукувати("Опція команди --формат-виходів має мати значення.");
       вернути 1;
     }
    } інакше якщо біб::перевірити_чи_ю8_рівні(опція.ключ, ю8"архітектура-виходів") {
      якщо опція.значення.заповнено == натуральне(так) {
        якщо біб::перевірити_чи_ю8_рівні(опція.значення.значення, ю8"ікс86_64") {
          пм_архітектура_виходу = ПМ::АРХІТЕКТУРА_ІКС86_64;
        } інакше {
          біб::надрукувати("Неочікуване значення опції команди --архітектура-виходів.");
          вернути 1;
        }
      } інакше {
       біб::надрукувати("Опція команди --архітектура-виходів має мати значення.");
       вернути 1;
     }
    } інакше якщо біб::перевірити_чи_ю8_рівні(опція.ключ, ю8"система-виходів") {
      якщо опція.значення.заповнено == натуральне(так) {
        якщо біб::перевірити_чи_ю8_рівні(опція.значення.значення, ю8"лінукс") {
          пм_система_виходу = ПМ::СИСТЕМА_ЛІНУКС;
        } інакше {
          біб::надрукувати("Неочікуване значення опції команди --система-виходів.");
          вернути 1;
        }
      } інакше {
       біб::надрукувати("Опція команди --система-виходів має мати значення.");
       вернути 1;
      }
    } інакше якщо біб::перевірити_чи_ю8_рівні(опція.ключ, ю8"біб-входів") {
      якщо опція.значення.заповнено == натуральне(так) {
        шлях_до_біб = опція.значення.значення;
      } інакше {
       біб::надрукувати("Опція команди --біб-входів має мати значення.");
       вернути 1;
      }
    } інакше {
      біб::вивести("Неочікувана опція команди ");
      біб::надрукувати_ю8(опція.ключ);
    }

    п += 1;
  }

  п = 0;

  поки п < опції_входу.розмір {
    змінна опція = опції_входу.дані[п];

    якщо біб::перевірити_чи_ю8_рівні(опція.ключ, ю8"біб") {
      якщо опція.значення.заповнено == натуральне(так) {
        шлях_до_біб = опція.значення.значення;
      } інакше {
       біб::надрукувати("Опція входу --біб має мати значення.");
       вернути 1;
      }
    } інакше {
      біб::вивести("Неочікувана опція входу ");
      біб::надрукувати_ю8(опція.ключ);
    }

    п += 1;
  }

  п = 0;

  поки п < опції_виходу.розмір {
    змінна опція = опції_виходу.дані[п];

    якщо біб::перевірити_чи_ю8_рівні(опція.ключ, ю8"формат") {
      якщо опція.значення.заповнено == натуральне(так) {
        якщо біб::перевірити_чи_ю8_рівні(опція.значення.значення, ю8"ллвмір") {
          формат_виходу = ФОРМАТ_ВИХОДУ_ЛЛВМІР;
          формат_виходу_визначено = так;
        } інакше якщо біб::перевірити_чи_ю8_рівні(опція.значення.значення, ю8"ллвмо") {
          формат_виходу = ФОРМАТ_ВИХОДУ_ЛЛВМО;
          формат_виходу_визначено = так;
        } інакше {
          біб::надрукувати("Неочікуване значення опції виходу --формат.");
          вернути 1;
        }
      } інакше {
       біб::надрукувати("Опція виходу --формат має мати значення.");
       вернути 1;
     }
    } інакше якщо біб::перевірити_чи_ю8_рівні(опція.ключ, ю8"архітектура") {
      якщо опція.значення.заповнено == натуральне(так) {
        якщо біб::перевірити_чи_ю8_рівні(опція.значення.значення, ю8"ікс86_64") {
          пм_архітектура_виходу = ПМ::АРХІТЕКТУРА_ІКС86_64;
        } інакше {
          біб::надрукувати("Неочікуване значення опції виходу --архітектура.");
          вернути 1;
        }
      } інакше {
       біб::надрукувати("Опція виходу --архітектура має мати значення.");
       вернути 1;
     }
    } інакше якщо біб::перевірити_чи_ю8_рівні(опція.ключ, ю8"система") {
      якщо опція.значення.заповнено == натуральне(так) {
        якщо біб::перевірити_чи_ю8_рівні(опція.значення.значення, ю8"лінукс") {
          пм_система_виходу = ПМ::СИСТЕМА_ЛІНУКС;
        } інакше {
          біб::надрукувати("Неочікуване значення опції виходу --система.");
          вернути 1;
        }
      } інакше {
       біб::надрукувати("Опція виходу --система має мати значення.");
       вернути 1;
     }
    } інакше {
      біб::вивести("Неочікувана опція виходу ");
      біб::надрукувати_ю8(опція.ключ);
    }

    п += 1;
  }

  якщо формат_виходу_визначено == ні {
    якщо очікується_ЛЛВМІР(виділяч, вихід) {
      формат_виходу = ФОРМАТ_ВИХОДУ_ЛЛВМІР;
    } інакше якщо очікується_ОБДЖЕКТ(виділяч, вихід) {
      формат_виходу = ФОРМАТ_ВИХОДУ_ЛЛВМО;
    }
  }

  змінна вихід_треба_звільнити = ні;

  якщо вихід.розмір == 0 {
    змінна ю8_закінчення = ю8 { 0, пусто };
    якщо формат_виходу == ФОРМАТ_ВИХОДУ_ЛЛВМІР {
      ю8_закінчення = ю8".ллвмір";
    } інакше якщо формат_виходу == ФОРМАТ_ВИХОДУ_ЛЛВМО {
      ю8_закінчення = ю8".ллвмо";
    }
    вихід = біб::обʼєднати_ю8(виділяч, вхід, ю8_закінчення);
    вихід_треба_звільнити = так;
  }

  змінна пм_модуль = ПМ::створити_модуль(
    пусто, 
    пм_архітектура_виходу, 
    пм_система_виходу
  );

  змінна компілятор = КЦ::створити_компілятор(виділяч, пм_модуль);

  якщо КЦ::отримати_поточну_директорію_процесу(компілятор, компілятор.кореневий_шлях::адреса) == ні {
    КЦ::померти(компілятор, "Не вдалось отримати поточну директорію процесу.");
  }

  компілятор.шлях_до_біб = КЦ::клонувати_шлях(компілятор, КЦ::Шлях { шлях_до_біб.розмір, шлях_до_біб.дані });

  змінна помилка: адреса<КЦ::Помилка> = пусто;

  змінна успіх_взяття = КЦ::взяти_файл_ю8(
    компілятор,
    компілятор.глобальне_середовище,
    КЦ::Шлях { вхід.розмір, вхід.дані },
    помилка::адреса
  );

  якщо успіх_взяття == ні {
    якщо помилка.місцезнаходження != пусто {
      змінна текст_коду = помилка.місцезнаходження.текст_коду;
      біб::вивести_ю8(ю8 { текст_коду.шлях.розмір, текст_коду.шлях.дані });
      біб::вивести(":");
      біб::вивести_позитивне(помилка.місцезнаходження.рядок);
      біб::вивести(":");
      біб::вивести_позитивне(помилка.місцезнаходження.стовпець);
      біб::вивести(" помилка: ");
    }

    змінна повідомлення_ю8 = ю8 { 0, пусто };
    змінна позиція_помилки: натуральне = 0;
    якщо біб::перекодувати_т8_в_ю8(компілятор.виділяч, помилка.повідомлення, ні, повідомлення_ю8::адреса, пусто, позиція_помилки::адреса) == ні {
      КЦ::померти(компілятор, "Не вдалось перекодувати помилку повідомлення в ю8.");
    }
    біб::надрукувати_ю8(повідомлення_ю8);
    КЦ::звільнити_памʼять(компілятор, повідомлення_ю8.дані);

    якщо помилка.місцезнаходження != пусто {
      змінна текст_коду = помилка.місцезнаходження.текст_коду;

      змінна витнутний_текст = КЦ::розбирач::витнути_значення_ю8(
        ю8 { помилка.місцезнаходження.текст_коду.значення.розмір, помилка.місцезнаходження.текст_коду.значення.дані },
        помилка.місцезнаходження.позиція_в_тексті,
        100
      );

      змінна натуральне_ю8 = біб::перетворити_позитивне_на_ю8(компілятор.виділяч, помилка.місцезнаходження.рядок);
      біб::вивести_ю8(натуральне_ю8);
      біб::вивести("| ");
      біб::надрукувати_ю8(витнутний_текст.витнуте_значення);
      змінна п: натуральне = 0;
      поки п < (витнутний_текст.початок_підкреслення + натуральне_ю8.розмір + 2) {
        біб::вивести(" ");
        п += 1;
      }
      біб::надрукувати("∧");
      біб::звільнити_памʼять(виділяч, натуральне_ю8.дані);
    }

    якщо треба_знищити_залишки {
      КЦ::знищити_помилку(компілятор, помилка);
      КЦ::знищити_компілятор(компілятор);
    }

    вернути 1;
  }

  змінна значення_запису = КЦ::Байти { 0, пусто };

  якщо формат_виходу == ФОРМАТ_ВИХОДУ_ЛЛВМІР {
    ПМЛЛВМ::перетворити_на_ллвмір(пм_модуль, значення_запису.розмір::адреса, значення_запису.дані::адреса);
  } інакше якщо формат_виходу == ФОРМАТ_ВИХОДУ_ЛЛВМО {
    ПМЛЛВМ::перетворити_на_ллвмо(пм_модуль, значення_запису.розмір::адреса, значення_запису.дані::адреса);
  }

  якщо КЦ::записати_файл(компілятор, КЦ::Шлях { вихід.розмір, вихід.дані }, значення_запису) {
  } інакше {
    біб::вивести("Не вдалось записати у файл ");
    біб::надрукувати_ю8(вхід);
  }

  якщо треба_знищити_залишки {
    якщо вихід_треба_звільнити {
      біб::звільнити_памʼять(виділяч, вихід.дані);
    }
    біб::звільнити_памʼять(виділяч, значення_запису.дані);
    КЦ::знищити_компілятор(компілятор);
    ПМ::знищити_модуль(пм_модуль);
  }

  вернути 0;
}

зовнішня дія розпочати(кількість_аргументів: натуральне, аргументи: памʼять<КЦ::Байти>) -> ц32 {
  змінна статус_виходу: ц32 = 0;
  змінна виділяч = біб::отримати_системний_виділяч();

  змінна кількість_команд: натуральне = 5;

  змінна доступні_команди = цілеспрямовано::ДоступніКомандиДляРозбору<ю8> { кількість_команд, біб::виділити_памʼять<ю8>(виділяч, кількість_команд) };
  доступні_команди.дані[0] = ю8"скомпілювати";
  доступні_команди.дані[1] = ю8"кдвю";
  доступні_команди.дані[2] = ю8"ювкд";
  доступні_команди.дані[3] = ю8"допомога";
  доступні_команди.дані[4] = ю8"версія";

  змінна розібрана_команда = цілеспрямовано::зробити_розібрану_команду<ю8>();

  змінна успіх_розбору_команди = цілеспрямовано::розібрати_команду<ю8>(
    виділяч,
    цілеспрямовано::АргументиДляРозбору<ю8> { кількість_аргументів - 1, аргументи[1]::адреса як памʼять<ю8> },
    доступні_команди,
    ю8"--",
    ю8"=",
    розібрана_команда::адреса
  );

  якщо успіх_розбору_команди == ні {
    біб::надрукувати("Не вдалось розібрати команду!");
    вернути 1;
  }

  якщо біб::перевірити_чи_ю8_рівні(розібрана_команда.команда, ю8"") {
    надрукувати_допомогу();
    стрибнути вихід;
  }

  якщо біб::перевірити_чи_ю8_рівні(розібрана_команда.команда, ю8"допомога") {
    надрукувати_допомогу();
    стрибнути вихід;
  }

  якщо біб::перевірити_чи_ю8_рівні(розібрана_команда.команда, ю8"версія") {
    надрукувати_версію();
    стрибнути вихід;
  }

  якщо біб::перевірити_чи_ю8_рівні(розібрана_команда.команда, ю8"скомпілювати") {
    якщо розібрана_команда.входи.розмір < 1 {
      біб::надрукувати("Недостатньо вхідних!");
      статус_виходу = 1;
      стрибнути вихід;
    }

    якщо розібрана_команда.виходи.розмір == 0 {
      змінна п: натуральне = 0;
      поки п < розібрана_команда.входи.розмір {
        змінна вхід = розібрана_команда.входи.дані[п];

        змінна статус_компіляції = скомпілювати(
          виділяч,
          розібрана_команда.опції_програми,
          розібрана_команда.опції_команди,
          вхід.значення,
          вхід.опції,
          ю8 { 0, пусто },
          цілеспрямовано::Опції<ю8> { 0, пусто },
          розібрана_команда.входи.розмір == 1
        );

        якщо статус_компіляції != 0 {
          статус_виходу = статус_компіляції;
          стрибнути вихід;
        }

        п += 1;
      }

      стрибнути вихід;
    } інакше {
      якщо розібрана_команда.входи.розмір > 1 {
        біб::надрукувати("Команда скомпілювати з вказаними виходами може мати лише один вхід!");
        статус_виходу = 1;
        стрибнути вихід;
      }

      змінна вхід = розібрана_команда.входи.дані[0];

      змінна п: натуральне = 0;
      поки п < розібрана_команда.виходи.розмір {
        змінна вихід = розібрана_команда.виходи.дані[п];

        змінна статус_компіляції = скомпілювати(
          виділяч,
          розібрана_команда.опції_програми,
          розібрана_команда.опції_команди,
          вхід.значення,
          вхід.опції,
          вихід.значення,
          вихід.опції,
          розібрана_команда.виходи.розмір == 1
        );

        якщо статус_компіляції != 0 {
          статус_виходу = статус_компіляції;
          стрибнути вихід;
        }

        п += 1;
      }

      стрибнути вихід;
    }
  }

  якщо біб::перевірити_чи_ю8_рівні(розібрана_команда.команда, ю8"кдвю") {
    якщо розібрана_команда.входи.розмір < 1 {
      біб::надрукувати("Недостатньо вхідних!");
      статус_виходу = 1;
      стрибнути вихід;
    }

    змінна виділяч = біб::отримати_системний_виділяч();

    якщо розібрана_команда.виходи.розмір == 0 {
      змінна п: натуральне = 0;
      поки п < розібрана_команда.входи.розмір {
        змінна вхід = розібрана_команда.входи.дані[п];

        змінна шлях_входу = КЦ::Шлях { вхід.значення.розмір, вхід.значення.дані };
        змінна байти_входу = КЦ::Байти { 0, пусто };

        змінна успіх = ні;
        __КЦ__прочитати_файл(виділяч, шлях_входу::адреса, байти_входу::адреса, успіх::адреса);

        якщо не успіх {
          біб::вивести("Не вдалось прочитати файл ");
          біб::надрукувати_ю8(вхід.значення);
          статус_виходу = 1;
          стрибнути вихід;
        }

        змінна значення_виходу = ю8 { 0, пусто };
        змінна позиція_помилки: натуральне = 0;

        якщо не біб::перекодувати_т8_в_ю8(виділяч, т8 { байти_входу.розмір, байти_входу.дані }, ні, значення_виходу::адреса, пусто, позиція_помилки::адреса) {
          біб::вивести("Не вдалось перекодувати файл ");
          біб::надрукувати_ю8(вхід.значення);
          статус_виходу = 1;
          стрибнути вихід;
        }

        біб::вивести_байти(значення_виходу.розмір, значення_виходу.дані);
        біб::вивести("\р");

        п += 1;
      }

      стрибнути вихід;
    } інакше {
      якщо розібрана_команда.входи.розмір > 1 {
        біб::надрукувати("Команда кдвю з вказаними виходами може мати лише один вхід!");
        статус_виходу = 1;
        стрибнути вихід;
      }

      змінна вхід = розібрана_команда.входи.дані[0];

      змінна п: натуральне = 0;
      поки п < розібрана_команда.виходи.розмір {
        змінна вихід = розібрана_команда.виходи.дані[п];

        змінна шлях_входу = КЦ::Шлях { вхід.значення.розмір, вхід.значення.дані };
        змінна байти_входу = КЦ::Байти { 0, пусто };

        змінна успіх = ні;
        __КЦ__прочитати_файл(виділяч, шлях_входу::адреса, байти_входу::адреса, успіх::адреса);

        якщо не успіх {
          біб::вивести("Не вдалось прочитати файл ");
          біб::надрукувати_ю8(вхід.значення);
          статус_виходу = 1;
          стрибнути вихід;
        }

        змінна значення_виходу = ю8 { 0, пусто };
        змінна позиція_помилки: натуральне = 0;

        якщо не біб::перекодувати_т8_в_ю8(виділяч, т8 { байти_входу.розмір, байти_входу.дані }, ні, значення_виходу::адреса, пусто, позиція_помилки::адреса) {
          біб::вивести("Не вдалось перекодувати файл ");
          біб::надрукувати_ю8(вхід.значення);
          статус_виходу = 1;
          стрибнути вихід;
        }

        змінна шлях_виходу = КЦ::Шлях { вихід.значення.розмір, вихід.значення.дані };
        змінна байти_виходу = КЦ::Байти { значення_виходу.розмір, значення_виходу.дані };

        __КЦ__записати_файл(виділяч, шлях_виходу::адреса, байти_виходу::адреса, успіх::адреса);

        якщо не успіх {
          біб::вивести("Не вдалось записати файл ");
          біб::надрукувати_ю8(вихід.значення);
          статус_виходу = 1;
          стрибнути вихід;
        }

        п += 1;
      }

      стрибнути вихід;
    }
  }

  якщо біб::перевірити_чи_ю8_рівні(розібрана_команда.команда, ю8"ювкд") {
    якщо розібрана_команда.входи.розмір < 1 {
      біб::надрукувати("Недостатньо вхідних!");
      статус_виходу = 1;
      стрибнути вихід;
    }

    змінна виділяч = біб::отримати_системний_виділяч();

    якщо розібрана_команда.виходи.розмір == 0 {
      змінна п: натуральне = 0;
      поки п < розібрана_команда.входи.розмір {
        змінна вхід = розібрана_команда.входи.дані[п];

        змінна шлях_входу = КЦ::Шлях { вхід.значення.розмір, вхід.значення.дані };
        змінна байти_входу = КЦ::Байти { 0, пусто };

        змінна успіх = ні;
        __КЦ__прочитати_файл(виділяч, шлях_входу::адреса, байти_входу::адреса, успіх::адреса);

        якщо не успіх {
          біб::вивести("Не вдалось прочитати файл ");
          біб::надрукувати_ю8(вхід.значення);
          статус_виходу = 1;
          стрибнути вихід;
        }

        змінна значення_виходу = т8 { 0, пусто };
        змінна позиція_помилки: натуральне = 0;

        якщо не біб::перекодувати_ю8_в_т8(виділяч, ю8 { байти_входу.розмір, байти_входу.дані }, ні, ні, значення_виходу::адреса, пусто, позиція_помилки::адреса) {
          біб::вивести("Не вдалось перекодувати файл ");
          біб::надрукувати_ю8(вхід.значення);
          статус_виходу = 1;
          стрибнути вихід;
        }

        біб::вивести_байти(значення_виходу.розмір, значення_виходу.дані);
        біб::вивести("\р");

        п += 1;
      }

      стрибнути вихід;
    } інакше {
      якщо розібрана_команда.входи.розмір > 1 {
        біб::надрукувати("Команда кдвю з вказаними виходами може мати лише один вхід!");
        статус_виходу = 1;
        стрибнути вихід;
      }

      змінна вхід = розібрана_команда.входи.дані[0];

      змінна п: натуральне = 0;
      поки п < розібрана_команда.виходи.розмір {
        змінна вихід = розібрана_команда.виходи.дані[п];

        змінна шлях_входу = КЦ::Шлях { вхід.значення.розмір, вхід.значення.дані };
        змінна байти_входу = КЦ::Байти { 0, пусто };

        змінна успіх = ні;
        __КЦ__прочитати_файл(виділяч, шлях_входу::адреса, байти_входу::адреса, успіх::адреса);

        якщо не успіх {
          біб::вивести("Не вдалось прочитати файл ");
          біб::надрукувати_ю8(вхід.значення);
          статус_виходу = 1;
          стрибнути вихід;
        }

        змінна значення_виходу = т8 { 0, пусто };
        змінна позиція_помилки: натуральне = 0;

        якщо не біб::перекодувати_ю8_в_т8(виділяч, ю8 { байти_входу.розмір, байти_входу.дані }, ні, ні, значення_виходу::адреса, пусто, позиція_помилки::адреса) {
          біб::вивести("Не вдалось перекодувати файл ");
          біб::надрукувати_ю8(вхід.значення);
          статус_виходу = 1;
          стрибнути вихід;
        }

        змінна шлях_виходу = КЦ::Шлях { вихід.значення.розмір, вихід.значення.дані };
        змінна байти_виходу = КЦ::Байти { значення_виходу.розмір, значення_виходу.дані };

        __КЦ__записати_файл(виділяч, шлях_виходу::адреса, байти_виходу::адреса, успіх::адреса);

        якщо не успіх {
          біб::вивести("Не вдалось записати файл ");
          біб::надрукувати_ю8(вихід.значення);
          статус_виходу = 1;
          стрибнути вихід;
        }

        п += 1;
      }

      стрибнути вихід;
    }
  }

  біб::надрукувати("Невідома команда!");
  статус_виходу = 1;

вихід:
  цілеспрямовано::знищити_розібрану_команду<ю8>(виділяч, розібрана_команда);
  біб::звільнити_памʼять(виділяч, доступні_команди.дані);
  вернути статус_виходу;
}