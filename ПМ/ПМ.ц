взяти визначення ./ПМ;
взяти біб Виділяч;
взяти біб Кодування;
взяти біб Реєстр;
взяти біб КД;

секція ПМ {
  місцева дія створити_сховище_назв() -> адреса<СховищеНазв> {
    змінна виділяч = біб::отримати_системний_виділяч();

    змінна сн = біб::виділити<СховищеНазв>(виділяч);
    
    сн.розмір = 0;
    сн.дані = пусто;
    сн.вмісткість = 0;
    
    вернути сн;
  }

  місцева дія знищити_сховище_назв(сховище: адреса<СховищеНазв>) {
    змінна виділяч = біб::отримати_системний_виділяч();

    змінна п: натуральне = 0;
    поки п < сховище.розмір {
      біб::звільнити_памʼять(виділяч, сховище.дані[п].значення.дані);
      біб::звільнити(виділяч, сховище.дані[п]);

      п += 1;
    }

    біб::звільнити_памʼять(виділяч, сховище.дані);
    біб::звільнити(виділяч, сховище);
  }

  місцева дія отримати_назву(сховище: адреса<СховищеНазв>, значення: т8) -> адреса<Назва> {
    змінна знайдена_назва: адреса<Назва> = пусто;

    змінна п: натуральне = 0;
    поки п < сховище.розмір {
      якщо КД::перевірити_чи_т8_рівні(сховище.дані[п].значення, значення) {
        вернути сховище.дані[п];
      }
      
      п += 1;
    }

    змінна виділяч = біб::отримати_системний_виділяч();

    змінна нова_назва = біб::виділити<Назва>(виділяч);

    нова_назва.значення = т8 {
      значення.розмір,
      біб::виділити_памʼять<п8>(виділяч, значення.розмір)
    };

    п = 0;
    поки п < значення.розмір {
      нова_назва.значення.дані[п] = значення.дані[п];
      
      п += 1;
    }

    якщо сховище.розмір == сховище.вмісткість {
      сховище.вмісткість += 1;
      сховище.дані = біб::перевиділити_памʼять<адреса<Назва>>(виділяч, сховище.дані, сховище.вмісткість);
    }

    сховище.дані[сховище.розмір] = нова_назва;
    сховище.розмір += 1;

    вернути нова_назва;
  }

  // потім: це працює неправильно
  місцева дія отримати_назву_без_копіювання(сховище: адреса<СховищеНазв>, значення: т8) -> адреса<Назва> {
    змінна виділяч = біб::отримати_системний_виділяч();

    змінна знайдена_назва: адреса<Назва> = пусто;

    змінна п: натуральне = 0;
    поки п < сховище.розмір {
      якщо КД::перевірити_чи_т8_рівні(сховище.дані[п].значення, значення) {
        // біб::звільнити_памʼять(виділяч, значення.дані); // потім: значення могло бути виділене іншим виділячем,
                                                        //        треба тут виправити в майбутньому
        
        вернути сховище.дані[п];
      }
      
      п += 1;
    }

    змінна нова_назва = біб::виділити<Назва>(виділяч);

    нова_назва.значення = значення;

    якщо сховище.розмір == сховище.вмісткість {
      сховище.вмісткість += 1;
      сховище.дані = біб::перевиділити_памʼять<адреса<Назва>>(виділяч, сховище.дані, сховище.вмісткість);
    }

    сховище.дані[сховище.розмір] = нова_назва;
    сховище.розмір += 1;

    вернути нова_назва;
  }
}

секція ПМ {
  дія покласти_крок(інструкція: адреса<Інструкція>, крок: адреса<Крок>) {
    змінна пм_значення = інструкція як адреса<Значення>;
    змінна дані_інструкції = пм_значення.дані як ДаніЗначенняІнструкція;

    якщо дані_інструкції.кроки.розмір == дані_інструкції.кроки.вмісткість {
      дані_інструкції.кроки.вмісткість += 1;
      дані_інструкції.кроки.дані = біб::перевиділити_памʼять<адреса<Крок>>(дані_інструкції.модуль.виділяч, дані_інструкції.кроки.дані, дані_інструкції.кроки.вмісткість);
    }

    дані_інструкції.кроки.дані[дані_інструкції.кроки.розмір] = крок;
    дані_інструкції.кроки.розмір += 1;

    пм_значення.дані = дані_інструкції;
  }

  місцева дія покласти_параметр(модуль: адреса<Модуль>, параметри: адреса<Параметри>, параметр: Параметр) {
    якщо параметри.розмір == параметри.вмісткість {
      параметри.вмісткість += 1;
      параметри.дані = біб::перевиділити_памʼять<Параметр>(модуль.виділяч, параметри.дані, параметри.вмісткість);
    }

    параметри.дані[параметри.розмір] = параметр;
    параметри.розмір += 1;
  }

  дія виділити_тип(модуль: адреса<Модуль>, вид: натуральне) -> адреса<Тип> {
    змінна тип = біб::виділити<Тип>(модуль.виділяч);

    тип.модуль = модуль;
    тип.вид = вид;
    тип.дані_компіляції = пусто;

    вернути тип;
  }

  дія виділити_значення(модуль: адреса<Модуль>, вид: натуральне, тип: адреса<Тип>) -> адреса<Значення> {
    змінна значення = біб::виділити<Значення>(модуль.виділяч);

    значення.модуль = модуль;
    значення.вид = вид;
    значення.тип = тип;
    значення.дані_компіляції = пусто;

    вернути значення;
  }

  дія змішати_назви_реєстру<Т>(реєстр: адреса<біб::Реєстр<адреса<Назва>, Т>>, назва: адреса<Назва>) -> натуральне {
    вернути назва.значення.розмір;
  }

  дія перевірити_назви_реєстру<Т>(реєстр: адреса<біб::Реєстр<адреса<Назва>, Т>>, а: адреса<Назва>, б: адреса<Назва>) -> логічне {
    вернути а == б;
  }

  дія виділити_реєстр_по_назвах<Т>(виділяч: адреса<біб::Виділяч>) -> адреса<біб::Реєстр<адреса<Назва>, Т>> {
    вернути біб::виділити_реєстр<адреса<Назва>, Т>(
      виділяч,
      0,
      пусто,
      змішати_назви_реєстру<Т>,
      перевірити_назви_реєстру<Т>,
      пусто,
      пусто
    );
  }

  місцева дія створити_модуль(назва: адреса<Назва>, архітектура: натуральне, система: натуральне) -> адреса<Модуль> {
    змінна виділяч = біб::отримати_системний_виділяч();
    
    змінна модуль = біб::виділити<Модуль>(виділяч);

    модуль.виділяч = виділяч;
    модуль.типи = виділити_реєстр_по_назвах<адреса<Тип>>(модуль.виділяч);
    модуль.глобальні = виділити_реєстр_по_назвах<адреса<Значення>>(модуль.виділяч);
    
    модуль.тип_ніщо = виділити_тип(модуль, ВидТипуНеподільний);
    модуль.тип_адреса = виділити_тип(модуль, ВидТипуНеподільний);
    модуль.тип_логічне = виділити_тип(модуль, ВидТипуНеподільний);
    модуль.тип_п8 = виділити_тип(модуль, ВидТипуНеподільний);
    модуль.тип_п16 = виділити_тип(модуль, ВидТипуНеподільний);
    модуль.тип_п32 = виділити_тип(модуль, ВидТипуНеподільний);
    модуль.тип_п64 = виділити_тип(модуль, ВидТипуНеподільний);
    модуль.тип_ц8 = виділити_тип(модуль, ВидТипуНеподільний);
    модуль.тип_ц16 = виділити_тип(модуль, ВидТипуНеподільний);
    модуль.тип_ц32 = виділити_тип(модуль, ВидТипуНеподільний);
    модуль.тип_ц64 = виділити_тип(модуль, ВидТипуНеподільний);
    модуль.тип_р32 = виділити_тип(модуль, ВидТипуНеподільний);
    модуль.тип_р64 = виділити_тип(модуль, ВидТипуНеподільний);

    модуль.значення_пусто = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_адреса);
    модуль.значення_пусто.дані = п64(0);
    
    модуль.значення_так = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_логічне);
    модуль.значення_так.дані = так;
    
    модуль.значення_ні = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_логічне);
    модуль.значення_ні.дані = ні;

    вернути модуль;
  }

  місцева дія створити_інструкцію(модуль: адреса<Модуль>, видимість: натуральне, назва: адреса<Назва>, параметри: Параметри, тип_результату: адреса<Тип>) -> адреса<Інструкція> {
    змінна тип_інструкції = створити_тип_інструкції(модуль, параметри, тип_результату);
    змінна значення_інструкції = виділити_значення(модуль, ВидЗначенняІнструкція, тип_інструкції);

    змінна значення_аргументів = біб::виділити_памʼять<адреса<Значення>>(модуль.виділяч, параметри.розмір);
    змінна п: натуральне = 0;
    поки п < параметри.розмір {
      значення_аргументів[п] = виділити_значення(модуль, ВидЗначенняАргумент, параметри.дані[п].тип);
      значення_аргументів[п].дані = ДаніЗначенняАргумент { п, значення_інструкції };
      
      п += 1;
    }

    значення_інструкції.дані = ДаніЗначенняІнструкція {
      модуль = модуль,
      видимість = видимість,
      назва = назва,
      тип = тип_інструкції,
      кроки = Кроки { 0, пусто, 0 },
      значення_аргументів = ЗначенняАргументів { параметри.розмір, значення_аргументів, параметри.розмір },
    };

    біб::змінити_в_реєстрі<адреса<Назва>, адреса<Значення>>(модуль.глобальні, назва, значення_інструкції);

    вернути значення_інструкції як адреса<Інструкція>;
  }

  місцева дія отримати_тип_інструкції(інструкція: адреса<Інструкція>) -> адреса<Тип> {
    змінна значення_інструкції = інструкція як адреса<Значення>;
    змінна дані_інструкції = значення_інструкції.дані як ДаніЗначенняІнструкція;
    
    вернути дані_інструкції.тип;
  }

  місцева дія створити_тип_інструкції(модуль: адреса<Модуль>, параметри: Параметри, тип_результату: адреса<Тип>) -> адреса<Тип> {
    змінна тип = виділити_тип(модуль, ВидТипуІнструкція);

    тип.дані = ДаніТипуІнструкція { параметри, тип_результату };

    вернути тип;
  }

  місцева дія отримати_значення_аргумента_інструкції(інструкція: адреса<Інструкція>, позиція: натуральне) -> адреса<Значення> {
    змінна значення_інструкції = інструкція як адреса<Значення>;
    змінна дані_інструкції = значення_інструкції.дані як ДаніЗначенняІнструкція;

    вернути дані_інструкції.значення_аргументів.дані[позиція];
  }

  місцева дія створити_крок(інструкція: адреса<Інструкція>, назва: адреса<Назва>) -> адреса<Крок> {
    змінна значення_інструкції = інструкція як адреса<Значення>;
    змінна дані_інструкції = значення_інструкції.дані як ДаніЗначенняІнструкція;

    змінна крок = біб::виділити<Крок>(дані_інструкції.модуль.виділяч);

    крок.інструкція = інструкція;
    крок.назва = назва;
    крок.вказівки = Вказівки { 0, пусто, 0 };
    крок.дані_компіляції = пусто;

    покласти_крок(інструкція, крок);
    
    вернути крок;
  }

  місцева дія перевірити_чи_крок_закінчується_стрибком(крок: адреса<Крок>) -> логічне {
    якщо крок.вказівки.розмір > 0 {
      якщо крок.вказівки.дані[крок.вказівки.розмір - 1].вид == ВидВказівкиСтрибнути {
        вернути так;
      }
    }

    вернути ні;
  }

  місцева дія створити_структуру(модуль: адреса<Модуль>, назва: адреса<Назва>, параметри: Параметри) -> адреса<Тип> {
    змінна тип = виділити_тип(модуль, ВидТипуСтруктура);

    тип.дані = ДаніТипуСтруктура { назва, параметри };

    біб::змінити_в_реєстрі<адреса<Назва>, адреса<Тип>>(модуль.типи, назва, тип);

    вернути тип;
  }

  місцева дія заповнити_параметри_структури(тип: адреса<Тип>, параметри: Параметри) {
    якщо тип.вид != ВидТипуСтруктура {
      вернути;
    }

    змінна дані = тип.дані як ДаніТипуСтруктура;
    дані.параметри = параметри; 
    
    тип.дані = дані;
  }

  дія отримати_модуль_з_інструкції(інструкція: адреса<Інструкція>) -> адреса<Модуль> {
    змінна значення_інструкції = інструкція як адреса<Значення>;
    змінна дані_інструкції = значення_інструкції.дані як ДаніЗначенняІнструкція;

    вернути дані_інструкції.модуль;
  }

  дія покласти_вказівку(крок: адреса<Крок>, вказівка: адреса<Значення>) {
    якщо крок.вказівки.розмір == крок.вказівки.вмісткість {
      крок.вказівки.вмісткість += 1;
      крок.вказівки.дані = біб::перевиділити_памʼять<адреса<Значення>>(отримати_модуль_з_інструкції(крок.інструкція).виділяч, крок.вказівки.дані, крок.вказівки.вмісткість);
    }

    крок.вказівки.дані[крок.вказівки.розмір] = вказівка;
    крок.вказівки.розмір += 1;
  }

  місцева дія виконати_дію(крок: адреса<Крок>, тип: адреса<Тип>, значення: адреса<Значення>, кількість_аргументів: натуральне, аргументи: памʼять<адреса<Значення>>) -> адреса<Значення> {
    змінна модуль = отримати_модуль_з_інструкції(крок.інструкція);
    змінна дані_типу_інструкція = тип.дані як ДаніТипуІнструкція;

    змінна копія_аргументів = біб::виділити_памʼять<адреса<Значення>>(модуль.виділяч, кількість_аргументів);
    змінна п: натуральне = 0;
    поки п < кількість_аргументів {
      копія_аргументів[п] = аргументи[п];
     
      п += 1;
    }

    змінна значення_вказівки = виділити_значення(модуль, ВидЗначенняВказівка, дані_типу_інструкція.тип_результату);

    значення_вказівки.дані = ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиВиконати,
      дані = ДаніВказівкиВиконати { тип, значення, кількість_аргументів, копія_аргументів }
    };

    покласти_вказівку(крок, значення_вказівки);

    вернути значення_вказівки;
  }

  місцева дія отримати_розмір_типу_для_виділення(модуль: адреса<Модуль>, тип: адреса<Тип>) -> натуральне {
    якщо тип == пусто {
      вернути 0;
    }

    якщо тип == модуль.тип_логічне {
      вернути 1;
    } інакше якщо тип == модуль.тип_п8 {
      вернути 1;
    } інакше якщо тип == модуль.тип_п16 {
      вернути 2;
    } інакше якщо тип == модуль.тип_п32 {
      вернути 4;
    } інакше якщо тип == модуль.тип_п64 {
      вернути 8;
    } інакше якщо тип == модуль.тип_ц8 {
      вернути 1;
    } інакше якщо тип == модуль.тип_ц16 {
      вернути 2;
    } інакше якщо тип == модуль.тип_ц32 {
      вернути 4;
    } інакше якщо тип == модуль.тип_ц64 {
      вернути 8;
    } інакше якщо тип == модуль.тип_р32 {
      вернути 4;
    } інакше якщо тип == модуль.тип_р64 {
      вернути 8;
    } інакше якщо тип == модуль.тип_адреса {
      вернути 8;
    } інакше якщо тип.вид == ВидТипуСтруктура {
      змінна дані_структури = тип.дані як ДаніТипуСтруктура;

      змінна розмір: натуральне = 0;
      змінна п: натуральне = 0;
      поки п < дані_структури.параметри.розмір {
        змінна розмір_параметра = отримати_розмір_типу_для_виділення(модуль, дані_структури.параметри.дані[п].тип);
        
        якщо розмір_параметра < 8 {
          розмір_параметра = 8;
        }
        
        розмір += розмір_параметра;
        п += 1;
      }

      вернути розмір;
    }

    вернути 0;
  }

  місцева дія створити_глобальну(модуль: адреса<Модуль>, назва: адреса<Назва>, видимість: натуральне, тип: адреса<Тип>) -> адреса<Значення> {
    змінна значення_глобальної = виділити_значення(модуль, ВидЗначенняГлобальна, тип);

    значення_глобальної.дані = ДаніЗначенняГлобальна { видимість, назва };

    біб::змінити_в_реєстрі<адреса<Назва>, адреса<Значення>>(модуль.глобальні, назва, значення_глобальної);

    вернути значення_глобальної;
  }

  місцева дія отримати_значення_пусто(модуль: адреса<Модуль>) -> адреса<Значення> {
    вернути модуль.значення_пусто;
  }

  місцева дія отримати_тип_ніщо(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_ніщо;
  }

  місцева дія отримати_тип_адреса(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_адреса;
  }

  місцева дія отримати_тип_логічне(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_логічне;
  }

  місцева дія отримати_тип_ц8(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_ц8;
  }

  місцева дія отримати_тип_ц16(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_ц16;
  }

  місцева дія отримати_тип_ц32(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_ц32;
  }

  місцева дія отримати_тип_ц64(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_ц64;
  }

  місцева дія отримати_тип_п8(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_п8;
  }

  місцева дія отримати_тип_п16(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_п16;
  }

  місцева дія отримати_тип_п32(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_п32;
  }

  місцева дія отримати_тип_п64(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_п64;
  }

  місцева дія отримати_тип_р32(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_р32;
  }

  місцева дія отримати_тип_р64(модуль: адреса<Модуль>) -> адреса<Тип> {
    вернути модуль.тип_р64;
  }

  місцева дія створити_логічне(модуль: адреса<Модуль>, значення: логічне) -> адреса<Значення> {
    якщо значення {
      вернути модуль.значення_так;
    }

    вернути модуль.значення_ні;
  }

  місцева дія створити_ц8(модуль: адреса<Модуль>, значення: ц8) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_ц8);

    пм_значення.дані = значення;

    вернути пм_значення;
  }

  місцева дія створити_ц16(модуль: адреса<Модуль>, значення: ц16) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_ц16);

    пм_значення.дані = значення;

    вернути пм_значення;
  }

  місцева дія створити_ц32(модуль: адреса<Модуль>, значення: ц32) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_ц32);

    пм_значення.дані = значення;

    вернути пм_значення;
  }

  місцева дія створити_ц64(модуль: адреса<Модуль>, значення: ц64) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_ц64);

    пм_значення.дані = значення;

    вернути пм_значення;
  }

  місцева дія створити_п8(модуль: адреса<Модуль>, значення: п8) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_п8);

    пм_значення.дані = значення;

    вернути пм_значення;
  }

  місцева дія створити_п16(модуль: адреса<Модуль>, значення: п16) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_п16);

    пм_значення.дані = значення;

    вернути пм_значення;
  }

  місцева дія створити_п32(модуль: адреса<Модуль>, значення: п32) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_п32);

    пм_значення.дані = значення;

    вернути пм_значення;
  }

  місцева дія створити_п64(модуль: адреса<Модуль>, значення: п64) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_п64);

    пм_значення.дані = значення;

    вернути пм_значення;
  }

  місцева дія створити_д32(модуль: адреса<Модуль>, значення: д32) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_р32);

    пм_значення.дані = значення;

    вернути пм_значення;
  }

  місцева дія створити_д64(модуль: адреса<Модуль>, значення: д64) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняЧисло, модуль.тип_р64);

    пм_значення.дані = значення;

    вернути пм_значення;
  }

  місцева дія створити_константу_даних(модуль: адреса<Модуль>, розмір: натуральне, дані: памʼять<п8>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняГлобальнаКонстантаДаних, модуль.тип_адреса);

    пм_значення.дані = ДаніЗначенняГлобальнаКонстантаДаних { розмір, дані };

    вернути пм_значення;
  }

  місцева дія створити_обʼєкт(модуль: адреса<Модуль>, тип: адреса<Тип>, кількість_аргументів: натуральне, аргументи: памʼять<адреса<Значення>>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняОбʼєкт, тип);

    пм_значення.дані = ДаніЗначенняОбʼєкт { кількість_аргументів, аргументи };

    вернути пм_значення;
  }

  місцева дія створити_пусте_значення(модуль: адреса<Модуль>, тип: адреса<Тип>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення(модуль, ВидЗначенняПустийОбʼєкт, тип);

    вернути пм_значення;
  }
  
  дія виділити_значення_вказівки(крок: адреса<Крок>, тип: адреса<Тип>, дані: ДаніЗначенняВказівка) -> адреса<Значення> {
    змінна модуль = отримати_модуль_з_інструкції(крок.інструкція);

    змінна пм_значення = виділити_значення(модуль, ВидЗначенняВказівка, тип);

    пм_значення.дані = дані;

    вернути пм_значення;
  }

  місцева дія вказівка_накопичити(крок: адреса<Крок>, тип: адреса<Тип>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, отримати_модуль_з_інструкції(крок.інструкція).тип_адреса, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиНакопичити,
      дані = ДаніВказівкиНакопичити { тип }
    });

    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_додати(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, ліво.тип, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиДодати,
      дані = ДаніДвійноїВказівки { ліво, право }
    });

    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_відняти(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, ліво.тип, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиВідняти,
      дані = ДаніДвійноїВказівки { ліво, право }
    });

    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_помножити(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, ліво.тип, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиПомножити,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_поділити(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, ліво.тип, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиПоділити,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_остача(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, ліво.тип, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиОстача,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_рівно(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, отримати_модуль_з_інструкції(крок.інструкція).тип_логічне, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиРівно,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_не_рівно(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, отримати_модуль_з_інструкції(крок.інструкція).тип_логічне, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиНеРівно,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_більше(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, отримати_модуль_з_інструкції(крок.інструкція).тип_логічне, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиБільше,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_менше(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, отримати_модуль_з_інструкції(крок.інструкція).тип_логічне, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиМенше,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_більше_рівно(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, отримати_модуль_з_інструкції(крок.інструкція).тип_логічне, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиБільшеРівно,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_менше_рівно(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, отримати_модуль_з_інструкції(крок.інструкція).тип_логічне, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиМеншеРівно,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_зсунути_вліво(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, ліво.тип, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиЗсунутиВліво,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_зсунути_вправо(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, ліво.тип, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиЗсунутиВправо,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_двійкове_і(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, ліво.тип, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиДвійковеІ,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_двійкове_або(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, ліво.тип, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиДвійковеАБО,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_двійкове_виключне_або(крок: адреса<Крок>, ліво: адреса<Значення>, право: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, ліво.тип, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиДвійковеВиключнеАБО,
      дані = ДаніДвійноїВказівки { ліво, право }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_двійкове_заперечення(крок: адреса<Крок>, значення: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, значення.тип, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиДвійковеЗаперечення,
      дані = ДаніОдинарноїВказівки { значення }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія покласти_вказівку_перетворити(крок: адреса<Крок>, значення: адреса<Значення>, очікуваний_тип: адреса<Тип>) -> адреса<Значення> {
    змінна пм_значення = виділити_значення_вказівки(крок, очікуваний_тип, ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиПеретворити,
      дані = ДаніВказівкиПеретворити { значення, очікуваний_тип }
    });
    
    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_перетворити(крок: адреса<Крок>, значення: адреса<Значення>, очікуваний_тип: адреса<Тип>) -> адреса<Значення> {
    вернути покласти_вказівку_перетворити(крок, значення, очікуваний_тип);
  }

  місцева дія вказівка_як(крок: адреса<Крок>, значення: адреса<Значення>, тип: адреса<Тип>) -> адреса<Значення> {
    змінна пм_значення = біб::виділити<Значення>(отримати_модуль_з_інструкції(крок.інструкція).виділяч);

    пм_значення.вид = ВидЗначенняВказівка;
    пм_значення.тип = отримати_модуль_з_інструкції(крок.інструкція).тип_адреса;
    пм_значення.дані = ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиЯк,
      дані = ДаніВказівкиЯк { значення, тип }
    };
    пм_значення.дані_компіляції = пусто;

    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_отримати_адресу_елемента(крок: адреса<Крок>, тип: адреса<Тип>, значення: адреса<Значення>, кількість_позицій: натуральне, позиції: памʼять<адреса<Значення>>) -> адреса<Значення> {
    змінна модуль = отримати_модуль_з_інструкції(крок.інструкція);
    
    змінна пм_значення = біб::виділити<Значення>(модуль.виділяч);

    змінна копія_позиції = біб::виділити_памʼять<адреса<Значення>>(модуль.виділяч, кількість_позицій);

    змінна п: натуральне = 0;
    поки п < кількість_позицій {
      копія_позиції[п] = позиції[п];
      
      п += 1;
    }

    пм_значення.модуль = модуль;
    пм_значення.вид = ВидЗначенняВказівка;
    пм_значення.тип = отримати_модуль_з_інструкції(крок.інструкція).тип_адреса;
    пм_значення.дані = ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиОтриматиАдресуЕлемента,
      дані = ДаніВказівкиОтриматиАдресуЕлемента { тип, значення, кількість_позицій, копія_позиції }
    };
    пм_значення.дані_компіляції = пусто;

    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_отримати_значення(крок: адреса<Крок>, значення: адреса<Значення>, позиція: натуральне) -> адреса<Значення> {
    змінна пм_значення = біб::виділити<Значення>(отримати_модуль_з_інструкції(крок.інструкція).виділяч);

    пм_значення.вид = ВидЗначенняВказівка;
    пм_значення.тип = значення.тип;
    пм_значення.дані = ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиОтриматиЗначення,
      дані = ДаніВказівкиОтриматиЗначення { значення, позиція }
    };
    пм_значення.дані_компіляції = пусто;

    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_стрибнути(крок: адреса<Крок>, куди: адреса<Крок>) -> адреса<Стрибок> {
    змінна пм_значення = біб::виділити<Значення>(отримати_модуль_з_інструкції(крок.інструкція).виділяч);

    пм_значення.вид = ВидЗначенняВказівка;
    пм_значення.тип = отримати_модуль_з_інструкції(крок.інструкція).тип_адреса;
    пм_значення.дані = ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиСтрибнути,
      дані = ДаніВказівкиСтрибнути { куди }
    };
    пм_значення.дані_компіляції = пусто;

    покласти_вказівку(крок, пм_значення);

    вернути пм_значення як адреса<Стрибок>;
  }

  місцева дія змінити_крок_стрибка(стрибок: адреса<Стрибок>, куди: адреса<Крок>) {
    змінна пм_значення = стрибок як адреса<Значення>;

    якщо пм_значення.вид == ВидЗначенняВказівка {
      змінна пм_дані = пм_значення.дані як ДаніЗначенняВказівка;

      якщо пм_дані.вид == ВидВказівкиСтрибнути {
        змінна пм_дані_стрибка = пм_дані.дані як ДаніВказівкиСтрибнути;
    
        пм_дані_стрибка.куди = куди;
  
        пм_дані.дані = пм_дані_стрибка;
        пм_значення.дані = пм_дані;
      }
    }
  }

  місцева дія вказівка_стрибнути_якщо(крок: адреса<Крок>, значення: адреса<Значення>, якщо_так: адреса<Крок>, якщо_ні: адреса<Крок>) -> адреса<Стрибок> {
    змінна пм_значення = біб::виділити<Значення>(отримати_модуль_з_інструкції(крок.інструкція).виділяч);

    пм_значення.вид = ВидЗначенняВказівка;
    пм_значення.тип = отримати_модуль_з_інструкції(крок.інструкція).тип_адреса;
    пм_значення.дані = ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиСтрибнутиЯкщо,
      дані = ДаніВказівкиСтрибнутиЯкщо { значення, якщо_так, якщо_ні }
    };
    пм_значення.дані_компіляції = пусто;

    покласти_вказівку(крок, пм_значення);

    вернути пм_значення як адреса<Стрибок>;
  }

  місцева дія вказівка_записати(крок: адреса<Крок>, значення: адреса<Значення>, куди: адреса<Значення>) {
    змінна пм_значення = біб::виділити<Значення>(отримати_модуль_з_інструкції(крок.інструкція).виділяч);

    пм_значення.вид = ВидЗначенняВказівка;
    пм_значення.тип = отримати_модуль_з_інструкції(крок.інструкція).тип_ніщо;
    пм_значення.дані = ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиЗаписати,
      дані = ДаніВказівкиЗаписати { значення, куди }
    };
    пм_значення.дані_компіляції = пусто;

    покласти_вказівку(крок, пм_значення);

    вернути;
  }

  місцева дія вказівка_прочитати(крок: адреса<Крок>, тип: адреса<Тип>, звідки: адреса<Значення>) -> адреса<Значення> {
    змінна пм_значення = біб::виділити<Значення>(отримати_модуль_з_інструкції(крок.інструкція).виділяч);

    пм_значення.вид = ВидЗначенняВказівка;
    пм_значення.тип = тип;
    пм_значення.дані = ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиПрочитати,
      дані = ДаніВказівкиПрочитати { тип, звідки }
    };
    пм_значення.дані_компіляції = пусто;

    покласти_вказівку(крок, пм_значення);

    вернути пм_значення;
  }

  місцева дія вказівка_вернути(крок: адреса<Крок>) {
    змінна пм_значення = біб::виділити<Значення>(отримати_модуль_з_інструкції(крок.інструкція).виділяч);

    пм_значення.вид = ВидЗначенняВказівка;
    пм_значення.тип = отримати_модуль_з_інструкції(крок.інструкція).тип_ніщо;
    пм_значення.дані = ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиВернути,
      дані = ДаніВказівкиВернути { пусто }
    };
    пм_значення.дані_компіляції = пусто;

    покласти_вказівку(крок, пм_значення);

    вернути;
  }

  місцева дія вказівка_вернути_значення(крок: адреса<Крок>, значення: адреса<Значення>) {
    змінна пм_значення = біб::виділити<Значення>(отримати_модуль_з_інструкції(крок.інструкція).виділяч);

    пм_значення.вид = ВидЗначенняВказівка;
    пм_значення.тип = отримати_модуль_з_інструкції(крок.інструкція).тип_ніщо;
    пм_значення.дані = ДаніЗначенняВказівка {
      крок = крок,
      вид = ВидВказівкиВернути,
      дані = ДаніВказівкиВернути { значення }
    };
    пм_значення.дані_компіляції = пусто;

    покласти_вказівку(крок, пм_значення);

    вернути;
  }

  місцева дія знищити_модуль(модуль: адреса<Модуль>) {

  }
}