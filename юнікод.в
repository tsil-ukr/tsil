секція біб {
  секція юнікод {
    місцева дія дізнатись_розмір_символа_юнікоду(перший_байт: ц8): ц8;
    місцева дія дізнатись_розмір_ю8(ю8: памʼять<ц8>): позитивне;
    місцева дія ю8_в_ю16(ю8: памʼять<ц8>): памʼять<ц16>;
    місцева дія ю8_в_ю32(ю8: памʼять<ц8>): памʼять<ц32>;
    місцева дія ю16_в_ю8(ю16: памʼять<ц16>): памʼять<ц8>;
    місцева дія ю16_в_ю32(ю16: памʼять<ц16>): памʼять<ц32>;
    місцева дія ю32_в_ю8(ю32: памʼять<ц32>): памʼять<ц8>;
    місцева дія ю32_в_ю16(ю32: памʼять<ц32>): памʼять<ц16>;
  }
}

секція біб {
  секція юнікод {
    місцева дія дізнатись_розмір_символа_юнікоду(перший_байт: ц8): ц8 {
      якщо (перший_байт & 0ш80) == 0ш00 {
        вернути 1;
      }
      якщо (перший_байт & 0шҐ0) == 0шВ0 {
        вернути 2;
      }
      якщо (перший_байт & 0шД0) == 0шҐ0 {
        вернути 3;
      }
      якщо (перший_байт & 0шД8) == 0шД0 {
        вернути 4;
      }
      вернути 0;
    }

    місцева дія дізнатись_розмір_ю8(ю8: памʼять<ц8>): позитивне {
      змінна розмір = 0;
      поки ю8[розмір] != 0 {
        розмір = розмір + 1;
      }
      вернути розмір;
    }

    місцева дія ю8_в_ю16(ю8: памʼять<ц8>): памʼять<ц16> {
      ціль розмір = дізнатись_розмір_ю8(ю8);
      змінна буфер = виділити<ц16>(розмір);
      змінна розмір_буфера = 0;
      змінна х = 0;
      поки х < розмір {
        ціль перший_байт = ю8[х];
        ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
        якщо розмір_символа == 1 {
          буфер[розмір_буфера] = перший_байт & (0ш7Д як ц8);
          розмір_буфера = розмір_буфера + 1;
        }
        якщо розмір_символа == 2 {
          ціль другий_байт = ю8[х + 1];
          буфер[розмір_буфера] = ((перший_байт & (0ш1Д як ц8)) << 6) | (другий_байт & (0ш3Д як ц8));
          х = х + 1;
        }
        якщо розмір_символа == 3 {
          ціль другий_байт = ю8[х + 1];
          ціль третій_байт = ю8[х + 2];
          буфер[розмір_буфера] = ((перший_байт & (0ш0Д як ц8)) << 12) | ((другий_байт & (0ш3Д як ц8)) << 6) | (третій_байт & (0ш3Д як ц8));
          х = х + 2;
        }
        якщо розмір_символа == 4 {
          ціль другий_байт = ю8[х + 1];
          ціль третій_байт = ю8[х + 2];
          ціль четвертий_байт = ю8[х + 3];
          змінна код_першої_частини = (((перший_байт & (0ш0Д як ц8)) як ціле) << 18) | (((другий_байт & (0ш3Д як ц8)) як ціле) << 12) | (((третій_байт & (0ш3Д як ц8)) як ціле) << 6) | ((четвертий_байт & (0ш3Д як ц8)) як ціле);
          код_першої_частини = код_першої_частини - 0ш10000;
          буфер[розмір_буфера] = 0шГ800 + ((код_першої_частини >> 10) & 0ш3ДД);
          буфер[розмір_буфера + 1] = 0шГВ00 + (код_першої_частини & 0ш3ДД);
          розмір_буфера = розмір_буфера + 1;
          х = х + 3;
        }
        х = х + 1;
      }
      вернути буфер;
    }
  }
}